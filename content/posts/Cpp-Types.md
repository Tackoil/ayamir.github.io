---
title: "重学C++：1.类型系统"
date: 2021-10-18T19:32:22+08:00
draft: false
keywords: ["C++"]
tags: ["C++"]
categories: ["Programming Language"]
---

## 常见的坑

1. int, short, long, long long都是带符号的，在前面添加unsigned就能得到无符号类型。

2. 字符型被分为3种：char, signed char, unsigned char，前两种并不等价。
   虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。
   
3. 有符号类型在与无符号类型运算时会隐式转换为无符号类型。

4. 虽然变量初始化时候使用了`=`号，但是初始化和变量赋值并不相同。

5. 变量默认初始化：

   |  变量类型  | 位置在函数内部 | 位置在函数外部 |
   | :--------: | :------------: | :------------: |
   |  内置类型  |   undefined    |       0        |
   | 自定义类型 |    由类决定    |    由类决定    |

   ```C++
   #include <iostream>
   
   int default_initialize(int a) {
       // 输出必定是0
       std::cout << a << std::endl;
       int b;
       return b;
   }
   
   int main() {
       int a;
       // 输出是随机值
       std::cout << default_initialize(a) << std::endl; 
   }
   ```

6. 如果在函数体内部试图初始化一个`extern`标记的变量会引发错误。

7. 在嵌套作用域中，内层作用域中的**定义**可以覆盖外层作用域中**声明**的变量。

   可以显式使用**域操作符**`::`来指明使用哪层的变量。
   
8. &和*在不同的上下文里面其含义并不相同，因此**完全可以当成不同的符号看待**。

   ```C++
   int i = 42;
   int &r = i;    // &在类型名后出现，是声明的一部分，表明r是一个引用
   int *p;        // *在类型名后出现，是声明的一部分，表明p是一个指针
   p = &i;        // &在表达式中出现，是取地址符
   *p = 43;       // *在表达式中出现，是解引用符
   int &r2 = *p;  // &是声明的一部分，*是解引用符
   ```

9. 指针可以用0进行初始化成空指针，但是不可以用0赋值。

10. 指针之间使用==来比较时，如果结果是true，对应多种情况：

    + 都是空指针
    + 都是同一个地址
      - 都指向同一个对象
      - 一个指针指向某一个对象，另一个指针指向另一对象的下一地址

## 必须要理解的点

1. 字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。

2. 变量的组成部分：类型和值。说白了就是一个定性一个定量。

   类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。

   值在实际代码运行过程中则被各种函数使用参与运算。

3. 变量声明和定义：

   声明的意思就是：我要用这个变量。

   定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。

   |                      | 声明 | 定义 |
   | :------------------: | :--: | :--: |
   | 规定变量的类型和名字 |  ✅   |  ✅   |
   |       申请空间       |      |  ✅   |
   |        初始化        |      |  ✅   |
   |       执行多次       |  ✅   |      |

   用`extern`标记**未初始化**的变量来表明只对变量作声明：

   ```C++
   extern int i;      //只声明不定义
   int i;             //声明并且定义
   extern int i = 10; //声明并且定义
   ```

   Q：为什么会有声明和定义这两个概念？

   A：因为C++支持*分离式编译*机制，这允许程序被分割成若干个文件，每个文件可以被独立编译。如果要在多个文件中使用同一个变量，就必须要将声明和定义分离。变量的定义必须且只能出现在一个文件中，其他用到这个变量的文件必须对其进行声明，且绝对不能进行重复定义。

4. 名字的作用域：

   同一个名字在不同的作用域中可以指向不同的实体。

   名字的有效区域始于**声明**语句，以**声明**语句所在的作用域末端结束。
   
5. 引用和指针——都可以用于间接访问对象
   
   |                                |    引用    |        指针         |
   | :----------------------------: | :--------: | :-----------------: |
   |            复合类型            |     ✅      |          ✅          |
   |            表示符号            |     &      |          *          |
   |              含义              | 变量的别名 | 变量在内存中的地址  |
   | 初始化和赋值时是否需要类型匹配 |  必须匹配  | 必须匹配（除void*） |
   |         是否需要初始化         | 必须初始化 |     无需初始化      |
   |      可否重新绑定其他变量      |   不可以   |        可以         |
   |          可否嵌套定义          |   不可以   |        可以         |
   
   引用：
   
   + 引用只能**绑定**在对象上，不能绑定在字面量或者表达式上。
   + 引用只是原有对象的**别名**，并非对象，因此不可以定义引用的引用。
   + 定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。
   
   指针：
   
   + 指针本身就是一个对象，能执行的操作自由度远超过引用。
   
     - 可以实现嵌套定义，即指针的指针。
   
     - 可以实现指针的引用。
   
       ```C++
       int i = 42;
       int *p;         // p是int型指针
       int *&r = p;    // r是指针p的引用（从r开始自右向左读，&表明r是一个引用，引用的是指针，指针指向的类型是int）
       
       r = &i;         // r是p的别名，即给p赋值为i的地址，即令p指向i
       *r = 0;         // r是p的别名，对r解引用即对p解引用，即将p所指向的地址处变量的值赋值为0
       ```
   
   + 指针初始化和赋值时需要使用&运算符取得对象的地址。
   
   + 指针值的情况：
     1. 指向一个对象。
     2. 指向紧邻对象所占空间的下一个位置。
     3. 空指针，没有指向任何对象。
     4. 无效指针，除上述情况之外。
     
     对第4种无效指针的操作是未定义的，后果无法预计。
     
     2、3两种值虽然有效，但是因为没有指向任何对象，所以对其操作的后果同样无法预计。
   
6. void*眼中内存空间仅仅是内存空间，并不能访问内存空间中的对象。

## 建议

1. 明确数值不可能为负时使用unsigned类型。

2. 使用int执行整数运算，范围不够时使用long long。

3. 使用double执行浮点数运算。

4. 算术表达式中不要使用bool和char。

5. 避免写出依赖实现环境的代码，否则代码不可移植。

6. 避免有符号类型和无符号类型之间的隐式类型转换。

7. C++11中引入了**列表初始化**，例如：

   ```C++
   // 传统的初始化方式
   int units_sold = 0;
   int units_sold(0);
   // 现代的初始化方式
   int units_sold{0};
   int units_sold = {0};
   ```

   列表初始化在用于内置类型变量时，如果初始值存在*丢失信息*的风险，编译器会报错。

   ```C++
   long double pi = 3.1415926536;
   int a{pi}, b = {pi};   // 错误：没有执行类型转换，因为可能丢失信息
   int a(pi), b = pi;     // 正确：执行了隐式类型转化，丢失了信息
   ```

8. 对每个内置类型的变量都执行**显式默认初始化**以防止undefined行为。

9. 在变量第一次使用的地方进行**定义**操作。

10. 初始化所有的指针，并且**在对象定义完成之后**再定义指向它的指针。

11. 避免使用0和NULL初始化空指针，应该使用**nullptr**。

12. 在使用指针之前检查其是否为**nullptr**。

13. **记住赋值改变的永远是等号左侧的对象。**

14. 面对复杂的指针或引用的声明语句时，从变量名开始自右向左阅读来弄清楚其真实含义。

