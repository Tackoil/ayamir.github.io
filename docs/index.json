[{"categories":["Programming Language"],"content":"常见的坑 所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。 string虽然不是容器，但是支持很多容器的操作。 容器不为空时：begin()返回的是容器中第一个元素的位置；end()返回的是容器中最后一个元素的后一个位置。 容器为空时：begin()和end()返回的都是最后一个元素的后一个位置。 任何可能改变容器大小的操作都会使容器的迭代器失效。 ","date":"2021-10-28","objectID":"/posts/iterator/:1:0","tags":["C++"],"title":"重学C++：容器和迭代器","uri":"/posts/iterator/"},{"categories":["Programming Language"],"content":"必须要理解的点 和指针类似的是，迭代器支持对对象的间接访问。 和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如begin(), end()。 所有迭代器都支持的运算： 运算符 例子 含义 * *iter 返回迭代器iter指向元素的引用 -\u003e iter-\u003emem 解引用iter并获取该元素名为mem的成员，即(*iter).mem ++ ++iter 令iter指向当前元素的后一个元素 – --iter 令iter指向当前元素的前一个元素 == iter1 == iter2 如果两个迭代器指向相同的元素返回true，否则返回false != iter1 != iter2 上面例子的反面 迭代器的类型有两种：iterator和const_iterator。 vector\u003cint\u003e::iterator itv; // 可用于读写vector\u003cint\u003e中的元素 string::iterator its; // 可用于读写string对象中的元素 vector\u003cint\u003e::const_iterator citv; // 只能读取元素 string::const_iterator cits; // 只能读取元素 begin()和end()返回哪一种取决于对象本身是否被const修饰。 C++11中引入了cbegin()和cend()来专门返回const_iterator。 认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。 vector和string的迭代器支持的额外的运算： 运算 含义 iter + n 运算得到一个新迭代器，指向当前元素的后n个元素的位置 iter - n 运算得到一个新迭代器，指向当前元素的前n个元素的位置 iter += n 运算得到的新迭代器赋值给iter iter -= n 同上 iter1 - iter2 两个迭代器之间的距离，可正可负 \u003e, \u003c, \u003c=, \u003e= 同两类型的下标运算符中的数字的关系，位置靠前的较小 ","date":"2021-10-28","objectID":"/posts/iterator/:2:0","tags":["C++"],"title":"重学C++：容器和迭代器","uri":"/posts/iterator/"},{"categories":["Programming Language"],"content":"建议 一般不在意迭代器的类型，因此使用auto来标注。 循环结束的判断条件习惯使用迭代器和!=，这样可以不用在意容器类型。 凡是使用了迭代器的循环体中都不能有改变容器大小的操作如push_back()。 ","date":"2021-10-28","objectID":"/posts/iterator/:3:0","tags":["C++"],"title":"重学C++：容器和迭代器","uri":"/posts/iterator/"},{"categories":["Programming Language"],"content":"常见的坑 vector的默认初始化是否合法取决于vector内对象所属的类是否要求显式初始化。 使用()和{}对vector执行初始化含义不同。 using std::vector; vector\u003cint\u003e v1{10}; // 存储1个int对象，值为10 vector\u003cint\u003e v2(10); // 存储10个int对象，值为0 vector\u003cint\u003e v3(10, 1); // 存储10个int对象，值都是1 vector\u003cint\u003e v4{10, 1}; // 存储2个int对象，值分别是10和1 使用{}执行列表初始化时按照顺序遵守2个守则： 如果{}内容可以用于初始化，则采用{}默认的初始化含义。 如果{}中的内容无法用{}默认的初始化含义做出解释，则会按照()的初始化含义去解释{}。 using std::vector; using std::string; vector\u003cstring\u003e v1{\"hi\"}; // 存储1个值为hi的string对象 vector\u003cstring\u003e v2{10}; // 存储10个值为空的string对象 vector\u003cstring\u003e v3{10, \"hi\"}; // 存储10个值为hi的string对象 与string相同，vector也有size_type作为其size()的返回值类型。 但是使用时必须首先指定vector由哪个类型定义。 std::vector\u003cint\u003e::size_type a; // 正确 std::vector::size_type a; // 错误 只有vector内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。 增加vector中的元素只能使用push_back()，而不能使用对下标赋值的方式。 ","date":"2021-10-28","objectID":"/posts/vector/:1:0","tags":["C++"],"title":"重学C++：标准库类模板Vector","uri":"/posts/vector/"},{"categories":["Programming Language"],"content":"必须理解的点 vector是类模板而非类型。 vector中只能容纳对象，不能容纳引用。 vector对象能高效增长，增加vector中的元素需要使用push_back()成员函数。 vector的成员函数（empty(), size()）和各种运算符（赋值、关系、下标）的操作使用方法和规则基本同string。 ","date":"2021-10-28","objectID":"/posts/vector/:2:0","tags":["C++"],"title":"重学C++：标准库类模板Vector","uri":"/posts/vector/"},{"categories":["Programming Language"],"content":"建议 不需要在创建vector时确定其中的元素及其大小。 在循环体内部包含向vector对象添加元素的操作时，不应该使用foreach循环。 ","date":"2021-10-28","objectID":"/posts/vector/:3:0","tags":["C++"],"title":"重学C++：标准库类模板Vector","uri":"/posts/vector/"},{"categories":["Programming Language"],"content":"常见的坑 string.size()和string.length()等价。 string.size()和其他STL容器的命名风格相一致（如vector, map）。 string.length()出现主要是因为这样的命名符合人的直觉，有更好的可读性。 string::size_type是无符号类型，和int不同，能存放下任何string对象的大小。 +两边至少有一端需要是string对象，不允许两个字符串字面量单独相加。 using std::string; string a = \"a\"; string b = a + \"b\" + \"c\"; // 正确，从左到右运算时能保证至少一段是string对象 string c = \"b\" + \"c\" + a; // 错误，从左到右运算时第一个+左右都是字符串字面量 ","date":"2021-10-28","objectID":"/posts/string/:1:0","tags":["C++"],"title":"重学C++：标准库类型string","uri":"/posts/string/"},{"categories":["Programming Language"],"content":"必须要理解的点 string的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。 string.size()返回值类型为string::size_type，出现这种类型是为了体现标准库类型和机器无关的特性。 string对象的比较运算完全实现了运算符重载（==, !=, \u003c,\u003c=, \u003e, \u003e=）。 ==表明两个对象的内容和长度完全一致，反之任一不同则!=。 不等关系运算符比较的法则： 如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。 如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。 string对象赋值操作就是内容的替换。 string对象相加操作就是内容的拼接，+=操作同理。 string对象可以与字符串字面量相加。 形如cname的C++头文件兼容形如ctype.h的C头文件，C++头文件中定义的名字可以在std中找到。 ","date":"2021-10-28","objectID":"/posts/string/:2:0","tags":["C++"],"title":"重学C++：标准库类型string","uri":"/posts/string/"},{"categories":["Programming Language"],"content":"建议 表达式中出现string.size()函数时就不应该使用int类型，这样可以避免int和unsigned混用的问题。 C++和C兼容的头文件作选择时，选择C++的头文件。 处理string对象中每一个字符时，使用foreach语句。 #include \u003ciostream\u003e#include \u003ccctype\u003e using std::string; string str{\"Some String\"}; for (auto c : str) { std::cout \u003c\u003c c \u003c\u003c std::endl; } // 使用引用来改变原字符串内容 for (auto \u0026c : str) { c = std::toupper(c); } std::cout \u003c\u003c str \u003c\u003c std::endl; 处理string对象中特定字符时使用[]（下标运算符）或者迭代器。 使用[]访问字符之前检查string对象是否为空。 std::string s = \"a\"; if (!s.empty()) { std::cout \u003c\u003c s[0] \u003c\u003c std::endl; } string对象下标使用string::size_type作为类型而非int。 using std::string; string a = \"Hello, world!\"; string::size_type index_of_space = a.find(\" \"); ","date":"2021-10-28","objectID":"/posts/string/:3:0","tags":["C++"],"title":"重学C++：标准库类型string","uri":"/posts/string/"},{"categories":["Programming Language"],"content":"常见的坑 auto可以在一条语句中声明多个变量，但是所有变量的类型必须一致。 decltype在分析表达式类型时并不执行表达式。 decltype处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。 decltype((variable))的结果永远是引用。 decltype(variable)的结果只有当variable是引用时才是引用。 ","date":"2021-10-26","objectID":"/posts/auto/:1:0","tags":["C++"],"title":"重学C++：类型推导","uri":"/posts/auto/"},{"categories":["Programming Language"],"content":"必须要理解的点 auto用于变量初始化时的类型推导，decltype用于分析表达式的类型。 auto对引用类型推导时实际上用的是引用对象的值。 auto与const：详见重学C++：Const二三事。 decltype与const：详见重学C++：Const二三事。 ","date":"2021-10-26","objectID":"/posts/auto/:2:0","tags":["C++"],"title":"重学C++：类型推导","uri":"/posts/auto/"},{"categories":["Programming Language"],"content":"建议 auto尽量只在类型较长但比较清晰时使用。 decltype尽量不要使用。 ","date":"2021-10-26","objectID":"/posts/auto/:3:0","tags":["C++"],"title":"重学C++：类型推导","uri":"/posts/auto/"},{"categories":["Programming Language"],"content":"常见的坑 仅用const修饰的对象只在单个文件中有效，如果想在多个文件之间共享const对象，必须在对象定义的前面加extern。 允许为一个常量引用绑定非常量的对象、字面量和表达式。 int i = 42; const int \u0026r1 = i; // 正确 const int \u0026r2 = 42; // 正确 const int \u0026r3 = r1 * 2; // 正确 int \u0026r4 = r1 * 2; // 错误 int \u0026r5 = i; r5 = 0; // 正确 r1 = 42; // 错误 指向常量的指针和常量指针： int err_numb = 0; const double pi = 3.1415; int *const cur_err = \u0026err_numb; const double *mut_pi_pointer = \u0026pi; const double *const pi_pointer = \u0026pi; 从声明语句的变量符号开始，自右向左看： cur_err首先是一个不可变对象，其次是一个指向int类型可变对象的指针。 mut_pi_pointer首先是一个可变对象，其次是一个指向double类型不可变对象的指针。 pi_pointer首先是一个不可变对象，其次是一个指向double类型不可变对象的指针。 当typedef遇到const时容易出现错误理解： typedef char *pstring; const pstring cstr = 0; const pstring *ps = 0; pstring是char *的别名，即指向char的指针。 const修饰的是pstring，因此cstr是：初始化值为nullptr的不可变指针。 错误理解会用char *替换掉pstring，即： const char *cstr = 0; 这样从cstr开始自右向左读的话，cstr就会被理解成：指向字符常量的可变指针。 constexpr属于顶层const，因此constexpr修饰指针意味着指针本身不可变。 auto默认会去除顶层const，保留底层const，如果需要顶层const则需要显式加入。 int i = 0; const int ci = i, \u0026cr = ci; auto b = ci; // b是一个初始化值为0的可变int对象 auto c = cr; // c同b auto d = \u0026i; // d是一个初始化为指向可变int类对象i的可变指针对象 auto e = \u0026ci; // e是一个初始化为指向不可变int类对象ci的可变指针对象 const auto f = ci; // f是一个初始化值为0的不可变int对象 decltype不会去除顶层const。 const int ci = 0; decltype(ci) x = 0; // x的类型是const int ","date":"2021-10-26","objectID":"/posts/const/:1:0","tags":["C++"],"title":"重学C++：Const二三事","uri":"/posts/const/"},{"categories":["Programming Language"],"content":"必须要理解的点 const对象在创建时必须进行初始化。 常量引用即对const对象的引用。 常量引用绑定不可变对象和可变对象时含义不同。 可变对象 不可变对象 用常量引用绑定 可以 必须 常量引用的含义 不能通过此引用改变对象的值 不可以改变对象的值 常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。 非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。 因为指针是对象，而引用不是对象，所以const和指针的组合有2种情况，const和引用的组合只有1种情况。 指针 指向常量的指针（pointer to const）：不能通过此指针修改对应的量。 常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。 引用 常量引用：不能通过此引用修改对应的量。 顶层const表示指针本身是常量，推广之后可以指任意对象是常量； 底层const表示指针指向的对象是常量，推广之后主要于指针和引用等复合类型的基本类型部分有关。 常量表达式指：值不会改变，在编译过程中就能得到计算结果的表达式。 为什么需要constexpr？ 因为实际中很难判断一个初始值是否为常量表达式。 使用constexpr相当于把验证变量的值是否是一个常量表达式的工作交给了编译器。 用constexpr声明的变量一定是一个变量，并且必须用常量表达式来初始化。 ","date":"2021-10-26","objectID":"/posts/const/:2:0","tags":["C++"],"title":"重学C++：Const二三事","uri":"/posts/const/"},{"categories":["Programming Language"],"content":"建议 如果认定变量是一个常量表达式，那就将其声明成constexpr类型。 ","date":"2021-10-26","objectID":"/posts/const/:3:0","tags":["C++"],"title":"重学C++：Const二三事","uri":"/posts/const/"},{"categories":["Programming Language"],"content":"常见的坑 \u0026和*在不同的上下文里面其含义并不相同，因此完全可以当成不同的符号看待。 int i = 42; int \u0026r = i; // \u0026在类型名后出现，是声明的一部分，表明r是一个引用 int *p; // *在类型名后出现，是声明的一部分，表明p是一个指针 p = \u0026i; // \u0026在表达式中出现，是取地址符 *p = 43; // *在表达式中出现，是解引用符 int \u0026r2 = *p; // \u0026是声明的一部分，*是解引用符 指针可以用0进行初始化成空指针，但是不可以用0赋值。 指针之间使用==来比较时，如果结果是true，对应多种情况： 都是空指针 都是同一个地址 都指向同一个对象 一个指针指向某一个对象，另一个指针指向另一对象的下一地址 ","date":"2021-10-26","objectID":"/posts/reference-and-pointer/:1:0","tags":["C++"],"title":"重学C++：引用和指针","uri":"/posts/reference-and-pointer/"},{"categories":["Programming Language"],"content":"必须要理解的点 引用和指针——都可以用于间接访问对象 引用 指针 复合类型 ✅ ✅ 表示符号 \u0026 * 含义 变量的别名 变量在内存中的地址 初始化和赋值时是否需要类型匹配 必须匹配（除常量引用） 必须匹配（除void*和指向常量的指针） 是否需要初始化 必须初始化 无需初始化 可否重新绑定其他变量 不可以 可以 可否嵌套定义 不可以 可以 引用： 引用只能绑定在对象上，不能绑定在字面量或者表达式上。 引用只是原有对象的别名，并非对象，因此不可以定义引用的引用。 定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。 指针： 指针本身就是一个对象，能执行的操作自由度远超过引用。 可以实现嵌套定义，即指针的指针。 可以实现指针的引用。 int i = 42; int *p; // p是int型指针 int *\u0026r = p; // r是指针p的引用，从r开始自右向左读，\u0026表明r是一个引用，引用的是指针，指针指向的类型是int r = \u0026i; // r是p的别名，即给p赋值为i的地址，即令p指向i *r = 0; // r是p的别名，对r解引用即对p解引用，即将p所指向的地址处变量的值赋值为0 指针初始化和赋值时需要使用\u0026运算符取得对象的地址。 指针值的情况： 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针，没有指向任何对象。 无效指针，除上述情况之外。 对第4种无效指针的操作是未定义的，后果无法预计。 2、3两种值虽然有效，但是因为没有指向任何对象，所以对其操作的后果同样无法预计。 void*眼中内存空间仅仅是内存空间，并不能访问内存空间中的对象。 ","date":"2021-10-26","objectID":"/posts/reference-and-pointer/:2:0","tags":["C++"],"title":"重学C++：引用和指针","uri":"/posts/reference-and-pointer/"},{"categories":["Programming Language"],"content":"建议 初始化所有的指针，并且在对象定义完成之后再定义指向它的指针。 避免使用0和NULL初始化空指针，应该使用nullptr。 在使用指针之前检查其是否为nullptr。 记住赋值改变的永远是等号左侧的对象。 面对复杂的指针或引用的声明语句时，从变量名开始自右向左阅读来弄清楚其真实含义。 ","date":"2021-10-26","objectID":"/posts/reference-and-pointer/:3:0","tags":["C++"],"title":"重学C++：引用和指针","uri":"/posts/reference-and-pointer/"},{"categories":["Immersive Video"],"content":"概述 360度视频的推流手段逐渐从视角独立型方案变成基于tile的视角依赖型方案。 相比于常规视频，360度视频被编码成全向的场景。 自适应360度视频推流利用DASH框架来实现比特率的自适应。 ","date":"2021-10-25","objectID":"/posts/note3/:1:0","tags":["Immersive Video"],"title":"自适应360度视频推流方案","uri":"/posts/note3/"},{"categories":["Immersive Video"],"content":"分类 ","date":"2021-10-25","objectID":"/posts/note3/:2:0","tags":["Immersive Video"],"title":"自适应360度视频推流方案","uri":"/posts/note3/"},{"categories":["Immersive Video"],"content":"Viewport-Independent Streaming 服务端的任务 使用如ERP、CMP等视角独立型的投影方式，360度视频被投影到一个球体上。 客户端的任务 投影之后的视频直接被传送到客户端，并不需要来自传感器的方向信息。 客户端需要支持对应的投影格式。 客户端像处理传统视频一样完成比特率自适应。 基于网络特征向将要到来的segment请求相同投影格式的表示 DASH插件需要支持相同质量视频的推流。 应用 视角独立型推流主要用于体育、教育和旅游视频内容。 优点 简单 缺点 相比于视角依赖型方案视频编码效率低了30%。 为不可见的区域要求大量带宽和解码资源。 ","date":"2021-10-25","objectID":"/posts/note3/:2:1","tags":["Immersive Video"],"title":"自适应360度视频推流方案","uri":"/posts/note3/"},{"categories":["Immersive Video"],"content":"Viewport-Dependent Streaming 终端设备的任务 只接受特定的视频帧内容，包括等于或大于视角角度的可见信息。 监测相关的视角作为用户头部移动的回应，并且向服务端发送信号来精确播放器信息。 为服务端准备和用户方向相关的几个自适应集。 客户端的任务 根据网络情况和估计的视角位置决定获取哪个自适应集。 难点 可视区域的确定 与用户头部移动的同步 质量调整 提供平滑的播放体验 现有的工作 各种投影方式在实际推流中表现如何？ 相比于金字塔格式，为视角依赖型投影方案提出的多分辨率变体有最好的研究和开发(RD)性能。 偏移CMP获得了5.6%到16.4%的平均可见质量。 提出的框架可以基于已知的网络资源和未来的视角位置适应视角的尺寸和质量。 相比于理想的下载过程，这种二维自适应策略可以花费20%的额外网络带宽下载超过57%的额外视频块。 如何在网络资源受限的情况下提供高质量的推流？ 为视角依赖型推流产生不同质量的segment。 当流中只有有限的representation时，利用Quality Emphasized Regions策略来缩放特定区域的分辨率。 在拥塞网络条件下，执行了基于网络回应的视角大小和比特率的联合适应，结果显示，相比于传送全部的360度场景，动态的视角覆盖率提供了更好的画面质量。 这种基于网络回应的自适应也确保基于整体拥塞变化做调整时能改善视频质量。 为立体视频的背景和前景视图采用不对称质量。 可以分别为背景块和前景块分别节省15%和41%的比特率。 DASH需要做什么？ manifest中需要包含视角位置信息和投影元数据。 优化获取random access point的周期来优化视角分辨率自适应体验。 考虑低延迟和活跃的视角切换。 ","date":"2021-10-25","objectID":"/posts/note3/:2:2","tags":["Immersive Video"],"title":"自适应360度视频推流方案","uri":"/posts/note3/"},{"categories":["Immersive Video"],"content":"Tile-based Streaming 传统视频被分成多个块，360度视频在块的基础上还被分成多个大小相等或者不等的tile，以此更加精确地调整画面的细节质量。 分块策略 基本完全交付 高级完全交付 部分交付 分块模式 1x1，3x2，5x3，6x4，8x5 其中6x4的模式实现了较好的带宽消耗和编码效率的折中。 在不同的带宽条件下，基本完全交付策略获得了大约65%的带宽节约。 具体方案 ClusTile 基于分簇的方式，推送满足最小带宽需求的tile来克服编码效率和计算开销。 相比于传统和高级的基于tile的推流方案，分别实现了72%和52%的带宽节约。 当实际看到的和下载的tile有差异时，基于分簇的tile选取可能会导致选择不当。 Ghosh’s work 提议以最低可获得的质量下载周围和远处的tile。 相比于其他算法，视角及其周边区域的可变质量提高了20%的QoE水平。 Ozcinar’s work 介绍了一种自适应 360° 视频流框架。 利用视觉注意力度量来计算每个帧的最佳平铺模式。 使用选中的模式，为不同区域的tile分配非统一的比特率。 比特率的选取取决于估计的视角和网络状况。 因为很大部分的带宽被用于传输非视角内的tile，框架难以优化视角内的质量。 Xie’s work 提出了一套优化框架，以此来最小化预取tile的错误，改善与不同比特率相关联的tile边界的平滑程度。 定义了两个QoE函数，目标是最小化： 预期质量失真$\\Phi(X)$ 当考虑tile看到概率时视角的空间质量方差$\\Psi(X)$： $$ \\Phi(X) = \\frac{\\sum_{i=1}^{N}\\sum_{j=1}^{M}D_{i,j} * x_{i,j} * p_{i,j}}{\\sum_{i=1}^{N}\\sum_{j=1}^{M}x_{i,j} * s_{i}} $$ $$ \\Psi(X) = \\frac{\\sum_{i=1}^{N}\\sum_{j=1}^{M}x_{i,j}*p_i * (D_{i,j} - s_i * \\Phi(X))^{2}}{\\sum_{i=1}^{N}\\sum_{j=1}^{M}x_{i,j}*s_i} $$ 基于目标缓冲区的自适应方法用于在需要短期视口预测的小缓冲区下进行平滑播放 在自适应的第k步，当第k个segment集合下载完成时，缓冲区占用率$b_k$由下面的式子给出： $$ b_k = b_{k-1} - \\frac{R_k*T}{C_k} + T $$ 为了避免用尽所有块，缓冲区的占用率被通过设定一个目标缓冲区水平$B_{target}$所控制，即$b_k = B_{target}$。 平均空间质量方差是0.97，比其他基于tile的策略小。 所提出的概率自适应框架在感知质量上实现了约 39% 的增益，平均降低了 46% 的空间质量方差。 Vander Hooft’s work 将360度帧划分成视角内区域和视角外区域。 首先为所有区域都选择最低质量，然后提高视角内tile的质量。 如果带宽依然可用，接着提高剩下的tile的质量。 启发式的方式在带宽可用的基础上积极提高视角内tile的质量。 没有考虑视角比特率调整时视角预测的错误。 Nguyen’s work 提出了一种新的自适应机制，它在每个segment中同时考虑头部移动和视角的预测错误，动态地决定视角内的比特率。 联合适应扩展块的覆盖范围和比特率。 在不同记录的用户头部运动下的实验评估表明，在不获取非视角内区域过多带宽利用率的情况下，视角内容质量有所提高。 DASH SRD扩展 DASH的SRD扩展提供了多种版本的tile的关联来节省更多的比特率。 Le Feuvre and Concolato’s work 他们应用了这个SRD特性，引入了同时为独立的和运动受限的HEVC tile的不同优先级设定，以此来高效地实现基于tile的方案。 使用开源的GPAC多媒体框架开发了一个DASH客户端，以此来执行带有可配置参数的基于tile的推流。 D’Acunto’s work 提出了一种 MPEG-DASH SRD 方法来促进可缩放和可平移视频的平滑推流。 总是下载低分辨率的tile来避免用户移动视角时的重新缓冲。 当前视野区域被上采样并展示给用户，以此来支持高质量的缩放功能。 用JavaScript实现了SRD视频播放器。 Hosseini’s work 基于SRD实现了视角内容、相邻tile和剩余tile的优先级推流。 用6个3D网格构建了一套3D座标系来在3D空间中平滑地表示tile。 相比于基础的方式，这种区分质量的推流方案节省了72%的带宽。 Kim and Yang’s work 使用改进的MPEG-DASH SRD来在质量可变的tile层中作选择。 基于他们之前的工作设计并实现了一个支持多层渲染的 360° VR 播放器，以支持高度不可预测的头部运动数据的高分辨率和低延迟流。 Motion-Constrained TileSet 在HEVC中，运动约束贴图集(MCTS)是将整个帧表示为子视频的相邻分割，并为自由选择的贴图集提供解码支持。 Zare’s work 将MCTS的概念应用到了全景视频推流中。 将两个质量版本的视频分割成tile，以原始的分辨率推流视角内的tile，以低分辨率推流剩余的tile。 它已经表明，选定图块的可变比特率会降低 30% 到 40% 的比特率。 Skupin’s work 陈述了一种使用HEVC编码器的基于tile的可变分辨率的推流系统。 使用立方贴图投影的360度视频被分割成24个网格，每个代表了一个独立的比特流。 两种不同质量的版本被推流到客户端，例如8个tile以高质量推送，16个tile以低质量推送。 Son’s work 在基于视角的移动VR推流中，为独立的tile提取和传输实现了基于MCTS的HEVC和可缩放的HEVC编解码器。 节省了超过47%的带宽。 相比于原始的HM和SHM编码器表现不佳，因为MCTS限制了时间运动信息。 Lee’s work 用MCTS编码360度视频tile，并使用显著性检测网络将混合质量的视频tile推流给终端用户。 通过显著性模型改进MCTS的使用，可以在不增加任何复杂性的情况下灵活地对感兴趣的tile区域进行解码支持。 Scalable Video Code 可伸缩视频编码SVC是实现viewport自适应的一种替代策略。 基础层总被需要并且能从客户端预取来避免重新缓冲事件。 提高层改善viewport质量并且可以在带宽充足的时候被请求。 SVC促进了一种高效的网络内缓存支持来减少多个客户端请求相同内容时的分发开销。 Nasrabadi’s work 使用了一种可伸缩编码方案来解决360度视频推流的重新缓冲的问题。 存在质量波动的问题，因为没有使用任何机制来处理viewport的预测错误。 Nguyen’s work 建议使用SVC协同viewport预测来克服网络信道和头部运动的随机性。 实验表明，所提出的平铺层更新和后期平铺终止特征可使viewport质量提高17%。 AI方法的应用 背景：传统视频推流中使用强化学习来高效调整视频比特率和实现长期的QoE回报。 和传统视频内容不同，360度视频包含几个新的方面比如tile大小、viewport预测等。 直接将现有的强化学习自适应策略应用到360度视频上可能会降低推流性能。 Fu’s work 为360度视频提出了称为360SRL的一种序列化强化学习方法，它基于之前决策的QoE回报而非估计的带宽状况做出自适应决策。 360SRL使用基于tile的推流模拟器来增强训练阶段。 跟踪驱动的评估表明，360SRL比基线适应方法取得了12%的QoE改善。 Jiang’s work 基于历史带宽、缓冲区空间、tile大小和viewport预测错误等，利用强化学习来做viewport和非viewport内tile的比特率选择。 所提出系统的架构由状态缓冲区、视口预测 (VPP) 和tile比特率选择 (TBS) 代理组成。 状态缓冲区向VPP和TBS代理提供用户查看模式和网络状态。 VPP代理然后使用LSTM模型估计下一个viewport位置。 TBS 代理由 Asynchronous Advantage Actor-Critic (A3C)算法训练以执行合适的比特率决策。 Quan’s work 通过卷积神经网络(CNN)提取像素运动来分析用户QoE，并使用它对tile动态分组，从而在视频质量和编码效率之间提供重要的平衡。 使用了基于强化学习的自适应代理，它可以智能地使每个图块的质量适应动态环境。 使用真实LTE带宽跟踪验证该方案，在感知质量方面表现出了卓越的性能，同时也节省了带宽资源。 背景：深度学习使强化学习能够使用多方面的状态和动作空间进一步优化聚合回报。 Kan and Xiao’s work 设计了一套深度强化学习的框架，基于对环境因素的探索和开发，自适应地调整推流策略。 这两种方案都采用DRL的A3C算法来进行比特率决策，因为A3C算法能使代理变得越来越智能化。 性能评估表明，所提出的系统平衡了各种 QoE 指标，包括平均视觉质量、平均质量波动和重新缓冲事件等。 Zhang’s work 提出了一个深度强化学习模型，它考虑viewport预测准确度和网络状况，使用基于LSTM的ACTOR-CRITIC(AC)网络动态地学习适应比特率分配。 方案能够很好地适应广泛的动态特性，并且与传统方法相比，提供了20%到30%的改进QoE","date":"2021-10-25","objectID":"/posts/note3/:2:3","tags":["Immersive Video"],"title":"自适应360度视频推流方案","uri":"/posts/note3/"},{"categories":["Immersive Video"],"content":"概述 自适应方案可以在处理不同目标对象时帮助改善推流体验。 目标主要包括视频质量、功耗、负载均衡等在移动无线网和有线网接入的情形。 适应性的视频比特率需要同时匹配网络条件和质量目标的需求。 ","date":"2021-10-21","objectID":"/posts/note2/:1:0","tags":["Immersive Video"],"title":"自适应视频推流方案","uri":"/posts/note2/"},{"categories":["Immersive Video"],"content":"分类 ","date":"2021-10-21","objectID":"/posts/note2/:2:0","tags":["Immersive Video"],"title":"自适应视频推流方案","uri":"/posts/note2/"},{"categories":["Immersive Video"],"content":"服务端适应 大多数服务端适应的方案要求客户端发送系统或网络相关信息。 质量导向的适应方案（Quality-Oriented Adaptive Scheme/QOAS） 向终端用户提供了高知觉质量的媒体内容。 QOAS是C-S架构，决策在服务器端产生。 QOAS基于客户知觉质量的反馈，提供对推流质量等级的调整。 智能优先级适应方案（intelligent Prioritized Adaptive Scheme/iPAS） 专用于802.11网络。 iPAS服务器上的基于固有印象的带宽分配模块被用于组合QoS相关的参数和视频内容特征来进行内容的优先级分类和带宽份额分配。 通过区分多媒体流，iPAS提供可用无线信道的优先级分配。 设备导向的适应方案（Device-Oriented Adaptive multimedia Scheme/DOAS） 专用于LTE网络，建立在LTE下行链路调度机制之上。 DOAS专门根据设备特性实现适配，尤其为多屏终端用户提供了卓越的QoE。 ","date":"2021-10-21","objectID":"/posts/note2/:2:1","tags":["Immersive Video"],"title":"自适应视频推流方案","uri":"/posts/note2/"},{"categories":["Immersive Video"],"content":"客户端适应 基于吞吐量的自适应方案 这类方案基于估计的网络吞吐量从服务端选择视频的比特率。 HTTP客户端通过之前的观察记录来估计网络的吞吐量。 通过测量端获取时间（segment fetch time/SFT）来代表发起和收到回复的瞬时HTTP GET请求之间的时间段，以此来确定一个推流会话中吞吐量的变化，进而独立地做出适应决策。 在分布式网络中，同时考虑并发和顺序的SFT。通过比较实际的和理想的SFT来选择未来的segment的质量等级。 FESTIVE算法 适用于多个HAS客户端共享一个常见的拥塞带宽链路的情形。 以效率、稳定性、公平性为度量因素的适应性算法。 探索了一种为分段调度、吞吐量估计和比特率选择而生的健壮的机制。 包含一个随机调度器来调度下一个视频块的下载。 多个客户端共享容量为$W$的满带宽链路，每个客户端$x$在$t$时刻播放的视频比特率为$b_x,_t$ ，需要避免以下3种问题： Inefficiency：多个HAS客户端必须能选择最可能的表示来提高QoE。 $$ Inefficiency = \\frac{|\\sum_{x}b_x,_t - W|}{W} $$ 低Inefficiency值表明多个客户端对带宽实现了最有效的利用。 Unfairness：可用带宽应该被均等地分配。 $$ Unfairness = \\sqrt{1-JainFair} $$ 低Unfairness值表明多个客户端有相近的比特率。 Instability：不必要的比特率切换会损害推流体验 $$Instability = \\frac{\\sum_{d=0}^{k-1}|b_{x,t-d} - b_{x,t-d-1}|*w(d)}{\\sum_{d=1}^{k}b_{x,t-d} * w(d)}$$ Probe AND Adapt(PANDA)算法 用于检测网络状况，考虑未来比特率选择的平均目标数据比特率。 目标是当多个HAS客户端共享一个拥塞带宽信道时，通过正确探测网络，进而最小化比特率震荡。 PANDA算法在性能上击败了FESTIVE算法，并且PANDA算法在这些解决方案中表现出了最好的适应性，在不同带宽情况和播放器设置下实现了最优的效率、公平性和稳定性。 整体上的推流质量不只依赖于本地的吞吐量测量，还依赖服务端的网络容量。 利用服务器发起的推送机制来降低DASH内容推流到移动客户端的端到端延迟。 利用HTTP/2的流终止特性来实现中间质量调整。 基于估计的用户QoE，功耗和可用资源来改善用户端的推流体验。 虽然有证据表明性能得到了提高，但是评估工作只是在受控的LAN环境下有效。 Cross Session Stateful Predictor(CS2P)方案 一种数据驱动的吞吐量估计方案，以克服不准确的 HAS 流量预测问题。 将共享相似特性的推流会话分簇，然后对每个簇使用隐马尔科夫模型预测相应的吞吐量样本。 在一个大规模数据集上实验性的评估表明：CS2P高效地估计了可用的网络吞吐量，进而改善了整体上的视频比特率的适应性。 CFA和Pytheas等方案和CS2P类似，也使用数据驱动的控制器来估计可用的吞吐量。 但是这些工作不支持异构系统并且需要额外的训练复杂性，使其不够具有吸引力。 基于吞吐量的适应性方案主要的挑战在于对吞吐量的精确估计。 为360度视频采用一个没有经过精巧设计的吞吐量估计机制可能会导致不稳定性和较差的QoE，在高度动态化的无线和蜂窝网络中尤甚。 基于缓冲区的自适应方案 客户端会在播放视频时根据当前缓冲区的占用情况请求将要到来的segment。 如何克服不完整的网络信息的限制 在多客户端启用缓存的环境中，结合客户端测量工具集和补偿算法构造模型。 这个模型可以高效探测比特率切换时间并通过选择切换适当的比特率来进行补偿，最终实现了可达20%的比特率改善。 Buffer Based Adaptation(BBA)方法 应用于Netfix客户端时可以减少可达20%的重新缓冲事件。 BBA方法考虑的缓冲区较大，因此对于比较短的视频不一定有这样的性能。 Buffer Occupancy-based Lyapunov Algorithm(BOLA) 把比特率适应性问题看作是与播放质量和重新缓冲时间相关的最优化问题。 BOLA旨在通过把缓冲区大小保持在设定的目标水平来避免重新缓冲。 对于缓冲区级别的突然下降，BOLA通过请求最低可用视频比特率来避免停顿事件的频率。 如何优化缓冲区利用率 Adaptation and Buffer Management Algorithm(ABMA+) 基于重新缓冲事件的可能性确定未来representation的下载时间。 通过基于预先计算的缓冲区大小和segment下载时间选择最大比特率来确保流畅的播放。 这样可以实现低计算开销的良好部署。 Scalable Video Coding(SVC)/Bandwidth Independent Efficient Buffering(BIEB) 基于层分发获取视频块，进而维持稳定的缓冲区大小来避免频繁的中断。 没有考虑QoE模型中的卡顿和质量切换。 涉及额外的编码和处理开销。 使用PID控制器的控制论方法 强制执行缓冲区设置点来使缓冲区保持在最佳水平。 略微降低视频比特率，以防止不必要的视频比特率调整。 在多个客户端竞争的情况下，不能保证公平性。 如何降低DASH流的排队延迟 DASH流会经历最长可达1s的排队延迟和严重拥塞，导致缓冲区膨胀问题，而这会严重损害实时多媒体服务的QoE。 旨在减少网络拥塞的主动队列管理 (AQM) 策略并没有充分减少这种不必要的延迟。 DASH客户端根据网络设备的队列大小动态接收窗口大小可以显著减轻缓冲区膨胀效应。 由于长期的viewport预测的高度不确定性，充足的缓冲区空间对于360度视频的流畅播放来说并不可行。 通常小于3s的缓冲区大小对于短期的viewport预测来讲比较适合。 由于小缓冲区很有可能造成播放卡顿，因此较短持续时间的segment可以被用于基于tile的流中，但是相比于长持续时间的segment，这样也会降低编码效率。 混合自适应方案 客户端同时考虑吞吐量和播放缓冲信号来确定即将到来的segments的视频比特率。 Model Predictive Control(MPC) 利用良好定义的参数集合来估计可用的网络和缓冲区资源，进而为高QoE的比特率做出最优调整的控制论方法。 提出的QoE模型采用视频的平均质量$R_k$，平均比特率切换，重新缓冲事件，和初始延迟$T_s$作计算： $$ QoE_1^K = \\sum_{k=1}^{K}q(R_k) - \\lambda\\sum_{k=1}^{K-1}|q(R_{k+1}) - q(R_k)| - \\mu\\sum_{k=1}^{K}(d_k(R_k)/C_k - B_k)_+ - \\mu_sT_s $$ $C_k$：第k个块的可用带宽，$B_k$：第k个块的可用缓冲区大小 $\\lambda, \\mu, \\mu_s$：可以根据用户兴趣进行调整的权重 MPC用调和平均的方法来估计吞吐量，并且能够明确管理复杂的控制对象。 只研究了单播放器的情况，因此没有公平性的考量。 Throughput and Buffer Occupancy-based Adaptation(TBOA) 选择合适的视频比特率来获得单个或多个客户端环境中改进的推流体验。 激进地提高了比特率来最高效地利用可用的带宽。 等待缓冲区超过某个级别，然后降低比特率以获得稳定的性能。 为缓冲区等级设置三个阈值，例如： $0 \u003c B_{min} \u003c B_{low} \u003c B_{high}$ 目标区间在$B_{low}$和$B_{high}$之间。 算法努力使最优区间$B_{opt}满足$ $B_{opt} = B_{low} + B_{high} \\over 2$。 通过控制$B_{low}$和$B_{high}$的阈值，使缓冲区和比特率的变化稳定来应对未知的TCP吞吐量。 算法表现的流畅而公平，但是没有把用户满意度的度量考虑在内。 fuzzy logic-based DASH 控制重新缓冲事件和视频推流的质量。 考虑了平均吞吐量的估计方法，获得了更高的视频比特率和更少的质量波动。 没有考虑QoE度量。 为了更好地调整比特率做出的改进： 用Kaufman’s Adaptive Moving Average/KAMA测量法估计吞吐量。 用Grey Prediction Model/GPM来估计缓冲区等级。 竞争流模拟环境中，改进所取得的效果： 平均情况下达到50%的公平性。 最好情况下达到17%的更好的接收质量。 Spectrum-based Quality Adaptation(SQUAD)算法 解决吞吐量预测和缓冲区等级估计的不连续性。 吞吐量和缓冲区等级反馈信号都被用于选择恰当的质量。 在一开始获取最低质量的segment来减少启动时间。 在视频质量切换频率和幅度方面性能显著提高。 尚未有方案讨论如何在视频质量和带宽利用率之间做出很好的平衡。 Throughput Friendly DASH/TFDASH 获得多个竞争客户端情形下的公平性、稳定性和效率。 通过避免OFF端获得了最大并且公平的带宽利用率。 双阈值的缓冲区保证播放时的稳定性。 在单客户端的环境中，混合适应方案表现的很合理。 但是多个客户端一起竞争带宽时会迅速扼杀整个网络。 当客户端的缓冲区达到了最大阈值时，客户端进入了ON-OFF阶段，此时客户端只对自己的视频比特率","date":"2021-10-21","objectID":"/posts/note2/:2:2","tags":["Immersive Video"],"title":"自适应视频推流方案","uri":"/posts/note2/"},{"categories":["Immersive Video"],"content":"360度流媒体视频框架 ","date":"2021-10-20","objectID":"/posts/note1/:1:0","tags":["Immersive Video"],"title":"360度流媒体面临的挑战、机遇和解决方案","uri":"/posts/note1/"},{"categories":["Immersive Video"],"content":"视频采集和拼接 使用不同的360度视频采集相机可以将视频内容存储为3D的球形内容 ","date":"2021-10-20","objectID":"/posts/note1/:1:1","tags":["Immersive Video"],"title":"360度流媒体面临的挑战、机遇和解决方案","uri":"/posts/note1/"},{"categories":["Immersive Video"],"content":"使用不同的投影策略实现降维 策略主要分为2种：视角独立型和视角依赖型 视角独立型 整个3D的视频内容被按照统一的质量投影到2D平面上 主要包括等距长方形投影和立方贴图投影 等距长方形投影(ERP) 使用左右偏向和俯仰值将观察者周围的球体展平到二维表面上 视角范围：左180度～右180度、上90度～下90度 缺点： 极点处会使用比赤道处更多的像素进行表示，会消耗有限的带宽 由于图像失真导致压缩效率不足 立方贴图投影(CMP) 六面立方体组合用于将球体的像素映射到立方体上的相关像素 在游戏中被广泛应用 优点： 节省空间，相比于等距长方形投影视频体积能减少25% 缺点： 只能渲染有限的用户视野 视角依赖型 视角内的内容比之外的内容有更高保真度的表示 主要包括金字塔投影、截断方形金字塔投影(TSP)和偏移立方贴图投影 金字塔投影 球体被投影到一个金字塔上，基础部分有最高的质量，大多数的投影区域属于用户的视角方向 优点： 节省空间，降低80%的视频体积 缺点： 用户以120度旋转视角时，视频的质量会像旋转180度一样急速下降 截断方形金字塔投影 大体情况和金字塔投影相同，区别在与使用了被截断的方形金字塔 优点： 减少了边缘数据，提高了高码率视频的推流性能 缺点： 使边缘更加锐利 偏移立方贴图投影 与原始的立方贴图投影类似，球体的像素点被投影到立方体的6个面上 优点： 视角方向的内容会有更高的质量，提供平滑的视频质量变化 缺点： 存储开销很大 ","date":"2021-10-20","objectID":"/posts/note1/:1:2","tags":["Immersive Video"],"title":"360度流媒体面临的挑战、机遇和解决方案","uri":"/posts/note1/"},{"categories":["Immersive Video"],"content":"编码视频内容 目前主要的编码方式有AVC/H.264和HEVC/H.265。 H.264 使用16x16的宏块结构对帧编码。 因为使用了编码器的动作预测的特性，编码的数据大小得到减少。 H.265 相比于同质量的H.264编码方式，H.265编码减少了50%的比特率。 H.265支持tiling特性来实现高效视频推流。 每个tile在物理上被分割然后在普通的流中拼接，并且使用一个解码器来解码。 VVC 相比于H.265，下一代标准VVC有望提高30%的压缩效率。 ","date":"2021-10-20","objectID":"/posts/note1/:1:3","tags":["Immersive Video"],"title":"360度流媒体面临的挑战、机遇和解决方案","uri":"/posts/note1/"},{"categories":["Immersive Video"],"content":"分包和传输 分包 使用DASH协议分包。 传输 依赖于雾计算和边缘计算等技术可以缩短分发中心和客户端之间的距离进而实现快速响应和低缓冲时间。 ","date":"2021-10-20","objectID":"/posts/note1/:1:4","tags":["Immersive Video"],"title":"360度流媒体面临的挑战、机遇和解决方案","uri":"/posts/note1/"},{"categories":["Immersive Video"],"content":"渲染和展示 客户端处理 主流方案是使用客户端处理，但是由于会处理不属于用户视角范围内的视频内容，所以会造成计算资源的浪费。 云端处理 另一种方案是使用云端处理，只有用户视角内的视频内容会被传输到客户端，没有更多的带宽和客户端硬件资源要求。 ","date":"2021-10-20","objectID":"/posts/note1/:1:5","tags":["Immersive Video"],"title":"360度流媒体面临的挑战、机遇和解决方案","uri":"/posts/note1/"},{"categories":["Programming Language"],"content":"常见的坑 int, short, long, long long都是带符号的，在前面添加unsigned就能得到无符号类型。 字符型被分为3种：char, signed char, unsigned char，前两种并不等价。 虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。 有符号类型在与无符号类型运算时会隐式转换为无符号类型。 虽然变量初始化时候使用了=号，但是初始化和变量赋值并不相同。 变量默认初始化： 变量类型 位置在函数内部 位置在函数外部 内置类型 undefined 0 自定义类型 由类决定 由类决定 #include \u003ciostream\u003e int default_initialize(int a) { // 输出必定是0 std::cout \u003c\u003c a \u003c\u003c std::endl; int b; return b; } int main() { int a; // 输出是随机值 std::cout \u003c\u003c default_initialize(a) \u003c\u003c std::endl; } 如果在函数体内部试图初始化一个extern标记的变量会引发错误。 在嵌套作用域中，内层作用域中的定义可以覆盖外层作用域中声明的变量。 可以显式使用域操作符::来指明使用哪层的变量。 ","date":"2021-10-18","objectID":"/posts/cpp-types/:1:0","tags":["C++"],"title":"重学C++：类型系统基础","uri":"/posts/cpp-types/"},{"categories":["Programming Language"],"content":"必须要理解的点 字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。 变量的组成部分：类型和值。说白了就是一个定性一个定量。 类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。 值在实际代码运行过程中则被各种函数使用参与运算。 变量声明和定义： 声明的意思就是：我要用这个变量。 定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。 声明 定义 规定变量的类型和名字 ✅ ✅ 申请空间 ✅ 初始化 ✅ 执行多次 ✅ 用extern标记未初始化的变量来表明只对变量作声明： extern int i; //只声明不定义 int i; //声明并且定义 extern int i = 10; //声明并且定义 Q：为什么会有声明和定义这两个概念？ A：因为C++支持分离式编译机制，这允许程序被分割成若干个文件，每个文件可以被独立编译。如果要在多个文件中使用同一个变量，就必须要将声明和定义分离。变量的定义必须且只能出现在一个文件中，其他用到这个变量的文件必须对其进行声明，且绝对不能进行重复定义。 名字的作用域： 同一个名字在不同的作用域中可以指向不同的实体。 名字的有效区域始于声明语句，以声明语句所在的作用域末端结束。 ","date":"2021-10-18","objectID":"/posts/cpp-types/:2:0","tags":["C++"],"title":"重学C++：类型系统基础","uri":"/posts/cpp-types/"},{"categories":["Programming Language"],"content":"建议 明确数值不可能为负时使用unsigned类型。 使用int执行整数运算，范围不够时使用long long。 使用double执行浮点数运算。 算术表达式中不要使用bool和char。 避免写出依赖实现环境的代码，否则代码不可移植。 避免有符号类型和无符号类型之间的隐式类型转换。 C++11中引入了列表初始化，例如： // 传统的初始化方式 int units_sold = 0; int units_sold(0); // 现代的初始化方式 int units_sold{0}; int units_sold = {0}; 列表初始化在用于内置类型变量时，如果初始值存在丢失信息的风险，编译器会报错。 long double pi = 3.1415926536; int a{pi}, b = {pi}; // 错误：没有执行类型转换，因为可能丢失信息 int a(pi), b = pi; // 正确：执行了隐式类型转化，丢失了信息 对每个内置类型的变量都执行显式默认初始化以防止undefined行为。 在变量第一次使用的地方进行定义操作。 ","date":"2021-10-18","objectID":"/posts/cpp-types/:3:0","tags":["C++"],"title":"重学C++：类型系统基础","uri":"/posts/cpp-types/"},{"categories":["Immersive-Video"],"content":"原仓库地址：Immersive-Video-Sample 修改之后的仓库：Immersive-Video-Sample ","date":"2021-10-09","objectID":"/posts/immersive-video-deploy/:0:0","tags":["Immersive-Video"],"title":"Immersive Video OMAF-Sample Deploy","uri":"/posts/immersive-video-deploy/"},{"categories":["Immersive-Video"],"content":"Server 端搭建 ","date":"2021-10-09","objectID":"/posts/immersive-video-deploy/:1:0","tags":["Immersive-Video"],"title":"Immersive Video OMAF-Sample Deploy","uri":"/posts/immersive-video-deploy/"},{"categories":["Immersive-Video"],"content":"修改 Dockerfile 手动设置 wget 和 git 的 http_proxy 旧 package 目录 not found，修改为新 package 目录 因为找不到 glog 库因此加入软链接操作 ln -s /usr/local/lib64/libglog.so.0.6.0 /usr/local/lib64/libglog.so.0 ","date":"2021-10-09","objectID":"/posts/immersive-video-deploy/:1:1","tags":["Immersive-Video"],"title":"Immersive Video OMAF-Sample Deploy","uri":"/posts/immersive-video-deploy/"},{"categories":["Immersive-Video"],"content":"重新编译内核 运行脚本时显示 libnuma 错误因此推断与 numa 设置有关 执行numactl -H显示只有一个 node，报错输出显示需要至少两个 numa 节点 查询资料之后获知可以使用 fakenuma 技术创造新节点，但是 Ubuntu 默认的内核没有开启对应的内核参数 手动下载 Linux 内核源代码到/usr/src/目录 wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.11.1.tar.gz 解压 tar xpvf linux-5.11.1.tar.gz 复制现有内核配置 cd linux-5.11.1 \u0026\u0026 cp -v /boot/config-$(uname -r) .config 安装必要的包 sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev 进入内核配置界面 sudo make menuconfig 按下/键分别查询CONFIG_NUMA和CONFIG_NUMA_EMU位置 手动勾选对应选项之后保存退出 重新编译并等待安装结束 sudo make -j $(nproc) \u0026\u0026 sudo make modules_install \u0026\u0026 sudo make install 修改grub启动参数加入 fake numa 配置 sudo vim /etc/default/grub 找到对应行并修改为 GRUB_CMDLINE_LINUX=\"numa=fake=2\" 更新grub并重启 sudo update-grub \u0026\u0026 sudo reboot 执行numactl -H检查 numa 节点数目为 2 重新执行脚本如图说明一切正常 ","date":"2021-10-09","objectID":"/posts/immersive-video-deploy/:1:2","tags":["Immersive-Video"],"title":"Immersive Video OMAF-Sample Deploy","uri":"/posts/immersive-video-deploy/"},{"categories":["Immersive-Video"],"content":"Client 端搭建 需要 Ubuntu18.04 环境，虚拟机中安装之后按照 README 命令，执行脚本一切正常 ","date":"2021-10-09","objectID":"/posts/immersive-video-deploy/:2:0","tags":["Immersive-Video"],"title":"Immersive Video OMAF-Sample Deploy","uri":"/posts/immersive-video-deploy/"},{"categories":["GNU/Linux"],"content":"Delete old sync files sudo rm /var/lib/pacman/sync/* ","date":"2021-06-11","objectID":"/posts/how-to-fix-gpgme-error/:1:0","tags":["Archlinux"],"title":"How to Fix GPGME Error on Archlinux","uri":"/posts/how-to-fix-gpgme-error/"},{"categories":["GNU/Linux"],"content":"Re init pacman-key sudo pacman-key --init ","date":"2021-06-11","objectID":"/posts/how-to-fix-gpgme-error/:2:0","tags":["Archlinux"],"title":"How to Fix GPGME Error on Archlinux","uri":"/posts/how-to-fix-gpgme-error/"},{"categories":["GNU/Linux"],"content":"Populate key sudo pacman-key --populate ","date":"2021-06-11","objectID":"/posts/how-to-fix-gpgme-error/:3:0","tags":["Archlinux"],"title":"How to Fix GPGME Error on Archlinux","uri":"/posts/how-to-fix-gpgme-error/"},{"categories":["GNU/Linux"],"content":"Re sync sudo pacman -Syyy Now you can update successfully! ","date":"2021-06-11","objectID":"/posts/how-to-fix-gpgme-error/:4:0","tags":["Archlinux"],"title":"How to Fix GPGME Error on Archlinux","uri":"/posts/how-to-fix-gpgme-error/"},{"categories":["Programming Language"],"content":"Get Correct Version microsoft-edge-dev --version The output is Microsoft Edge 91.0.831.1 dev in my case. ","date":"2021-03-26","objectID":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/:1:0","tags":["Python"],"title":"Python selenium settings on microsoft-edge-dev","uri":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/"},{"categories":["Programming Language"],"content":"Get Corresponding WebDriver Find the corresponding version at msedgewebdriverstorage and download the zip. Extract it to you path like /usr/local/bin or $HOME/.local/bin. ","date":"2021-03-26","objectID":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/:2:0","tags":["Python"],"title":"Python selenium settings on microsoft-edge-dev","uri":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/"},{"categories":["Programming Language"],"content":"Write Code Following is a example. from msedge.selenium_tools import EdgeOptions, Edge options = EdgeOptions() options.use_chromium = True options.binary_location = r\"/usr/bin/microsoft-edge-dev\" options.set_capability(\"platform\", \"LINUX\") webdriver_path = r\"/home/ayamir/.local/bin/msedgewebdriver\" browser = Edge(options=options, executable_path=webdriver_path) browser.get(\"http://localhost:8000\") assert \"Django\" in browser.title ","date":"2021-03-26","objectID":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/:3:0","tags":["Python"],"title":"Python selenium settings on microsoft-edge-dev","uri":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/"},{"categories":["Programming Language"],"content":"Launch it ","date":"2021-03-26","objectID":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/:4:0","tags":["Python"],"title":"Python selenium settings on microsoft-edge-dev","uri":"/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/"},{"categories":["GNU/Linux"],"content":"文件和目录的权限 下图为使用exa命令的部分截图 上图中的 Permission 字段下面的字母表示权限 第一个字母表示 文件类型 ： 剩下的 9 个位置上的字符称为 文件模式 ，每 3 个为一组，分别表示文件所有者、文件所属群组以及其他所有用户对该文件的读取、写入和执行权限 ","date":"2021-03-15","objectID":"/posts/linux-authority/:1:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"id：显示用户身份标识 一个用户可以拥有文件和目录，同时对其拥有的文件和目录有控制权 用户之上是群组，一个群组可以由多个用户组成 文件和目录的访问权限由其所有者授予群组或者用户 下图为 Gentoo Linux 下以普通用户身份执行 id 命令的结果 uid 和 gid 分别说明了当前用户的用户编号与用户名、所属用户组的编号与组名 groups 后的内容说明了用户还属于哪些组，说明了其对应的编号和名称 许多类 UNIX 系统会将普通用户分配到一个公共的群组中如：users 现代 Linux 操作是创建一个独一无二的只有一个用户的同名群组 ","date":"2021-03-15","objectID":"/posts/linux-authority/:2:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"chmod：更改文件模式 chmod 支持两种标识方法 八进制表示法 常用的模式有 7,6,5,4,0 符号表示法 如果没有指定字符默认使用 all ’+’表示添加一种权限 ’-’表示删除一种权限 例如： ’-R’=’\u0026##x2013;recursive’表示递归设置 ","date":"2021-03-15","objectID":"/posts/linux-authority/:3:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"umask：设置文件默认权限 使用八进制表示法表示从文件模式属性中删除一个位掩码 掩码的意思：用掩码来取消不同的文件模式 umask 可以看到输出为： 0022 不同 linux 发行版默认的文件权限不同，这里的输出是 Gentoo Linux 上普通用户对应的的输出 0022：先不看第一个 0,后面的 0|2|2 用二进制展开结果是：000|010|010 掩码中 1 对应位处的权限会被取消，0则不受影响 所以会有这样的结果： 再来谈最前面的 0:因为除了 rwx 之外还有较少用到的权限设置 setuid 位:4000(8 进制) 设置此位到一个可执行文件时，有效用户 ID 将从实际运行此程序的用户 ID 变成该程序拥有者的 ID 设置场景：应用于由 root 用户拥有的程序，当普通用户运行一个具有 setuid 位的程序时，这个程序会以超级用户的权限执行，因此可以访问普通用户无法访问到的文件和目录 设置程序 setuid： chmod u+s program_name 结果： -rwsr-xr-x 可以看到第二组权限中第一个符号是 s setgid 位:2000(8 进制) 有效组 ID 从该用户的实际组 ID 更改为该文件所有者的组 ID 设置场景：当一个公共组下的成员需要访问共享目录下的所有文件时可以设置此位 对一个目录设置 setgid 位，则该目录下新创建的文件将由该目录所在组所有 chmod g+s dir_name 结果： drwxrwsr-x 可以看到第二组权限中最后一个符号是 s(替换了 x) sticky 位:1000(8 进制) 标记一个可执行文件是“不可交换的”，linux 中默认会忽略文件的 sticky 位，但是对目录设置 sticky 位，能阻止用户删除或者重命名文件，除非用户是这个目录的所有者，文件所有者或者 root 用来控制对共享目录的访问 chmod +t dir_name 结果： drwxrwxrwt 可以看到第三组权限中最后一个符号是 t(替换了 x) ","date":"2021-03-15","objectID":"/posts/linux-authority/:4:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"su：以另一个用户身份运行 shell ","date":"2021-03-15","objectID":"/posts/linux-authority/:5:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"使用 su 命令登录 su [-[l]] [user] 如果包含“-l”选项，得到的 shell session 会是 user 所指定的的用户的登录 shell 即 user 所指定的用户的运行环境将会被加载，工作目录会更改为此用户的主目录 ","date":"2021-03-15","objectID":"/posts/linux-authority/:5:1","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"使用 su 命令执行单个命令 su -c 'comand' 命令内容必须用 ’’ 引用起来（也可以是双引号） ","date":"2021-03-15","objectID":"/posts/linux-authority/:5:2","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"sudo：以另一个用户身份执行命令 ","date":"2021-03-15","objectID":"/posts/linux-authority/:6:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"sudo 和 su 的区别 sudo 比 su 有更丰富的功能，而且可以配置 通过修改配置文件来配置 sudo EDITOR=vim visudo 执行上面的命令可以用 vim 来编辑 sudo 的配置文件 常用的场景是在将用户加入到 wheel 组之后使 wheel 组的用户能够访问 root 权限 使用 sudo 命令输入的不是 root 的密码，而是自己的密码 可以使用 `sudo -l`来查看通过 sudo 命令能获得的权限 ","date":"2021-03-15","objectID":"/posts/linux-authority/:6:1","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"chown：更改文件所有者 ","date":"2021-03-15","objectID":"/posts/linux-authority/:7:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"用法 chown [owner][:[group]] file ... 第一个参数决定 chown 命令更改的是文件所有者还是文件所属群组，或者对两者都更改 图中使用 root 用户在/home/ayamir 目录下创建了一个 foo.txt 文件，最后将此文件的所有者和所属组都改为了 ayamir（rg 是ripgrep） ","date":"2021-03-15","objectID":"/posts/linux-authority/:7:1","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"chgrp：更改文件所属群组 这个命令是历史遗留问题，在早期的 UNIX 版本中，chown 只能更改文件的所有者，而不能改变文件的所属群组，因此出现了这个命令，事实上现在的 chown 已经能实现 chgrp 的功能，因此没必要再使用这个命令（其使用方式几乎与 chown 命令相同） ","date":"2021-03-15","objectID":"/posts/linux-authority/:8:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"passwd：更改用户密码 ","date":"2021-03-15","objectID":"/posts/linux-authority/:9:0","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"一般用法 passwd [user] 用来更改 user 用户的密码，如果想修改当前用户的密码则不需要指定 user 执行之后会提示输入旧密码和新密码，新密码需要再确认输入一次 拥有 root 用户权限的用户可以设置所有用户的密码 上图为 Gentoo Linux 下使用 passwd 命令修改 ayamir 用户密码的过程，这里可以看到 passwd 会强迫用户使用强密码，会拒绝短密码或容易猜到的密码（其他发行版可能输出会不一样） ","date":"2021-03-15","objectID":"/posts/linux-authority/:9:1","tags":["GNU/Linux"],"title":"Linux权限相关命令解读","uri":"/posts/linux-authority/"},{"categories":["GNU/Linux"],"content":"Arch Linux DNS设置 安装dnsmasq sudo pacman -S dnsmasq 配置/etc/resolv.conf中的域名代理服务器 # Tencent nameserver 119.29.29.29 nameserver 182.254.118.118 # Ali nameserver 223.5.5.5 nameserver 223.6.6.6 # OpenDNS IPv4 nameservers nameserver 208.67.222.222 nameserver 208.67.220.220 # OpenDNS IPv6 nameservers nameserver 2620:0:ccc::2 nameserver 2620:0:ccd::2 # Google IPv4 nameservers nameserver 8.8.8.8 nameserver 8.8.4.4 # Google IPv6 nameservers nameserver 2001:4860:4860::8888 nameserver 2001:4860:4860::8844 # Comodo nameservers nameserver 8.26.56.26 nameserver 8.20.247.20 # Generated by NetworkManager nameserver 192.168.1.1 防止/etc/resolv.conf被修改 sudo chattr +i /etc/resolv.conf 减少主机名查找时间 sudo echo \"options timeout:1\" \u003e /etc/resolv.conf.tail 启动dnsmasq sudo systemctl enable dnsmasq.service --now ","date":"2021-01-26","objectID":"/posts/dns-settings-on-archlinux/:1:0","tags":["Archlinux"],"title":"Dns Settings on Archlinux","uri":"/posts/dns-settings-on-archlinux/"}]