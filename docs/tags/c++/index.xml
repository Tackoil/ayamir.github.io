<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 标签 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/tags/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 标签 - Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Tue, 26 Oct 2021 15:53:11 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>重学C&#43;&#43;：Const二三事</title>
    <link>https://ayamir.github.io/posts/const/</link>
    <pubDate>Tue, 26 Oct 2021 15:53:11 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/const/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>仅用<code>const</code>修饰的对象只在单个文件中有效，如果想在多个文件之间共享<code>const</code>对象，必须在对象<strong>定义</strong>的前面加<code>extern</code>。</p>
</li>
<li>
<p>允许为一个常量引用绑定非常量的对象、字面量和表达式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>       <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>      <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 正确
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1">// 错误
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r5</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">r5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                  <span class="c1">// 正确
</span><span class="c1"></span><span class="n">r1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>                 <span class="c1">// 错误
</span></code></pre></div></li>
<li>
<p>指向常量的指针和常量指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">errNumb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">curErr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">errNumb</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">mutPPi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="k">const</span> <span class="n">pPi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
</code></pre></div><p>从声明语句的变量符号开始，自右向左看：</p>
<p><code>curErr</code>首先是一个不可变对象，其次是一个指向<code>int</code>类型可变对象的指针。</p>
<p><code>mutPPi</code>首先是一个可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
<p><code>pPi</code>首先是一个不可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>const</code>对象在创建时必须进行初始化。</p>
</li>
<li>
<p>常量引用即对<code>const</code>对象的引用。</p>
</li>
<li>
<p>常量引用绑定<em>不可变对象</em>和<em>可变对象</em>时含义不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">可变对象</th>
<th style="text-align:center">不可变对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用常量引用绑定</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">必须</td>
</tr>
<tr>
<td style="text-align:center">常量引用的含义</td>
<td style="text-align:center">不能通过此引用改变对象的值</td>
<td style="text-align:center">不可以改变对象的值</td>
</tr>
</tbody>
</table>
<p>常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。</p>
<p>非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。</p>
</li>
<li>
<p>因为指针是对象，而引用不是对象，所以<code>const</code>和指针的组合有2种情况，<code>const</code>和引用的组合只有1种情况。</p>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）：不能通过此指针修改对应的量。</li>
<li>常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。</li>
</ul>
</li>
<li>引用
<ul>
<li>常量引用：不能通过此引用修改对应的量。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：引用和指针</title>
    <link>https://ayamir.github.io/posts/reference-and-pointer/</link>
    <pubDate>Tue, 26 Oct 2021 15:49:49 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/reference-and-pointer/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>&amp;</code>和<code>*</code>在不同的上下文里面其含义并不相同，因此<strong>完全可以当成不同的符号看待</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// &amp;在类型名后出现，是声明的一部分，表明r是一个引用
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>        <span class="c1">// *在类型名后出现，是声明的一部分，表明p是一个指针
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>        <span class="c1">// &amp;在表达式中出现，是取地址符
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>       <span class="c1">// *在表达式中出现，是解引用符
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// &amp;是声明的一部分，*是解引用符
</span></code></pre></div></li>
<li>
<p>指针可以用<code>0</code>进行初始化成空指针，但是不可以用<code>0</code>赋值。</p>
</li>
<li>
<p>指针之间使用<code>==</code>来比较时，如果结果是<code>true</code>，对应多种情况：</p>
<ul>
<li>都是空指针</li>
<li>都是同一个地址
<ul>
<li>都指向同一个对象</li>
<li>一个指针指向某一个对象，另一个指针指向另一对象的下一地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>引用和指针——都可以用于间接访问对象</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">引用</th>
<th style="text-align:center">指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复合类型</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">表示符号</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">含义</td>
<td style="text-align:center">变量的别名</td>
<td style="text-align:center">变量在内存中的地址</td>
</tr>
<tr>
<td style="text-align:center">初始化和赋值时是否需要类型匹配</td>
<td style="text-align:center">必须匹配（除常量引用）</td>
<td style="text-align:center">必须匹配（除void*和指向常量的指针）</td>
</tr>
<tr>
<td style="text-align:center">是否需要初始化</td>
<td style="text-align:center">必须初始化</td>
<td style="text-align:center">无需初始化</td>
</tr>
<tr>
<td style="text-align:center">可否重新绑定其他变量</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center">可否嵌套定义</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
</tbody>
</table>
<p>引用：</p>
<ul>
<li>引用只能<strong>绑定</strong>在对象上，不能绑定在字面量或者表达式上。</li>
<li>引用只是原有对象的<strong>别名</strong>，并非对象，因此不可以定义引用的引用。</li>
<li>定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。</li>
</ul>
<p>指针：</p>
<ul>
<li>
<p>指针本身就是一个对象，能执行的操作自由度远超过引用。</p>
<ul>
<li>
<p>可以实现嵌套定义，即指针的指针。</p>
</li>
<li>
<p>可以实现指针的引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>         <span class="c1">// p是int型指针
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// r是指针p的引用，从r开始自右向左读，&amp;表明r是一个引用，引用的是指针，指针指向的类型是int
</span><span class="c1"></span>
<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>         <span class="c1">// r是p的别名，即给p赋值为i的地址，即令p指向i
</span><span class="c1"></span><span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// r是p的别名，对r解引用即对p解引用，即将p所指向的地址处变量的值赋值为0
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>指针初始化和赋值时需要使用&amp;运算符取得对象的地址。</p>
</li>
<li>
<p>指针值的情况：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，没有指向任何对象。</li>
<li>无效指针，除上述情况之外。</li>
</ol>
<p>对第4种无效指针的操作是未定义的，后果无法预计。</p>
<p>2、3两种值虽然有效，但是因为没有指向任何对象，所以对其操作的后果同样无法预计。</p>
</li>
</ul>
</li>
<li>
<p><code>void*</code>眼中内存空间仅仅是内存空间，并不能访问内存空间中的对象。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>初始化所有的指针，并且<strong>在对象定义完成之后</strong>再定义指向它的指针。</p>
</li>
<li>
<p>避免使用<code>0</code>和<code>NULL</code>初始化空指针，应该使用<code>nullptr</code>。</p>
</li>
<li>
<p>在使用指针之前检查其是否为<code>nullptr</code>。</p>
</li>
<li>
<p><strong>记住赋值改变的永远是等号左侧的对象。</strong></p>
</li>
<li>
<p>面对复杂的指针或引用的声明语句时，从变量名开始自右向左阅读来弄清楚其真实含义。</p>
</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：类型系统基础</title>
    <link>https://ayamir.github.io/posts/cpp-types/</link>
    <pubDate>Mon, 18 Oct 2021 19:32:22 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/cpp-types/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code>都是带符号的，在前面添加<code>unsigned</code>就能得到无符号类型。</p>
</li>
<li>
<p>字符型被分为3种：<code>char</code>, <code>signed char</code>, <code>unsigned char</code>，前两种并不等价。
虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。</p>
</li>
<li>
<p>有符号类型在与无符号类型运算时会隐式转换为无符号类型。</p>
</li>
<li>
<p>虽然变量初始化时候使用了<code>=</code>号，但是初始化和变量赋值并不相同。</p>
</li>
<li>
<p>变量默认初始化：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">位置在函数内部</th>
<th style="text-align:center">位置在函数外部</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内置类型</td>
<td style="text-align:center">undefined</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">自定义类型</td>
<td style="text-align:center">由类决定</td>
<td style="text-align:center">由类决定</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">default_initialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 输出必定是0
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// 输出是随机值
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">default_initialize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>如果在函数体内部试图初始化一个<code>extern</code>标记的变量会引发错误。</p>
</li>
<li>
<p>在嵌套作用域中，内层作用域中的<strong>定义</strong>可以覆盖外层作用域中<strong>声明</strong>的变量。</p>
<p>可以显式使用<strong>域操作符</strong><code>::</code>来指明使用哪层的变量。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。</p>
</li>
<li>
<p>变量的组成部分：类型和值。说白了就是一个定性一个定量。</p>
<p>类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。</p>
<p>值在实际代码运行过程中则被各种函数使用参与运算。</p>
</li>
<li>
<p>变量声明和定义：</p>
<p>声明的意思就是：我要用这个变量。</p>
<p>定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">声明</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">规定变量的类型和名字</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">申请空间</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">初始化</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">执行多次</td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>用<code>extern</code>标记<strong>未初始化</strong>的变量来表明只对变量作声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>      <span class="c1">//只声明不定义
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>             <span class="c1">//声明并且定义
</span><span class="c1"></span><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//声明并且定义
</span></code></pre></div><p>Q：为什么会有声明和定义这两个概念？</p>
<p>A：因为C++支持<em>分离式编译</em>机制，这允许程序被分割成若干个文件，每个文件可以被独立编译。如果要在多个文件中使用同一个变量，就必须要将声明和定义分离。变量的定义必须且只能出现在一个文件中，其他用到这个变量的文件必须对其进行声明，且绝对不能进行重复定义。</p>
</li>
<li>
<p>名字的作用域：</p>
<p>同一个名字在不同的作用域中可以指向不同的实体。</p>
<p>名字的有效区域始于<strong>声明</strong>语句，以<strong>声明</strong>语句所在的作用域末端结束。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>明确数值不可能为负时使用<code>unsigned</code>类型。</p>
</li>
<li>
<p>使用<code>int</code>执行整数运算，范围不够时使用<code>long long</code>。</p>
</li>
<li>
<p>使用<code>double</code>执行浮点数运算。</p>
</li>
<li>
<p>算术表达式中不要使用<code>bool</code>和<code>char</code>。</p>
</li>
<li>
<p>避免写出依赖实现环境的代码，否则代码不可移植。</p>
</li>
<li>
<p>避免有符号类型和无符号类型之间的隐式类型转换。</p>
</li>
<li>
<p>C++11中引入了<strong>列表初始化</strong>，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="c1">// 传统的初始化方式
</span><span class="c1"></span><span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">units_sold</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 现代的初始化方式
</span><span class="c1"></span><span class="kt">int</span> <span class="n">units_sold</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</code></pre></div><p>列表初始化在用于内置类型变量时，如果初始值存在<em>丢失信息</em>的风险，编译器会报错。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">long</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415926536</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="n">pi</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="n">pi</span><span class="p">};</span>   <span class="c1">// 错误：没有执行类型转换，因为可能丢失信息
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">a</span><span class="p">(</span><span class="n">pi</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span>     <span class="c1">// 正确：执行了隐式类型转化，丢失了信息
</span></code></pre></div></li>
<li>
<p>对每个内置类型的变量都执行<strong>显式默认初始化</strong>以防止undefined行为。</p>
</li>
<li>
<p>在变量第一次使用的地方进行<strong>定义</strong>操作。</p>
</li>
</ol>
]]></description>
</item></channel>
</rss>
