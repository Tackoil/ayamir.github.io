<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 标签 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/tags/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 标签 - Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Thu, 28 Oct 2021 17:09:18 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>重学C&#43;&#43;：容器和迭代器</title>
    <link>https://ayamir.github.io/posts/iterator/</link>
    <pubDate>Thu, 28 Oct 2021 17:09:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/iterator/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。</p>
</li>
<li>
<p><code>string</code>虽然不是容器，但是支持很多容器的操作。</p>
</li>
<li>
<p>容器不为空时：<code>begin()</code>返回的是容器中第一个元素的位置；<code>end()</code>返回的是容器中最后一个元素的<strong>后一个位置</strong>。</p>
<p>容器为空时：<code>begin()</code>和<code>end()</code>返回的都是最后一个元素的<strong>后一个位置</strong>。</p>
</li>
<li>
<p>任何可能改变容器大小的操作都会使容器的迭代器失效。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>和指针类似的是，迭代器支持对对象的间接访问。</p>
</li>
<li>
<p>和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如<code>begin()</code>, <code>end()</code>。</p>
</li>
<li>
<p>所有迭代器都支持的运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center"><code>*iter</code></td>
<td style="text-align:center">返回迭代器<code>iter</code>指向元素的<strong>引用</strong></td>
</tr>
<tr>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center"><code>iter-&gt;mem</code></td>
<td style="text-align:center">解引用<code>iter</code>并获取该元素名为<code>mem</code>的成员，即<code>(*iter).mem</code></td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center"><code>++iter</code></td>
<td style="text-align:center">令<code>iter</code>指向当前元素的后一个元素</td>
</tr>
<tr>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center"><code>--iter</code></td>
<td style="text-align:center">令<code>iter</code>指向当前元素的前一个元素</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center"><code>iter1 == iter2</code></td>
<td style="text-align:center">如果两个迭代器指向相同的元素返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center"><code>iter1 != iter2</code></td>
<td style="text-align:center">上面例子的反面</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>迭代器的类型有两种：<code>iterator</code>和<code>const_iterator</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itv</span><span class="p">;</span>          <span class="c1">// 可用于读写vector&lt;int&gt;中的元素
</span><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">its</span><span class="p">;</span>               <span class="c1">// 可用于读写string对象中的元素
</span><span class="c1"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">citv</span><span class="p">;</span>   <span class="c1">// 只能读取元素
</span><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">cits</span><span class="p">;</span>        <span class="c1">// 只能读取元素
</span></code></pre></div><p><code>begin()</code>和<code>end()</code>返回哪一种取决于对象本身是否被<code>const</code>修饰。</p>
<p>C++11中引入了<code>cbegin()</code>和<code>cend()</code>来专门返回<code>const_iterator</code>。</p>
</li>
<li>
<p>认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。</p>
</li>
<li>
<p><code>vector</code>和<code>string</code>的迭代器支持的<strong>额外的</strong>运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>iter + n</code></td>
<td style="text-align:center">运算得到一个新迭代器，指向当前元素的后n个元素的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>iter - n</code></td>
<td style="text-align:center">运算得到一个新迭代器，指向当前元素的前n个元素的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>iter += n</code></td>
<td style="text-align:center">运算得到的新迭代器赋值给<code>iter</code></td>
</tr>
<tr>
<td style="text-align:center"><code>iter -= n</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>iter1 - iter2</code></td>
<td style="text-align:center">两个迭代器之间的距离，可正可负</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td style="text-align:center">同两类型的下标运算符中的数字的关系，位置靠前的较小</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>一般不在意迭代器的类型，因此使用<code>auto</code>来标注。</li>
<li>循环结束的判断条件习惯使用迭代器和<code>!=</code>，这样可以不用在意容器类型。</li>
<li>凡是使用了迭代器的循环体中都不能有改变容器大小的操作如<code>push_back()</code>。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：标准库类模板Vector</title>
    <link>https://ayamir.github.io/posts/vector/</link>
    <pubDate>Thu, 28 Oct 2021 15:35:17 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/vector/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>vector</code>的默认初始化是否合法取决于<code>vector</code>内对象所属的类是否要求显式初始化。</p>
</li>
<li>
<p>使用<code>()</code>和<code>{}</code>对<code>vector</code>执行初始化含义不同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>    <span class="c1">// 存储1个int对象，值为10
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">// 存储10个int对象，值为0
</span><span class="c1"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 存储10个int对象，值都是1
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// 存储2个int对象，值分别是10和1
</span></code></pre></div></li>
<li>
<p>使用<code>{}</code>执行列表初始化时按照顺序遵守2个守则：</p>
<ol>
<li>
<p>如果<code>{}</code>内容可以用于初始化，则采用<code>{}</code>默认的初始化含义。</p>
</li>
<li>
<p>如果<code>{}</code>中的内容无法用<code>{}</code>默认的初始化含义做出解释，则会按照<code>()</code>的初始化含义去解释<code>{}</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="s">&#34;hi&#34;</span><span class="p">};</span>      <span class="c1">// 存储1个值为hi的string对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>        <span class="c1">// 存储10个值为空的string对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">};</span>  <span class="c1">// 存储10个值为hi的string对象
</span></code></pre></div></li>
</ol>
</li>
<li>
<p>与<code>string</code>相同，<code>vector</code>也有<code>size_type</code>作为其<code>size()</code>的返回值类型。</p>
<p>但是使用时必须首先指定<code>vector</code>由哪个类型定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 正确
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">::</span><span class="n">size_type</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 错误
</span></code></pre></div></li>
<li>
<p>只有<code>vector</code>内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。</p>
</li>
<li>
<p>增加<code>vector</code>中的元素只能使用<code>push_back()</code>，而不能使用对下标赋值的方式。</p>
</li>
</ol>
<h2 id="必须理解的点">必须理解的点</h2>
<ol>
<li><code>vector</code>是类模板而非类型。</li>
<li><code>vector</code>中只能容纳对象，不能容纳引用。</li>
<li><code>vector</code>对象能高效增长，增加<code>vector</code>中的元素需要使用<code>push_back()</code>成员函数。</li>
<li><code>vector</code>的成员函数（<code>empty()</code>, <code>size()</code>）和各种运算符（赋值、关系、下标）的操作使用方法和规则基本同<code>string</code>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>不需要在创建<code>vector</code>时确定其中的元素及其大小。</li>
<li>在循环体内部包含向<code>vector</code>对象添加元素的操作时，不应该使用<code>foreach</code>循环。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：标准库类型string</title>
    <link>https://ayamir.github.io/posts/string/</link>
    <pubDate>Thu, 28 Oct 2021 10:31:33 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/string/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>string.size()</code>和<code>string.length()</code>等价。</p>
<p><code>string.size()</code>和其他<code>STL</code>容器的命名风格相一致（如<code>vector</code>, <code>map</code>）。</p>
<p><code>string.length()</code>出现主要是因为这样的命名符合人的直觉，有更好的可读性。</p>
</li>
<li>
<p><code>string::size_type</code>是无符号类型，和<code>int</code>不同，能存放下任何<code>string</code>对象的大小。</p>
</li>
<li>
<p><code>+</code>两边至少有一端需要是<code>string</code>对象，不允许两个字符串字面量单独相加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&#34;b&#34;</span> <span class="o">+</span> <span class="s">&#34;c&#34;</span><span class="p">;</span>   <span class="c1">// 正确，从左到右运算时能保证至少一段是string对象
</span><span class="c1"></span><span class="n">string</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&#34;b&#34;</span> <span class="o">+</span> <span class="s">&#34;c&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>   <span class="c1">// 错误，从左到右运算时第一个+左右都是字符串字面量
</span></code></pre></div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>string</code>的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。</p>
</li>
<li>
<p><code>string.size()</code>返回值类型为<code>string::size_type</code>，出现这种类型是为了体现标准库类型和机器无关的特性。</p>
</li>
<li>
<p><code>string</code>对象的比较运算完全实现了运算符重载（<code>==</code>, <code>!=</code>, <code>&lt;</code>,<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>）。</p>
<p><code>==</code>表明两个对象的内容和长度完全一致，反之任一不同则<code>!=</code>。</p>
<p>不等关系运算符比较的法则：</p>
<ol>
<li>如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。</li>
<li>如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。</li>
</ol>
</li>
<li>
<p><code>string</code>对象赋值操作就是内容的替换。</p>
</li>
<li>
<p><code>string</code>对象相加操作就是内容的拼接，<code>+=</code>操作同理。</p>
</li>
<li>
<p><code>string</code>对象可以与字符串字面量相加。</p>
</li>
<li>
<p>形如<code>cname</code>的<code>C++</code>头文件兼容形如<code>ctype.h</code>的<code>C</code>头文件，<code>C++</code>头文件中定义的名字可以在<code>std</code>中找到。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>表达式中出现<code>string.size()</code>函数时就不应该使用<code>int</code>类型，这样可以避免<code>int</code>和<code>unsigned</code>混用的问题。</p>
</li>
<li>
<p><code>C++</code>和<code>C</code>兼容的头文件作选择时，选择<code>C++</code>的头文件。</p>
</li>
<li>
<p>处理<code>string</code>对象中每一个字符时，使用<code>foreach</code>语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

<span class="n">string</span> <span class="n">str</span><span class="p">{</span><span class="s">&#34;Some String&#34;</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 使用引用来改变原字符串内容
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>处理<code>string</code>对象中特定字符时使用<code>[]</code>（下标运算符）或者迭代器。</p>
<p>使用<code>[]</code>访问字符之前检查<code>string</code>对象是否为空。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p><code>string</code>对象下标使用<code>string::size_type</code>作为类型而非<code>int</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

<span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;Hello, world!&#34;</span><span class="p">;</span>
<span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">index_of_space</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">);</span>
</code></pre></div></li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：类型推导</title>
    <link>https://ayamir.github.io/posts/auto/</link>
    <pubDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/auto/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>auto</code>可以在一条语句中声明多个变量，但是所有变量的类型必须一致。</p>
</li>
<li>
<p><code>decltype</code>在分析表达式类型时并不执行表达式。</p>
</li>
<li>
<p><code>decltype</code>处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。</p>
</li>
<li>
<p><code>decltype((variable))</code>的结果永远是引用。</p>
<p><code>decltype(variable)</code>的结果只有当<code>variable</code>是引用时才是引用。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li><code>auto</code>用于变量初始化时的类型推导，<code>decltype</code>用于分析表达式的类型。</li>
<li><code>auto</code>对引用类型推导时实际上用的是引用对象的值。</li>
<li><code>auto</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
<li><code>decltype</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li><code>auto</code>尽量只在类型较长但比较清晰时使用。</li>
<li><code>decltype</code>尽量不要使用。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：Const二三事</title>
    <link>https://ayamir.github.io/posts/const/</link>
    <pubDate>Tue, 26 Oct 2021 15:53:11 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/const/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>仅用<code>const</code>修饰的对象只在单个文件中有效，如果想在多个文件之间共享<code>const</code>对象，必须在对象<strong>定义</strong>的前面加<code>extern</code>。</p>
</li>
<li>
<p>允许为一个常量引用绑定非常量的对象、字面量和表达式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>       <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>      <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 正确
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1">// 错误
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r5</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">r5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                  <span class="c1">// 正确
</span><span class="c1"></span><span class="n">r1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>                 <span class="c1">// 错误
</span></code></pre></div></li>
<li>
<p>指向常量的指针和常量指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">err_numb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">cur_err</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">err_numb</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">mut_pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="k">const</span> <span class="n">pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
</code></pre></div><p>从声明语句的变量符号开始，自右向左看：</p>
<p><code>cur_err</code>首先是一个不可变对象，其次是一个指向<code>int</code>类型可变对象的指针。</p>
<p><code>mut_pi_pointer</code>首先是一个可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
<p><code>pi_pointer</code>首先是一个不可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
</li>
<li>
<p>当<code>typedef</code>遇到<code>const</code>时容易出现错误理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p><code>pstring</code>是<code>char *</code>的别名，即指向<code>char</code>的指针。</p>
<p><code>const</code>修饰的是<code>pstring</code>，因此<code>cstr</code>是：初始化值为<code>nullptr</code>的<strong>不可变指针</strong>。</p>
<p>错误理解会用<code>char *</code>替换掉<code>pstring</code>，即：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>这样从<code>cstr</code>开始自右向左读的话，<code>cstr</code>就会被理解成：指向<strong>字符常量</strong>的<strong>可变指针</strong>。</p>
</li>
<li>
<p><code>constexpr</code>属于顶层<code>const</code>，因此<code>constexpr</code>修饰指针意味着指针本身不可变。</p>
</li>
<li>
<p><code>auto</code>默认会去除顶层<code>const</code>，保留底层<code>const</code>，如果需要顶层<code>const</code>则需要显式加入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>       <span class="c1">// b是一个初始化值为0的可变int对象 
</span><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>       <span class="c1">// c同b
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>       <span class="c1">// d是一个初始化为指向可变int类对象i的可变指针对象
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>      <span class="c1">// e是一个初始化为指向不可变int类对象ci的可变指针对象
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// f是一个初始化值为0的不可变int对象
</span></code></pre></div></li>
<li>
<p><code>decltype</code>不会去除顶层<code>const</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// x的类型是const int
</span></code></pre></div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>const</code>对象在创建时必须进行初始化。</p>
</li>
<li>
<p>常量引用即对<code>const</code>对象的引用。</p>
</li>
<li>
<p>常量引用绑定<em>不可变对象</em>和<em>可变对象</em>时含义不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">可变对象</th>
<th style="text-align:center">不可变对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用常量引用绑定</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">必须</td>
</tr>
<tr>
<td style="text-align:center">常量引用的含义</td>
<td style="text-align:center">不能通过此引用改变对象的值</td>
<td style="text-align:center">不可以改变对象的值</td>
</tr>
</tbody>
</table>
<p>常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。</p>
<p>非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。</p>
</li>
<li>
<p>因为指针是对象，而引用不是对象，所以<code>const</code>和指针的组合有2种情况，<code>const</code>和引用的组合只有1种情况。</p>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）：不能通过此指针修改对应的量。</li>
<li>常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。</li>
</ul>
</li>
<li>引用
<ul>
<li>常量引用：不能通过此引用修改对应的量。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>顶层<code>const</code>表示指针本身是常量，推广之后可以指任意对象是常量；</p>
<p>底层<code>const</code>表示指针指向的对象是常量，推广之后主要于指针和引用等复合类型的基本类型部分有关。</p>
</li>
<li>
<p><strong>常量表达式</strong>指：值不会改变，在编译过程中就能得到计算结果的表达式。</p>
</li>
<li>
<p>为什么需要<code>constexpr</code>？</p>
<p>因为实际中很难判断一个初始值是否为常量表达式。</p>
<p>使用<code>constexpr</code>相当于把验证变量的值是否是一个常量表达式的工作交给了编译器。</p>
<p>用<code>constexpr</code>声明的变量一定是一个变量，并且必须用常量表达式来初始化。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>如果认定变量是一个常量表达式，那就将其声明成<code>constexpr</code>类型。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：引用和指针</title>
    <link>https://ayamir.github.io/posts/reference-and-pointer/</link>
    <pubDate>Tue, 26 Oct 2021 15:49:49 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/reference-and-pointer/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>&amp;</code>和<code>*</code>在不同的上下文里面其含义并不相同，因此<strong>完全可以当成不同的符号看待</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// &amp;在类型名后出现，是声明的一部分，表明r是一个引用
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>        <span class="c1">// *在类型名后出现，是声明的一部分，表明p是一个指针
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>        <span class="c1">// &amp;在表达式中出现，是取地址符
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>       <span class="c1">// *在表达式中出现，是解引用符
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// &amp;是声明的一部分，*是解引用符
</span></code></pre></div></li>
<li>
<p>指针可以用<code>0</code>进行初始化成空指针，但是不可以用<code>0</code>赋值。</p>
</li>
<li>
<p>指针之间使用<code>==</code>来比较时，如果结果是<code>true</code>，对应多种情况：</p>
<ul>
<li>都是空指针</li>
<li>都是同一个地址
<ul>
<li>都指向同一个对象</li>
<li>一个指针指向某一个对象，另一个指针指向另一对象的下一地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>引用和指针——都可以用于间接访问对象</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">引用</th>
<th style="text-align:center">指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复合类型</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">表示符号</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">含义</td>
<td style="text-align:center">变量的别名</td>
<td style="text-align:center">变量在内存中的地址</td>
</tr>
<tr>
<td style="text-align:center">初始化和赋值时是否需要类型匹配</td>
<td style="text-align:center">必须匹配（除常量引用）</td>
<td style="text-align:center">必须匹配（除void*和指向常量的指针）</td>
</tr>
<tr>
<td style="text-align:center">是否需要初始化</td>
<td style="text-align:center">必须初始化</td>
<td style="text-align:center">无需初始化</td>
</tr>
<tr>
<td style="text-align:center">可否重新绑定其他变量</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center">可否嵌套定义</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
</tbody>
</table>
<p>引用：</p>
<ul>
<li>引用只能<strong>绑定</strong>在对象上，不能绑定在字面量或者表达式上。</li>
<li>引用只是原有对象的<strong>别名</strong>，并非对象，因此不可以定义引用的引用。</li>
<li>定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。</li>
</ul>
<p>指针：</p>
<ul>
<li>
<p>指针本身就是一个对象，能执行的操作自由度远超过引用。</p>
<ul>
<li>
<p>可以实现嵌套定义，即指针的指针。</p>
</li>
<li>
<p>可以实现指针的引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>         <span class="c1">// p是int型指针
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// r是指针p的引用，从r开始自右向左读，&amp;表明r是一个引用，引用的是指针，指针指向的类型是int
</span><span class="c1"></span>
<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>         <span class="c1">// r是p的别名，即给p赋值为i的地址，即令p指向i
</span><span class="c1"></span><span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// r是p的别名，对r解引用即对p解引用，即将p所指向的地址处变量的值赋值为0
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>指针初始化和赋值时需要使用&amp;运算符取得对象的地址。</p>
</li>
<li>
<p>指针值的情况：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，没有指向任何对象。</li>
<li>无效指针，除上述情况之外。</li>
</ol>
<p>对第4种无效指针的操作是未定义的，后果无法预计。</p>
<p>2、3两种值虽然有效，但是因为没有指向任何对象，所以对其操作的后果同样无法预计。</p>
</li>
</ul>
</li>
<li>
<p><code>void*</code>眼中内存空间仅仅是内存空间，并不能访问内存空间中的对象。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>初始化所有的指针，并且<strong>在对象定义完成之后</strong>再定义指向它的指针。</p>
</li>
<li>
<p>避免使用<code>0</code>和<code>NULL</code>初始化空指针，应该使用<code>nullptr</code>。</p>
</li>
<li>
<p>在使用指针之前检查其是否为<code>nullptr</code>。</p>
</li>
<li>
<p><strong>记住赋值改变的永远是等号左侧的对象。</strong></p>
</li>
<li>
<p>面对复杂的指针或引用的声明语句时，从变量名开始自右向左阅读来弄清楚其真实含义。</p>
</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：类型系统基础</title>
    <link>https://ayamir.github.io/posts/cpp-types/</link>
    <pubDate>Mon, 18 Oct 2021 19:32:22 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/cpp-types/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code>都是带符号的，在前面添加<code>unsigned</code>就能得到无符号类型。</p>
</li>
<li>
<p>字符型被分为3种：<code>char</code>, <code>signed char</code>, <code>unsigned char</code>，前两种并不等价。
虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。</p>
</li>
<li>
<p>有符号类型在与无符号类型运算时会隐式转换为无符号类型。</p>
</li>
<li>
<p>虽然变量初始化时候使用了<code>=</code>号，但是初始化和变量赋值并不相同。</p>
</li>
<li>
<p>变量默认初始化：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">位置在函数内部</th>
<th style="text-align:center">位置在函数外部</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内置类型</td>
<td style="text-align:center">undefined</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">自定义类型</td>
<td style="text-align:center">由类决定</td>
<td style="text-align:center">由类决定</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">default_initialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 输出必定是0
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// 输出是随机值
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">default_initialize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>如果在函数体内部试图初始化一个<code>extern</code>标记的变量会引发错误。</p>
</li>
<li>
<p>在嵌套作用域中，内层作用域中的<strong>定义</strong>可以覆盖外层作用域中<strong>声明</strong>的变量。</p>
<p>可以显式使用<strong>域操作符</strong><code>::</code>来指明使用哪层的变量。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。</p>
</li>
<li>
<p>变量的组成部分：类型和值。说白了就是一个定性一个定量。</p>
<p>类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。</p>
<p>值在实际代码运行过程中则被各种函数使用参与运算。</p>
</li>
<li>
<p>变量声明和定义：</p>
<p>声明的意思就是：我要用这个变量。</p>
<p>定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">声明</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">规定变量的类型和名字</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">申请空间</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">初始化</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">执行多次</td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>用<code>extern</code>标记<strong>未初始化</strong>的变量来表明只对变量作声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>      <span class="c1">//只声明不定义
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>             <span class="c1">//声明并且定义
</span><span class="c1"></span><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//声明并且定义
</span></code></pre></div><p>Q：为什么会有声明和定义这两个概念？</p>
<p>A：因为C++支持<em>分离式编译</em>机制，这允许程序被分割成若干个文件，每个文件可以被独立编译。如果要在多个文件中使用同一个变量，就必须要将声明和定义分离。变量的定义必须且只能出现在一个文件中，其他用到这个变量的文件必须对其进行声明，且绝对不能进行重复定义。</p>
</li>
<li>
<p>名字的作用域：</p>
<p>同一个名字在不同的作用域中可以指向不同的实体。</p>
<p>名字的有效区域始于<strong>声明</strong>语句，以<strong>声明</strong>语句所在的作用域末端结束。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>明确数值不可能为负时使用<code>unsigned</code>类型。</p>
</li>
<li>
<p>使用<code>int</code>执行整数运算，范围不够时使用<code>long long</code>。</p>
</li>
<li>
<p>使用<code>double</code>执行浮点数运算。</p>
</li>
<li>
<p>算术表达式中不要使用<code>bool</code>和<code>char</code>。</p>
</li>
<li>
<p>避免写出依赖实现环境的代码，否则代码不可移植。</p>
</li>
<li>
<p>避免有符号类型和无符号类型之间的隐式类型转换。</p>
</li>
<li>
<p>C++11中引入了<strong>列表初始化</strong>，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="c1">// 传统的初始化方式
</span><span class="c1"></span><span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">units_sold</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 现代的初始化方式
</span><span class="c1"></span><span class="kt">int</span> <span class="n">units_sold</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</code></pre></div><p>列表初始化在用于内置类型变量时，如果初始值存在<em>丢失信息</em>的风险，编译器会报错。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">long</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415926536</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="n">pi</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="n">pi</span><span class="p">};</span>   <span class="c1">// 错误：没有执行类型转换，因为可能丢失信息
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">a</span><span class="p">(</span><span class="n">pi</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span>     <span class="c1">// 正确：执行了隐式类型转化，丢失了信息
</span></code></pre></div></li>
<li>
<p>对每个内置类型的变量都执行<strong>显式默认初始化</strong>以防止undefined行为。</p>
</li>
<li>
<p>在变量第一次使用的地方进行<strong>定义</strong>操作。</p>
</li>
</ol>
]]></description>
</item></channel>
</rss>
