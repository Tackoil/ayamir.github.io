<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>WebRTC - 标签 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/tags/webrtc/</link>
        <description>WebRTC - 标签 - Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Thu, 18 Apr 2024 17:33:24 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/tags/webrtc/" rel="self" type="application/rss+xml" /><item>
    <title>Jitter Buffer学习理解（上）</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/</link>
    <pubDate>Thu, 18 Apr 2024 17:33:24 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/</guid>
    <description><![CDATA[<h2 id="jitter-buffer-是什么">Jitter Buffer 是什么</h2>
<p>在了解 Jitter Buffer 之前，我们应该先来看一下整个 webrtc 会话中数据传输的完整流程。</p>
<p></p>
<p>与传输相关的部分主要出现在 pacer 和 Jitter Buffer 这两个部分，从图中可以清晰的看到这两者处于编解码和网络传输之间，考虑到编解码可能会引入突变的帧大小（比如 I 帧），而在网络传输的过程又受到网络传输速率和排队延迟的影响，所以它们的作用其实就比较显而易见了。Pacer 在发送端负责平滑编码后的码流打包成 rtp 包之后，发送到网络上的速率；Jitter Buffer 在接收端负责平滑接收到的 rtp 包到组成解码所需的码流的过程。</p>
<p>当然，这个传输的过程中离开不了拥塞控制算法如 gcc 和各种抗丢包的技术如 nack，fec 等来保障实时通信质量。在这里我们主要关注传输的流程，相关算法和机制之后再研究。</p>
<p>Jitter Buffer 可以理解为有两部分的功能，一部分是 Buffer 的功能，也就是作为 rtp 包的缓冲区，并且将 rtp 包恢复成表示可解码帧的码流；另一部分是 Jitter 的功能，也就是通过引入延迟来平滑因帧大小和网络状况而造成的接收帧不均匀的情况。</p>
<h2 id="buffer-的工作流程">buffer 的工作流程</h2>
<p>正如前面所说，网络传输的是 rtp 包，而解码器的输入是可以解码的码流，所以需要一个将 rtp 包转换成可以解码的帧的过程。因为一个帧由多个 rtp 包组成，所以肯定需要缓冲区来存放前面收到但是还不足以组成一个帧的 rtp 包，这个缓冲区在 webrtc 中其实就是<code>PacketBuffer</code>。此外，考虑到编解码原理，接收到的 P 帧还需要等它所依赖的 I 帧/P 帧被解码，它才能被解码，所以在<code>PacketBuffer</code>之外还需要一个<code>FrameBuffer</code>来缓存可以解码的一个 GOP 中的各个帧。而负责寻找当前帧所依赖帧的是<code>RtpFrameReferenceFinder</code>，因为这个寻找依赖帧的过程实际上是递归依赖的，直到找到一个 GOP 的 IDR 帧才算结束，这样就能得到按照解码依赖顺序排列的一个 GOP。而最后，因为不同 GOP 的解码是独立的，所以 GOP 之间实际上就直接按照时间顺序排列就完成了 GOP 的排序。</p>
<p>总体上来看，buffer 负责的工作就是 3 个：rtp 包的排序并组成帧、帧的排序并组成 GOP、GOP 的排序并组成视频。</p>
<h2 id="代码实现">代码实现</h2>
<p>结合代码逻辑来看一下实际的工作流程，最核心的类是<code>RtpVideoStreamReceiver2</code>，这个类负责完成上面所说的工作内容的实现与逻辑的拆分，不过除了上面这些逻辑之外，这个类还需要向发送端发送 rtcp 反馈包的工作，比如 nack, pli, fir。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RtpVideoStreamReceiver2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LossNotificationSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RecoveredPacketReceiver</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RtpPacketSinkInterface</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">KeyFrameRequestSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">NackSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">OnDecryptedFrameCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">OnDecryptionStatusChangeCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RtpVideoFrameReceiver</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// A complete frame is a frame which has received all its packets and all its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// references are known.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">OnCompleteFrameCallback</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">OnCompleteFrameCallback</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpVideoStreamReceiver2</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">current_queue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clock</span><span class="o">*</span> <span class="n">clock</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">Transport</span><span class="o">*</span> <span class="n">transport</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpRttStats</span><span class="o">*</span> <span class="n">rtt_stats</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The packet router is optional; if provided, the RtpRtcp module for this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// stream is registered as a candidate for sending REMB and transport
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// feedback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">PacketRouter</span><span class="o">*</span> <span class="n">packet_router</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">VideoReceiveStreamInterface</span><span class="o">::</span><span class="n">Config</span><span class="o">*</span> <span class="n">config</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">ReceiveStatistics</span><span class="o">*</span> <span class="n">rtp_receive_statistics</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpPacketTypeCounterObserver</span><span class="o">*</span> <span class="n">rtcp_packet_type_counter_observer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpCnameCallback</span><span class="o">*</span> <span class="n">rtcp_cname_callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">NackPeriodicProcessor</span><span class="o">*</span> <span class="n">nack_periodic_processor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The KeyFrameRequestSender is optional; if not provided, key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// requests are sent via the internal RtpRtcp module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">OnCompleteFrameCallback</span><span class="o">*</span> <span class="n">complete_frame_callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameDecryptorInterface</span><span class="o">&gt;</span> <span class="n">frame_decryptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameTransformerInterface</span><span class="o">&gt;</span> <span class="n">frame_transformer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">FieldTrialsView</span><span class="o">&amp;</span> <span class="n">field_trials</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcEventLog</span><span class="o">*</span> <span class="n">event_log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">RtpVideoStreamReceiver2</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">AddReceiveCodec</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">payload_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">VideoCodecType</span> <span class="n">video_codec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CodecParameterMap</span><span class="o">&amp;</span> <span class="n">codec_params</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">bool</span> <span class="n">raw_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Clears state for all receive codecs added via `AddReceiveCodec`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">RemoveReceiveCodecs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">StartReceive</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">StopReceive</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Produces the transport-related timestamps; current_delay_ms is left unset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Syncable</span><span class="o">::</span><span class="n">Info</span><span class="o">&gt;</span> <span class="n">GetSyncInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">DeliverRtcp</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">rtcp_packet</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">rtcp_packet_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">FrameContinuous</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">FrameDecoded</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SignalNetworkState</span><span class="p">(</span><span class="n">NetworkState</span> <span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns number of different frames seen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">GetUniqueFramesSeen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">frame_counter_</span><span class="p">.</span><span class="n">GetUniqueSeen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RtpPacketSinkInterface.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnRtpPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Public only for tests.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Returns true if the packet should be stashed and retried at a later stage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">OnReceivedPayloadData</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span> <span class="n">codec_payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">int</span> <span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RecoveredPacketReceiver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnRecoveredPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Send an RTCP keyframe request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">RequestKeyFrame</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements NackSender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SendNack</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;&amp;</span> <span class="n">sequence_numbers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements LossNotificationSender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SendLossNotification</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns true if a decryptor is attached and frames can be decrypted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Updated by OnDecryptionStatusChangeCallback. Note this refers to Frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Decryption not SRTP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">IsDecryptable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements OnDecryptedFrameCallback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnDecryptedFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements OnDecryptionStatusChangeCallback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnDecryptionStatusChange</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrameDecryptorInterface</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Optionally set a frame decryptor after a stream has started. This will not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reset the decoder state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetFrameDecryptor</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameDecryptorInterface</span><span class="o">&gt;</span> <span class="n">frame_decryptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Sets a frame transformer after a stream has started, if no transformer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// has previously been set. Does not reset the decoder state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetDepacketizerToDecoderFrameTransformer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameTransformerInterface</span><span class="o">&gt;</span> <span class="n">frame_transformer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Called by VideoReceiveStreamInterface when stats are updated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">UpdateRtt</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">max_rtt_ms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Called when the local_ssrc is changed to match with a sender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnLocalSsrcChange</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">local_ssrc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Forwards the call to set rtcp_sender_ to the RTCP mode of the rtcp sender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetRtcpMode</span><span class="p">(</span><span class="n">RtcpMode</span> <span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetReferenceTimeReport</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Sets or clears the callback sink that gets called for RTP packets. Used for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// packet handlers such as FlexFec. Must be called on the packet delivery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread (same context as `OnRtpPacket` is called on).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TODO(bugs.webrtc.org/11993): Packet delivery thread today means `worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread` but will be `network thread`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetPacketSink</span><span class="p">(</span><span class="n">RtpPacketSinkInterface</span><span class="o">*</span> <span class="n">packet_sink</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Turns on/off loss notifications. Must be called on the packet delivery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetLossNotificationEnabled</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetNackHistory</span><span class="p">(</span><span class="n">TimeDelta</span> <span class="n">history</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">ulpfec_payload_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">red_payload_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetProtectionPayloadTypes</span><span class="p">(</span><span class="kt">int</span> <span class="n">red_payload_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ulpfec_payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">LastReceivedPacketMs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">LastReceivedFrameRtpTimestamp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">LastReceivedKeyframePacketMs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">RtpRtcpInterface</span><span class="o">::</span><span class="n">SenderReportStats</span><span class="o">&gt;</span> <span class="n">GetSenderReportStats</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RtpVideoFrameReceiver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnCompleteFrames</span><span class="p">(</span><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Used for buffering RTCP feedback messages and sending them all together.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Note:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 1. Key frame requests and NACKs are mutually exclusive, with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    former taking precedence over the latter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 2. Loss notifications are orthogonal to either. (That is, may be sent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    alongside either.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">RtcpFeedbackBuffer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">KeyFrameRequestSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">public</span> <span class="n">NackSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">public</span> <span class="n">LossNotificationSender</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtcpFeedbackBuffer</span><span class="p">(</span><span class="n">KeyFrameRequestSender</span><span class="o">*</span> <span class="n">key_frame_request_sender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">NackSender</span><span class="o">*</span> <span class="n">nack_sender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">LossNotificationSender</span><span class="o">*</span> <span class="n">loss_notification_sender</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">RtcpFeedbackBuffer</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// KeyFrameRequestSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">RequestKeyFrame</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NackSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendNack</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;&amp;</span> <span class="n">sequence_numbers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// LossNotificationSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendLossNotification</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Send all RTCP feedback messages buffered thus far.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">ClearLossNotificationState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// LNTF-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">LossNotificationState</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LossNotificationState</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">:</span> <span class="n">last_decoded_seq_num</span><span class="p">(</span><span class="n">last_decoded_seq_num</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_received_seq_num</span><span class="p">(</span><span class="n">last_received_seq_num</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">decodability_flag</span><span class="p">(</span><span class="n">decodability_flag</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">packet_sequence_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyFrameRequestSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">key_frame_request_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">NackSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">nack_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LossNotificationSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">loss_notification_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Key-frame-request-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">request_key_frame_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NACK-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">nack_sequence_numbers_</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">LossNotificationState</span><span class="o">&gt;</span> <span class="n">lntf_state_</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="nc">ParseGenericDependenciesResult</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">kStashPacket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kDropPacket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kHasGenericDescriptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kNoGenericDescriptor</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Entry point doing non-stats work for a received packet. Called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for the same packet both before and after RED decapsulation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">ReceivePacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Parses and handles RED headers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This function assumes that it&#39;s being called from only one thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">ParseAndHandleEncapsulatingHeader</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">IsRedEnabled</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">InsertSpsPpsIntoTracker</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">payload_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnInsertedPacket</span><span class="p">(</span><span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ParseGenericDependenciesResult</span> <span class="nf">ParseGenericDependenciesExtension</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTPVideoHeader</span><span class="o">*</span> <span class="n">video_header</span><span class="p">)</span> <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnAssembledFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">UpdatePacketReceiveTimestamps</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="kt">bool</span> <span class="n">is_keyframe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">FieldTrialsView</span><span class="o">&amp;</span> <span class="n">field_trials_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">worker_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Clock</span><span class="o">*</span> <span class="k">const</span> <span class="n">clock_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Ownership of this object lies with VideoReceiveStreamInterface, which owns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `this`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">VideoReceiveStreamInterface</span><span class="o">::</span><span class="n">Config</span><span class="o">&amp;</span> <span class="n">config_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">PacketRouter</span><span class="o">*</span> <span class="k">const</span> <span class="n">packet_router_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RemoteNtpTimeEstimator</span> <span class="n">ntp_estimator_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Set by the field trial WebRTC-ForcePlayoutDelay to override any playout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// delay that is specified in the received packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FieldTrialOptional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forced_playout_delay_max_ms_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FieldTrialOptional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forced_playout_delay_min_ms_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ReceiveStatistics</span><span class="o">*</span> <span class="k">const</span> <span class="n">rtp_receive_statistics_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">UlpfecReceiver</span><span class="o">&gt;</span> <span class="n">ulpfec_receiver_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">red_payload_type_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">worker_task_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(bugs.webrtc.org/11993): This checker conceptually represents
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// operations that belong to the network thread. The Call class is currently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// moving towards handling network packets on the network thread and while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that work is ongoing, this checker may in practice represent the worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread, but still serves as a mechanism of grouping together concepts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that belong to the network thread. Once the packets are fully delivered
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the network thread, this comment will be deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">packet_sequence_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketSinkInterface</span><span class="o">*</span> <span class="n">packet_sink_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">receiving_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">last_packet_log_ms_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ModuleRtpRtcpImpl2</span><span class="o">&gt;</span> <span class="n">rtp_rtcp_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">NackPeriodicProcessor</span><span class="o">*</span> <span class="k">const</span> <span class="n">nack_periodic_processor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">OnCompleteFrameCallback</span><span class="o">*</span> <span class="n">complete_frame_callback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">KeyFrameReqMethod</span> <span class="n">keyframe_request_method_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtcpFeedbackBuffer</span> <span class="n">rtcp_feedback_buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(tommi): Consider absl::optional&lt;NackRequester&gt; instead of unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// since nack is usually configured.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">NackRequester</span><span class="o">&gt;</span> <span class="n">nack_module_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LossNotificationController</span><span class="o">&gt;</span> <span class="n">loss_notification_controller_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span> <span class="n">packet_buffer_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// h26x_packet_buffer_ is nullptr if codec list doens&#39;t contain H.264 or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// H.265, or field trial WebRTC-Video-H26xPacketBuffer is not enabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">H26xPacketBuffer</span><span class="o">&gt;</span> <span class="n">h26x_packet_buffer_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">UniqueTimestampCounter</span> <span class="n">frame_counter_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">SeqNumUnwrapper</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">frame_id_unwrapper_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Video structure provided in the dependency descriptor in a first packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// of a key frame. It is required to parse dependency descriptor in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// following delta packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FrameDependencyStructure</span><span class="o">&gt;</span> <span class="n">video_structure_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Frame id of the last frame with the attached video structure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// absl::nullopt when `video_structure_ == nullptr`;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">video_structure_frame_id_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">last_logged_failed_to_parse_dd_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">)</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">MinusInfinity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameReferenceFinder</span><span class="o">&gt;</span> <span class="n">reference_finder_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoCodecType</span><span class="o">&gt;</span> <span class="n">current_codec_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">last_assembled_frame_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">last_seq_num_for_pic_id_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span> <span class="n">tracker_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Maps payload id to the depacketizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VideoRtpDepacketizer</span><span class="o">&gt;&gt;</span> <span class="n">payload_type_map_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(johan): Remove pt_codec_params_ once
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// https://bugs.chromium.org/p/webrtc/issues/detail?id=6883 is resolved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Maps a payload type to a map of out-of-band supplied codec parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CodecParameterMap</span><span class="o">&gt;</span> <span class="n">pt_codec_params_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int16_t</span> <span class="n">last_payload_type_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">has_received_frame_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">last_received_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">last_received_keyframe_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;</span> <span class="n">last_received_rtp_system_time_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;</span> <span class="n">last_received_keyframe_rtp_system_time_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Handles incoming encrypted frames and forwards them to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// rtp_reference_finder if they are decryptable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BufferedFrameDecryptor</span><span class="o">&gt;</span> <span class="n">buffered_frame_decryptor_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_PT_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">frames_decryptable_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">worker_task_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ColorSpace</span><span class="o">&gt;</span> <span class="n">last_color_space_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">AbsoluteCaptureTimeInterpolator</span> <span class="n">absolute_capture_time_interpolator_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CaptureClockOffsetUpdater</span> <span class="n">capture_clock_offset_updater_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">last_completed_picture_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">RtpVideoStreamReceiverFrameTransformerDelegate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame_transformer_delegate_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SeqNumUnwrapper</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">rtp_seq_num_unwrapper_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">RtpPacketInfo</span><span class="o">&gt;</span> <span class="n">packet_infos_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RtpPacketReceived</span><span class="o">&gt;</span> <span class="n">stashed_packets_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">Timestamp</span><span class="o">::</span><span class="n">MinusInfinity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的<code>OnRtpPacket</code>方法实现了<code>RtpPacketSinkInterface</code>这一接口，负责完成前面提到的 buffer 的第一个工作内容：接收 rtp 包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// This method handles both regular RTP packets and packets recovered
</span></span></span><span class="line"><span class="cl"><span class="c1">// via FlexFEC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">receiving_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ReceivePacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Update receive statistics after ReceivePacket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Receive statistics will be reset if the payload type changes (make sure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that the first packet is included in the stats).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtp_receive_statistics_</span><span class="o">-&gt;</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet_sink_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_sink_</span><span class="o">-&gt;</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，用于接收普通 rtp 包的方法为<code>ReceivePacket</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">ReceivePacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">payload_size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Padding or keep-alive packet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO(nisse): Could drop empty packets earlier, but need to figure out how
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// they should be counted in stats.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadType</span><span class="p">()</span> <span class="o">==</span> <span class="n">red_payload_type_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ParseAndHandleEncapsulatingHeader</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span> <span class="n">type_it</span> <span class="o">=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">type_it</span> <span class="o">==</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">parse_and_insert</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoRtpDepacketizer</span><span class="o">::</span><span class="n">ParsedRtpPayload</span><span class="o">&gt;</span> <span class="n">parsed_payload</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">type_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Parse</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadBuffer</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">parsed_payload</span> <span class="o">==</span> <span class="n">absl</span><span class="o">::</span><span class="n">nullopt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed parsing payload.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times_nacked</span> <span class="o">=</span> <span class="n">nack_module_</span>
</span></span><span class="line"><span class="cl">                           <span class="o">?</span> <span class="n">nack_module_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="n">packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                           <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">OnReceivedPayloadData</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">parsed_payload</span><span class="o">-&gt;</span><span class="n">video_payload</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">packet</span><span class="p">,</span> <span class="n">parsed_payload</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// When the dependency descriptor is used and the descriptor fail to parse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// then `OnReceivedPayloadData` may return true to signal the the packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// should be retried at a later stage, which is why they are stashed here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TODO(bugs.webrtc.org/15782):
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is an ugly solution. The way things should work is for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `RtpFrameReferenceFinder` to stash assembled frames until the keyframe with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the relevant template structure has been received, but unfortunately the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `frame_transformer_delegate_` is called before the frames are inserted into
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the `RtpFrameReferenceFinder`, and it expects the dependency descriptor to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// be parsed at that stage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">parse_and_insert</span><span class="p">(</span><span class="n">packet</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stashed_packets_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">parse_and_insert</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">it</span><span class="p">;</span>  <span class="c1">// keep in the stash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">it</span> <span class="o">=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>parse_and_insert()</code>中，首先将 packet 的<code>PayloadBuffer</code>移动到<code>parsed_payload</code>中，并且计算发送的 nack 的数量，然后将<code>parsed_payload</code>和<code>times_nacked</code>传入<code>OnReceivedPayloadData</code>来完成真正的 packet 解析和 frame 组装的工作。在下面<code>parse_and_insert</code>的使用过程，其实就是利用一个大小为 100 的 vector 来完成递归解析和组装属于同一个 frame 的 packet 的过程。这里的<code>OnReceivedPayloadData</code>的返回值表示的就是当前 packet 所属的帧有没有被解析完。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnReceivedPayloadData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span> <span class="n">codec_payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times_nacked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">packet</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">,</span> <span class="n">video</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">unwrapped_rtp_seq_num</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketInfo</span><span class="o">&amp;</span> <span class="n">packet_info</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">packet_infos_</span>
</span></span><span class="line"><span class="cl">          <span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">RtpPacketInfo</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">Ssrc</span><span class="p">(),</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Csrcs</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                 <span class="cm">/*receive_time_ms=*/</span><span class="n">clock_</span><span class="o">-&gt;</span><span class="n">CurrentTime</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">          <span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to extrapolate absolute capture time if it is missing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">packet_info</span><span class="p">.</span><span class="n">set_absolute_capture_time</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">absolute_capture_time_interpolator_</span><span class="p">.</span><span class="n">OnReceivePacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">AbsoluteCaptureTimeInterpolator</span><span class="o">::</span><span class="n">GetSource</span><span class="p">(</span><span class="n">packet_info</span><span class="p">.</span><span class="n">ssrc</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                                     <span class="n">packet_info</span><span class="p">.</span><span class="n">csrcs</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">          <span class="n">packet_info</span><span class="p">.</span><span class="n">rtp_timestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Assume frequency is the same one for all video frames.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">kVideoPayloadTypeFrequency</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">AbsoluteCaptureTimeExtension</span><span class="o">&gt;</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet_info</span><span class="p">.</span><span class="n">absolute_capture_time</span><span class="p">().</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_info</span><span class="p">.</span><span class="n">set_local_capture_clock_offset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">capture_clock_offset_updater_</span><span class="p">.</span><span class="n">ConvertsToTimeDela</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">capture_clock_offset_updater_</span><span class="p">.</span><span class="n">AdjustEstimatedCaptureClockOffset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">packet_info</span><span class="p">.</span><span class="n">absolute_capture_time</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="o">-&gt;</span><span class="n">estimated_capture_clock_offset</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video_header</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">kVideoRotation_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span> <span class="o">=</span> <span class="n">VideoContentType</span><span class="o">::</span><span class="n">UNSPECIFIED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VideoSendTiming</span><span class="o">::</span><span class="n">kInvalid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span> <span class="o">|=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Marker</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoOrientation</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoContentTypeExtension</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoTimingExtension</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">forced_playout_delay_max_ms_</span> <span class="o">&amp;&amp;</span> <span class="n">forced_playout_delay_min_ms_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span><span class="p">.</span><span class="n">emplace</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Millis</span><span class="p">(</span><span class="o">*</span><span class="n">forced_playout_delay_min_ms_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Millis</span><span class="p">(</span><span class="o">*</span><span class="n">forced_playout_delay_max_ms_</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span> <span class="o">=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">PlayoutDelayLimits</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UpdatePacketReceiveTimestamps</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtp_packet</span><span class="p">,</span> <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ParseGenericDependenciesResult</span> <span class="n">generic_descriptor_state</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">ParseGenericDependenciesExtension</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">video_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kStashPacket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kDropPacket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Timestamp</span> <span class="n">now</span> <span class="o">=</span> <span class="n">clock_</span><span class="o">-&gt;</span><span class="n">CurrentTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">last_logged_failed_to_parse_dd_</span> <span class="o">&gt;</span> <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_logged_failed_to_parse_dd_</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ssrc: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Ssrc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                          <span class="o">&lt;&lt;</span> <span class="s">&#34; Failed to parse dependency descriptor.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">video_structure_</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// No video structure received yet, most likely part of the initial
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// keyframe was lost.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">now</span> <span class="o">+</span> <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Color space should only be transmitted in the last packet of a frame,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// therefore, neglect it otherwise so that last_color_space_ is not reset by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// mistake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">ColorSpaceExtension</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Store color space since it&#39;s only transmitted when changed or for key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// frames. Color space will be cleared if a key frame is transmitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// without color space information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">last_color_space_</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">last_color_space_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">=</span> <span class="n">last_color_space_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">video_frame_tracking_id</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoFrameTrackingIdExtension</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">loss_notification_controller_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// TODO(bugs.webrtc.org/10336): Implement support for reordering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_INFO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34;LossNotificationController does not support reordering.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kNoGenericDescriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;LossNotificationController requires generic &#34;</span>
</span></span><span class="line"><span class="cl">                             <span class="s">&#34;frame descriptor, but it is missing.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_first_packet_in_frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">LossNotificationController</span><span class="o">::</span><span class="n">FrameDetails</span> <span class="n">frame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">is_keyframe</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">frame_id</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="o">-&gt;</span><span class="n">frame_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">frame_dependencies</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span> <span class="o">=</span> <span class="n">times_nacked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">codec_payload</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Only when we start to receive packets will we know what payload type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// that will be used. When we know the payload type insert the correct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sps/pps into the tracker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span> <span class="o">!=</span> <span class="n">last_payload_type_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_payload_type_</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">InsertSpsPpsIntoTracker</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">h26x_packet_buffer_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="n">FixedBitstream</span> <span class="n">fixed</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">tracker_</span><span class="p">.</span><span class="n">CopyAndFixBitstream</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtc</span><span class="o">::</span><span class="n">MakeArrayView</span><span class="p">(</span><span class="n">codec_payload</span><span class="p">.</span><span class="n">cdata</span><span class="p">(),</span> <span class="n">codec_payload</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">fixed</span><span class="p">.</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kRequestKeyframe</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="na">[[fallthrough]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kInsert</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fixed</span><span class="p">.</span><span class="n">bitstream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">codec_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">frame_counter_</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">       <span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH265</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h26x_packet_buffer_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnInsertedPacket</span><span class="p">(</span><span class="n">h26x_packet_buffer_</span><span class="o">-&gt;</span><span class="n">InsertPacket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnInsertedPacket</span><span class="p">(</span><span class="n">packet_buffer_</span><span class="p">.</span><span class="n">InsertPacket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个方法的核心判断的逻辑在于利用<code>ParseGenericDependenciesExtension</code>来判断当前 packet 的依赖类型，对于正常的依赖类型<code>kHasGenericDescriptor</code>，调用<code>InsertPacket</code>将 packet 插入到<code>PacketBuffer</code>中，并将<code>InsertPacket</code>的返回值作为<code>OnInsertedPacket</code>的参数来组帧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint16_t</span> <span class="n">seq_num</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_packet_received_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_packet_received_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">first_seq_num_</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If we have explicitly cleared past this packet then it&#39;s old,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// don&#39;t insert it, just silently ignore it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">is_cleared_to_first_seq_num_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ForwardDiff</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first_seq_num_</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Large negative jump in rtp sequence number: clear the buffer and treat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// latest packet as the new first packet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">first_packet_received_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">first_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Duplicate packet, just delete the payload.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">seq_num</span> <span class="o">==</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The packet buffer is full, try to expand the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">ExpandBufferSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Packet buffer is still full since we were unable to expand the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Clear the buffer, delete payload, and return false to signal that a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// new keyframe is needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Clear PacketBuffer and request key frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ClearInternal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">result</span><span class="p">.</span><span class="n">buffer_cleared</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">continuous</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">UpdateMissingPackets</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">received_padding_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">received_padding_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="n">received_padding_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">seq_num</span> <span class="o">-</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">result</span><span class="p">.</span><span class="n">packets</span> <span class="o">=</span> <span class="n">FindFrames</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>InsertPacket</code>的过程其实就是：首先判断是不是当前 packet 首包，是的话就记录一下，接下来的包开始往后排序，不是的话就调用包序列号比较函数 AheadOf。在利用索引计算的包在缓存中的位置如果被占用并且序列号一样，就是重复包，丢掉。如果被占用但是序列号不相同，就说明缓存满了，需要扩容，重新计算包的索引值，扩容后还是满的就要情况缓存了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">UpdateMissingPackets</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newest_inserted_seq_num_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">newest_inserted_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">kMaxPaddingAge</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">old_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">-</span> <span class="n">kMaxPaddingAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">erase_to</span> <span class="o">=</span> <span class="n">missing_packets_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">old_seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">erase_to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Guard against inserting a large amount of missing packets if there is a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// jump in the sequence number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">old_seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">newest_inserted_seq_num_</span> <span class="o">=</span> <span class="n">old_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">++*</span><span class="n">newest_inserted_seq_num_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">missing_packets_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">++*</span><span class="n">newest_inserted_seq_num_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>UpdateMissingPackets</code>主要是利用<code>missing_packets_</code>来维护丢包缓存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;&gt;</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">FindFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;&gt;</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">received_padding_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">seq_num</span><span class="p">)</span> <span class="o">!=</span> <span class="n">received_padding_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">seq_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PotentialNewFrame</span><span class="p">(</span><span class="n">seq_num</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">continuous</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If all packets of the frame is continuous, find the first packet of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// frame and add all packets of the frame to the returned packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">start_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Find the start index by searching backward until the packet with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `frame_begin` flag is set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">int</span> <span class="n">start_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">size_t</span> <span class="n">tested_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int64_t</span> <span class="n">frame_timestamp</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Identify H.264 keyframes by means of SPS, PPS, and IDR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">bool</span> <span class="n">is_generic</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">.</span><span class="n">has_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">is_h264_descriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_sps</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_pps</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_idr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">is_h264_keyframe</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">idr_width</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">idr_height</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">full_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">tested_packets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果是VPX，并且找到了frame_begin标识的第一个包，一帧完整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">              <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">full_frame_found</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">h264_header</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderH264</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h264_header</span> <span class="o">||</span> <span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus_length</span> <span class="o">&gt;=</span> <span class="n">kMaxNalusPerPacket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus_length</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kSps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_sps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kPps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_pps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kIdr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_idr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">((</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_idr</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_sps</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">               <span class="n">has_h264_pps</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="o">!</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_idr</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is_h264_keyframe</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Store the resolution of key frame which is the packet with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// smallest index and valid resolution; typically its IDR or SPS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// packet; there may be packet preceeding this packet, IDR&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// resolution will be applied to them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">idr_width</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">              <span class="n">idr_height</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tested_packets</span> <span class="o">==</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">start_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">start_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// In the case of H264 we don&#39;t have a frame_begin bit (yes,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// `frame_begin` might be set to true but that is a lie). So instead
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// we traverese backwards as long as we have a previous packet and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the timestamp of that packet is the same as this one. This may cause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the PacketBuffer to hand out incomplete frames.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// See: https://bugs.chromium.org/p/webrtc/issues/detail?id=7106
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">             <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">!=</span> <span class="n">frame_timestamp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">start_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Warn if this is an unsafe frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">has_h264_idr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">has_h264_sps</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_h264_pps</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34;Received H.264-IDR frame &#34;</span>
</span></span><span class="line"><span class="cl">                 <span class="s">&#34;(SPS: &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="n">has_h264_sps</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, PPS: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">has_h264_pps</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;). Treating as &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">?</span> <span class="s">&#34;delta&#34;</span> <span class="o">:</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; frame since WebRTC-SpsPpsIdrIsH264Keyframe is &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">?</span> <span class="s">&#34;enabled.&#34;</span> <span class="o">:</span> <span class="s">&#34;disabled&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Now that we have decided whether to treat this frame as a key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// or delta frame in the frame buffer, we update the field that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// determines if the RtpFrameObject is a key frame or delta frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_t</span> <span class="n">first_packet_index</span> <span class="o">=</span> <span class="n">start_seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_keyframe</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">idr_width</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idr_height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// IDR frame was finalized and we have the correct resolution for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// IDR; update first packet to have same resolution as IDR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">idr_width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">idr_height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If this is not a keyframe, make sure there are no gaps in the packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sequence numbers up until this point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_h264_keyframe</span> <span class="o">&amp;&amp;</span> <span class="n">missing_packets_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">start_seq_num</span><span class="p">)</span> <span class="o">!=</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span> <span class="o">||</span> <span class="n">full_frame_found</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">end_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Use uint16_t type to handle sequence number wrap around case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">uint16_t</span> <span class="n">num_packets</span> <span class="o">=</span> <span class="n">end_seq_num</span> <span class="o">-</span> <span class="n">start_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">found_frames</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">found_frames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">num_packets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start_seq_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">end_seq_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;&amp;</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_DCHECK_EQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Ensure frame boundary flags are properly set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_first_packet_in_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">start_seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">found_frames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="n">missing_packets_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">seq_num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">received_padding_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">received_padding_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                <span class="n">received_padding_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">seq_num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>FindFrames</code>的主要工作是检测帧的完整性，具体的实现方式是遍历排序缓存中连续的包，来检查一帧的边界，并且对于 VPX 和 H264 的处理做了区分。对于 VPX，通过检测 frame_begin 和 frame_end 这两个包来确定收到了一个完整的帧，而对于 H264 则通过从 frame_end 标识的一帧最后一个包向前追溯，直到找到一个时间戳不一样的断层，认为找到了完整的一个 H264 的帧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnInsertedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_task_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">*</span> <span class="n">first_packet</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">max_nack_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">min_recv_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">max_recv_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;&gt;</span> <span class="n">payloads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketInfos</span><span class="o">::</span><span class="n">vector_type</span> <span class="n">packet_infos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">frame_boundary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">packet</span> <span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">packets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// PacketBuffer promisses frame boundaries are correctly set on each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// packet. Document that assumption with the DCHECKs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">RTC_DCHECK_EQ</span><span class="p">(</span><span class="n">frame_boundary</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">unwrapped_rtp_seq_num</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_GT</span><span class="p">(</span><span class="n">packet_infos_</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpPacketInfo</span><span class="o">&amp;</span> <span class="n">packet_info</span> <span class="o">=</span> <span class="n">packet_infos_</span><span class="p">[</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">first_packet</span> <span class="o">=</span> <span class="n">packet</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_nack_count</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">min_recv_time</span> <span class="o">=</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_recv_time</span> <span class="o">=</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_nack_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_nack_count</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">min_recv_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">min_recv_time</span><span class="p">,</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_recv_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_recv_time</span><span class="p">,</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">payloads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_infos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">packet_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">frame_boundary</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">depacketizer_it</span> <span class="o">=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_CHECK</span><span class="p">(</span><span class="n">depacketizer_it</span> <span class="o">!=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_CHECK</span><span class="p">(</span><span class="n">depacketizer_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">EncodedImageBuffer</span><span class="o">&gt;</span> <span class="n">bitstream</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">depacketizer_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">AssembleFrame</span><span class="p">(</span><span class="n">payloads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitstream</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Failed to assemble a frame. Discard and continue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&amp;</span> <span class="n">last_packet</span> <span class="o">=</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">OnAssembledFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">,</span>                             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">seq_num</span><span class="p">,</span>                               <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">marker_bit</span><span class="p">,</span>                            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">max_nack_count</span><span class="p">,</span>                                    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">min_recv_time</span><span class="p">,</span>                                     <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">max_recv_time</span><span class="p">,</span>                                     <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">,</span>                           <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">ntp_estimator_</span><span class="p">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">),</span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">,</span>             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">,</span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">(),</span>                             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span>                 <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span><span class="p">,</span>             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">,</span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span><span class="p">,</span>              <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">RtpPacketInfos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet_infos</span><span class="p">)),</span>           <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">      <span class="n">payloads</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">packet_infos</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">frame_boundary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">buffer_cleared</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_rtp_system_time_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_keyframe_rtp_system_time_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_keyframe_rtp_timestamp_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_infos_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>OnInsertedPacket</code>中的主要逻辑就是缓存解析好的 packet，在遍历到当前帧的最后一个包之后调用<code>OnAssembledFrame</code>进行组帧。至此，rtp 包的排序和组帧的工作结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnAssembledFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">RTPVideoHeader</span><span class="o">::</span><span class="n">GenericDescriptorInfo</span><span class="o">&gt;&amp;</span> <span class="n">descriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame</span><span class="o">-&gt;</span><span class="n">GetRtpVideoHeader</span><span class="p">().</span><span class="n">generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">loss_notification_controller_</span> <span class="o">&amp;&amp;</span> <span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnAssembledFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">(),</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">frame_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">absl</span><span class="o">::</span><span class="n">c_linear_search</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">decode_target_indications</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="n">DecodeTargetIndication</span><span class="o">::</span><span class="n">kDiscardable</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If frames arrive before a key frame, they would not be decodable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// In that case, request a key frame ASAP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_received_frame_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">FrameType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// `loss_notification_controller_`, if present, would have already
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// requested a key frame when the first packet for the non-key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// had arrived, so no need to replicate the request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loss_notification_controller_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">has_received_frame_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Reset `reference_finder_` if `frame` is new and the codec have changed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">current_codec_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">frame_is_newer</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">AheadOf</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">(),</span> <span class="n">last_assembled_frame_rtp_timestamp_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">current_codec_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">frame_is_newer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// When we reset the `reference_finder_` we don&#39;t want new picture ids
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to overlap with old picture ids. To ensure that doesn&#39;t happen we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// start from the `last_completed_picture_id_` and add an offset in case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// of reordering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">reference_finder_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RtpFrameReferenceFinder</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_completed_picture_id_</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_codec_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Old frame from before the codec switch, discard it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame_is_newer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_assembled_frame_rtp_timestamp_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_codec_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_assembled_frame_rtp_timestamp_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffered_frame_decryptor_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffered_frame_decryptor_</span><span class="o">-&gt;</span><span class="n">ManageEncryptedFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">frame_transformer_delegate_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_transformer_delegate_</span><span class="o">-&gt;</span><span class="n">TransformFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnCompleteFrames</span><span class="p">(</span><span class="n">reference_finder_</span><span class="o">-&gt;</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>OnAssembledFrame</code>中则通过调用<code>RtpFrameReferenceFinder</code>的<code>ManageFrame</code>来寻找一个帧解码时所依赖的帧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If we have cleared past this frame, drop it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">cleared_to_seq_num_</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">AheadOf</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cleared_to_seq_num_</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">frames</span> <span class="o">=</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">AddPictureIdOffset</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>impl_</code>是<code>RtpFrameReferenceFinder</code>代码逻辑的实现类的实例，其<code>ManageFrame</code>函数是寻找依赖帧的核心逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpFrameReferenceFinderImpl</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video_header</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">GetRtpVideoHeader</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpGenericFrameRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="o">*</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecVP8</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RTPVideoHeaderVP8</span><span class="o">&amp;</span> <span class="n">vp8_header</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">absl</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderVP8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vp8_header</span><span class="p">.</span><span class="n">temporalIdx</span> <span class="o">==</span> <span class="n">kNoTemporalIdx</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="n">vp8_header</span><span class="p">.</span><span class="n">tl0PicIdx</span> <span class="o">==</span> <span class="n">kNoTl0PicIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">vp8_header</span><span class="p">.</span><span class="n">pictureId</span> <span class="o">==</span> <span class="n">kNoPictureId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">vp8_header</span><span class="p">.</span><span class="n">pictureId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpVp8RefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecVP9</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RTPVideoHeaderVP9</span><span class="o">&amp;</span> <span class="n">vp9_header</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">absl</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderVP9</span><span class="o">&gt;</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vp9_header</span><span class="p">.</span><span class="n">temporal_idx</span> <span class="o">==</span> <span class="n">kNoTemporalIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">vp9_header</span><span class="p">.</span><span class="n">picture_id</span> <span class="o">==</span> <span class="n">kNoPictureId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">vp9_header</span><span class="p">.</span><span class="n">picture_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpVp9RefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecGeneric</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">generic_header</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderLegacyGeneric</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">generic_header</span><span class="o">-&gt;</span><span class="n">picture_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个方法中主要是针对不同的编码类型做了分类处理，实际上完成寻找依赖帧工作的函数则交给了<code>RtpSeqNumOnlyRefFinder</code>的<code>ManageFrame</code>和<code>ManageFrameInternal</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">FrameDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">decision</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kStash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">stashed_frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">kMaxStashedFrames</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kHandOff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">RetryStashedFrames</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">FrameDecision</span>
</span></span><span class="line"><span class="cl"><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">RtpFrameObject</span><span class="o">*</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果是关键帧，插入GOP表，key是last_seq_num，初始value是{last_seq_num,last_seq_num}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_seq_num_GOP_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">())));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// We have received a frame but not yet a keyframe, stash this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果GOP表空，那么就不可能找到参考帧，先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">last_seq_num_GOP_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">kStash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Clean up info for old keyframes but make sure to keep info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for the last keyframe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 删除较老的关键帧(PID小于last_seq_num - 100), 但是至少保留一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">clean_to</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">clean_to</span> <span class="o">&amp;&amp;</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Find the last sequence number of the last frame for the keyframe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that this frame indirectly references.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 在GOP表中搜索第一个比当前帧新的关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">seq_num_it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果搜索到的关键帧是最老的，说明当前帧比最老的关键帧还老，无法设置参考帧，丢弃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">seq_num_it</span> <span class="o">==</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Generic frame with packet range [&#34;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="s">&#34;] has no GoP, dropping frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">kDrop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果搜索到的关键帧不是最老的，那么搜索到的关键帧的上一个关键帧所在的GOP里应该可以找到参考帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果找不到关键帧，seq_num_it为end(), seq_num_it--则为最后一个关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">seq_num_it</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Make sure the packet sequence numbers are continuous, otherwise stash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 保证帧的连续，不连续则先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前GOP的最新一个帧的最后一个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">last_picture_id_gop</span> <span class="o">=</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当前GOP的最新包的序列号，可能是last_picture_id_gop, 也可能是填充包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">last_picture_id_with_padding_gop</span> <span class="o">=</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// P帧的连续性检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获得P帧第一个包的上个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">prev_seq_num</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果P帧第一个包的上个包的序列号与当前GOP的最新包的序列号不等，说明不连续，先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">prev_seq_num</span> <span class="o">!=</span> <span class="n">last_picture_id_with_padding_gop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">kStash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 现在这个帧是连续的了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">AheadOrAt</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Since keyframes can cause reordering we can&#39;t simply assign the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// picture id according to some incrementing counter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 获得当前帧的最后一个包的序列号，设置为初始PID，后面还会设置一次Unwrap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetId</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置帧的参考帧数，P帧才需要1个参考帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">num_references</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置参考帧为当前GOP的最新一个帧的最后一个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 既然该帧是连续的，那么其参考帧自然也就是上个帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">last_picture_id_gop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果当前帧比当前GOP的最新一个帧的最后一个包还新，则更新GOP的最新一个帧的最后一个包(first)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 以及GOP的最新包(second)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">(),</span> <span class="n">last_picture_id_gop</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新填充包状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UpdateLastPictureIdWithPadding</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetSpatialIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置当前帧的PID为Unwrap形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetId</span><span class="p">(</span><span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">kHandOff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">RetryStashedFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">frame_it</span> <span class="o">=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="n">frame_it</span> <span class="o">!=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrameDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">frame_it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="n">decision</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kStash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="o">++</span><span class="n">frame_it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kHandOff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">frame_it</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">          <span class="na">[[fallthrough]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">frame_it</span> <span class="o">=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">frame_it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">complete_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>ManageFrameInternal</code>的核心逻辑实际上就是前面所说的，处理 GOP 内帧的连续性以及设置参考帧。至此就完成了 GOP 内的帧排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnCompleteFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">frame</span> <span class="p">:</span> <span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_seq_num_for_pic_id_</span><span class="p">[</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">last_completed_picture_id_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">last_completed_picture_id_</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">complete_frame_callback_</span><span class="o">-&gt;</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而<code>OnCompleteFrames</code>则接受<code>MangeFrame</code>的返回值作为参数，遍历 GOP 中已经排好序的 Frame 调用<code>complete_frame_callback_</code>的<code>OnCompleteFrame</code>函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">VideoReceiveStream2</span><span class="o">::</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoPlayoutDelay</span><span class="o">&gt;</span> <span class="n">playout_delay</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">frame</span><span class="o">-&gt;</span><span class="n">EncodedImage</span><span class="p">().</span><span class="n">PlayoutDelay</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_minimum_playout_delay_</span> <span class="o">=</span> <span class="n">playout_delay</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_maximum_playout_delay_</span> <span class="o">=</span> <span class="n">playout_delay</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">UpdatePlayoutDelays</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">last_continuous_pid</span> <span class="o">=</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">last_continuous_pid</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// TODO(bugs.webrtc.org/11993): Call on the network thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_video_stream_receiver_</span><span class="p">.</span><span class="n">FrameContinuous</span><span class="p">(</span><span class="o">*</span><span class="n">last_continuous_pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里先更新<code>playout_delay</code>用于之后 Jitter 的计算，然后将 frame 插入到<code>VideoStreamBufferController</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">VideoStreamBufferController</span><span class="o">::</span><span class="n">InsertFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">FrameMetadata</span> <span class="nf">metadata</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">complete_units</span> <span class="o">=</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">GetTotalNumberOfContinuousTemporalUnits</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame receive time must be set!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">metadata</span><span class="p">.</span><span class="n">delayed_by_retransmission</span> <span class="o">&amp;&amp;</span> <span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">field_trials_</span><span class="p">.</span><span class="n">IsDisabled</span><span class="p">(</span><span class="s">&#34;WebRTC-IncomingTimestampOnMarkerBitOnly&#34;</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">         <span class="n">metadata</span><span class="p">.</span><span class="n">is_last_spatial_layer</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">timing_</span><span class="o">-&gt;</span><span class="n">IncomingTimestamp</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">rtp_timestamp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">*</span><span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">complete_units</span> <span class="o">&lt;</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">GetTotalNumberOfContinuousTemporalUnits</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stats_proxy_</span><span class="o">-&gt;</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">is_keyframe</span><span class="p">,</span> <span class="n">metadata</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">metadata</span><span class="p">.</span><span class="n">contentType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">MaybeScheduleFrameForRelease</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">LastContinuousFrameId</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的核心逻辑就是将 frame 插入到<code>FrameBuffer</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">FrameBuffer</span><span class="o">::</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ValidReferences</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; has invalid references, dropping frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 根据frame的id判断是否解码过，解码过就不插入直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">decoded_frame_history_</span><span class="p">.</span><span class="n">GetLastDecodedFrameId</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">legacy_frame_id_jump_behavior_</span> <span class="o">&amp;&amp;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">is_keyframe</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">AheadOf</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="n">decoded_frame_history_</span><span class="p">.</span><span class="n">GetLastDecodedFrameTimestamp</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34;Keyframe &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34; has newer timestamp but older picture id, clearing buffer.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Already decoded past this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 判断填满buffer的frame是不是I帧，是就清空buffer，否则不插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">is_keyframe</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Keyframe &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                           <span class="o">&lt;&lt;</span> <span class="s">&#34; inserted into full buffer, clearing buffer.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// No space for this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 插入当前帧到FrameBuffer中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">frame_id</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">insert_res</span> <span class="o">=</span> <span class="n">frames_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">frame_id</span><span class="p">,</span> <span class="n">FrameInfo</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insert_res</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Frame has already been inserted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame_id</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; inserted, buffer is now full.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 前向传播当前FrameBuffer中的解码连续性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PropagateContinuity</span><span class="p">(</span><span class="n">insert_res</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新下一个可解码的时域单元的timestamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FindNextAndLastDecodableTemporalUnit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>视频帧的<code>FrameBuffer</code>按照可解码的顺序建立完毕，之后就可以根据 Jitter Delay 来交付给解码器解码了。至此，Buffer 的功能分析完毕，下篇学习分析 Jitter Buffer 的核心算法，也就是 Jitter 的计算过程。</p>
]]></description>
</item>
<item>
    <title>WebRTC任务队列学习笔记</title>
    <link>https://ayamir.github.io/posts/development/webrtc-task-queue/</link>
    <pubDate>Tue, 19 Mar 2024 19:32:57 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/development/webrtc-task-queue/</guid>
    <description><![CDATA[<h2 id="taskqueue">TaskQueue</h2>
<p><code>TaskQueue</code>也即任务队列，不过这个类本身并没有与队列相关的任何代码，所以它是用来干什么的呢？</p>
<p>我们直接来读代码（为了方便，我这里直接把方法的实现代码贴了出来）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RTC_LOCKABLE</span> <span class="n">RTC_EXPORT</span> <span class="n">TaskQueue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TaskQueue priority levels. On some platforms these will map to thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// priorities, on others such as Mac and iOS, GCD queue priorities.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">Priority</span> <span class="o">=</span> <span class="o">::</span><span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueFactory</span><span class="o">::</span><span class="n">Priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">TaskQueue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueBase</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueDeleter</span><span class="o">&gt;</span> <span class="n">task_queue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">task_queue</span><span class="p">.</span><span class="n">release</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">TaskQueue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">Delete</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Used for DCHECKing the current queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">IsCurrent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">IsCurrent</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns non-owning pointer to the task queue implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">impl_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(tommi): For better debuggability, implement RTC_FROM_HERE.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Ownership of the task is passed to PostTask.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">PostTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">PostTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Schedules a task to execute a specified number of milliseconds from when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the call is made. The precision should be considered as &#34;best effort&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and in some cases, such as on Windows when all high precision timers have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// been used up, can be off by as much as 15 millseconds (although 8 would be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// more likely). This can be mitigated by limiting the use of delayed tasks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">PostDelayedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">uint32_t</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">PostDelayedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">milliseconds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// std::enable_if is used here to make sure that calls to PostTask() with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// std::unique_ptr&lt;SomeClassDerivedFromQueuedTask&gt; would not end up being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// caught by this template.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">PostTask</span><span class="p">(</span><span class="n">Closure</span><span class="o">&amp;&amp;</span> <span class="n">closure</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PostTask</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">ToQueuedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">&gt;</span><span class="p">(</span><span class="n">closure</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// See documentation above for performance expectations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">PostDelayedTask</span><span class="p">(</span><span class="n">Closure</span><span class="o">&amp;&amp;</span> <span class="n">closure</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PostDelayedTask</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">ToQueuedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">&gt;</span><span class="p">(</span><span class="n">closure</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">milliseconds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">impl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DISALLOW_COPY_AND_ASSIGN</span><span class="p">(</span><span class="n">TaskQueue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>private</code>部分：</p>
<p><code>TaskQueue</code>只有一个私有变量，也就是使用<code>TaskQueueBase</code>的裸指针指向的常量<code>impl_</code>，并且<code>TaskQueue</code>禁用了拷贝构造函数和赋值运算符。</p>
<p>这里为什么存放的是裸指针呢，我猜主要是出于性能的考虑。</p>
<p><code>public</code>部分：</p>
<p><code>TaskQueue</code>的构造函数接受 1 个参数，也就是使用<code>unique_ptr</code>管理生命周期的对象，这个对象需要是实现了<code>TaskQueueBase</code>这一接口的对象。</p>
<p><code>TaskQueue</code>有 2 个重要的方法，也就是<code>PostTask</code>和<code>PostDelayedTask</code>。</p>
<ul>
<li><code>PostTask</code>：将<code>task</code>加入到任务队列中进行即时处理；</li>
<li><code>PostDelayedTask</code>：将<code>task</code>加入到任务队列中，过<code>milliseconds</code>毫秒处理。</li>
</ul>
<p>这 2 种方法都有 2 种重载形式。在 webrtc 的代码中，经常使用的是接受一个闭包也就是 lambda 表达式作为参数的这一重载形式。</p>
<p>比如在<code>call/rtp_transport_controller_send.cc</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpTransportControllerSend</span><span class="o">::</span><span class="n">OnSentPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rtc</span><span class="o">::</span><span class="n">SentPacket</span><span class="o">&amp;</span> <span class="n">sent_packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">task_queue_</span><span class="p">.</span><span class="n">PostTask</span><span class="p">([</span><span class="k">this</span><span class="p">,</span> <span class="n">sent_packet</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_queue_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">SentPacket</span><span class="o">&gt;</span> <span class="n">packet_msg</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">transport_feedback_adapter_</span><span class="p">.</span><span class="n">ProcessSentPacket</span><span class="p">(</span><span class="n">sent_packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pacer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">UpdateOutstandingData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">transport_feedback_adapter_</span><span class="p">.</span><span class="n">GetOutstandingData</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet_msg</span> <span class="o">&amp;&amp;</span> <span class="n">controller_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">PostUpdates</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">OnSentPacket</span><span class="p">(</span><span class="o">*</span><span class="n">packet_msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpTransportControllerSend</span><span class="o">::</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ReceivedPacket</span><span class="o">&amp;</span> <span class="n">packet_msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">task_queue_</span><span class="p">.</span><span class="n">PostTask</span><span class="p">([</span><span class="k">this</span><span class="p">,</span> <span class="n">packet_msg</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_queue_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">controller_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">PostUpdates</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span><span class="n">packet_msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>TaskQueue</code>的创建基本上都是采用工厂模式完成。</p>
<p>从<code>TaskQueue</code>的实现代码中可以发现，它其实只是为实现了<code>TaskQueueBase</code>这一接口类的子类封装了一个统一的调用接口，实际上起到的是代理的作用。</p>
<p>真正做事的或者说真正核心的代码应该是<code>TaskQueueBase</code>这个接口类的定义以及实现其纯虚函数的子类。</p>
<h2 id="taskqueuebase">TaskQueueBase</h2>
<p><code>TaskQueueBase</code>是 WebRTC 中用来实现异步执行任务的类，保证队列中的任务按照 FIFO 的顺序执行，不同任务的执行时间不会重叠。</p>
<p>不过，同一个任务队列中的不同任务并不一定总是在相同的 worker 线程上执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RTC_LOCKABLE</span> <span class="n">RTC_EXPORT</span> <span class="n">TaskQueueBase</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Starts destruction of the task queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On return ensures no task are running and no new tasks are able to start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the task queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Responsible for deallocation. Deallocation may happen syncrhoniously during
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Delete or asynchronously after Delete returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Code not running on the TaskQueue should not make any assumption when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TaskQueue is deallocated and thus should not call any methods after Delete.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Code running on the TaskQueue should not call Delete, but can assume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TaskQueue still exists and may call other methods, e.g. PostTask.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Delete</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Schedules a task to execute. Tasks are executed in FIFO order.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If |task-&gt;Run()| returns true, task is deleted on the task queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// before next QueuedTask starts executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// When a TaskQueue is deleted, pending tasks will not be executed but they
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// will be deleted. The deletion of tasks may happen synchronously on the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TaskQueue or it may happen asynchronously after TaskQueue is deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This may vary from one implementation to the next so assumptions about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// lifetimes of pending tasks should not be made.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PostTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Schedules a task to execute a specified number of milliseconds from when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the call is made. The precision should be considered as &#34;best effort&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and in some cases, such as on Windows when all high precision timers have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// been used up, can be off by as much as 15 millseconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PostDelayedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="kt">uint32_t</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns the task queue that is running the current thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Returns nullptr if this thread is not associated with any task queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="nf">Current</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">IsCurrent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">()</span> <span class="o">==</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">CurrentTaskQueueSetter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ABSL_CONST_INIT</span> <span class="k">thread_local</span> <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">CurrentTaskQueueSetter</span><span class="p">(</span><span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">task_queue</span><span class="p">)</span> <span class="o">:</span> <span class="n">previous_</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span> <span class="o">=</span> <span class="n">task_queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">CurrentTaskQueueSetter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span> <span class="o">=</span> <span class="n">previous_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">CurrentTaskQueueSetter</span><span class="p">(</span><span class="k">const</span> <span class="n">CurrentTaskQueueSetter</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CurrentTaskQueueSetter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">CurrentTaskQueueSetter</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">previous_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Users of the TaskQueue should call Delete instead of directly deleting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// this object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="o">~</span><span class="n">TaskQueueBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从代码中的注释可以看明白<code>PostTask</code>这一方法的作用，也就是我们上面所说的：把<code>task</code>加入到事件队列中，按照 FIFO 的顺序进行处理。</p>
<p>需要注意的是，这里还有一个可访问性为<code>protected</code>的类：<code>CurrentTaskQueueSetter</code>，这个类的作用就像它的命名一样，用于设置当前的任务队列，也就是把任务队列绑定到当前线程上。</p>
<ul>
<li>构造时，用传入构造函数的任务队列更新当前线程存放的任务队列，并将更新前的任务队列暂存到当前线程的 TLS(Thread Local Storage)中。</li>
<li>析构时，用构造时暂存的任务队列更新当前线程存放的任务队列。</li>
</ul>
<p>WebRTC 中有好几个实现了<code>TaskQueueBase</code>这一接口的类如<code>TaskQueueStdlib</code>, <code>TaskQueueLibevent</code>, <code>TaskQueueWin</code>, <code>SimulatedTaskQueue</code>等，它们的作用也各不相同。</p>
<p>下面我们以<code>TaskQueueStdlib</code>为例，对实际的<code>PostTask</code>等函数是如何运行的一探究竟。</p>
<h2 id="taskqueuestdlib">TaskQueueStdlib</h2>
]]></description>
</item>
<item>
    <title>远程桌面与WebRTC</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/remote-desktop-with-webrtc/</link>
    <pubDate>Thu, 15 Jun 2023 18:21:02 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/remote-desktop-with-webrtc/</guid>
    <description><![CDATA[<h1 id="关于远程桌面">关于远程桌面</h1>
<p>远程桌面是一种将一台计算机的桌面控制权限交给网络上另一台计算机的技术，两台计算机之间建立连接之后，可以进行音视频以及控制信令的相互传输，从而实现远程控制的功能。</p>
<h1 id="远程桌面技术的实现">远程桌面技术的实现</h1>
<p>基于远程桌面要完成的任务目标，其需要实现以下两个核心功能：</p>
<ol>
<li>音视频的传输，即需要让控制机收到受控机的音频跟视频。</li>
<li>控制信令的传输，即鼠标键盘的控制信号等</li>
</ol>
<p>目前主流的远程桌面技术主要有 2 种：</p>
<ol>
<li>基于<a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing" target="_blank" rel="noopener noreffer">VNC(Virtual Network Computing)</a>的远程桌面技术</li>
<li>基于<a href="https://en.wikipedia.org/wiki/Remote_Desktop_Protocol" target="_blank" rel="noopener noreffer">RDP(Remote Desktop Protocol)</a>的远程桌面技术</li>
</ol>
<h2 id="vnc">VNC</h2>
<p>VNC 使用远程帧缓冲协议即(RFB, Remote FrameBuffer)来远程控制另一台计算机，将控制机的键盘和鼠标事件传输到被控制机，同时将被控制机的屏幕图像传输到控制机。</p>
<p>基于其技术原理，VNC 有以下优点：</p>
<ol>
<li>跨平台，可以在不同的操作系统上运行，VNC 技术本身也有多个客户端和服务端的实现版本，如 RealVNC、TightVNC、UltraVNC 等</li>
<li>开源，VNC 的源代码及其很多现代衍生品都是在 GNU 许可证之下发布的</li>
<li>轻量级，VNC 的客户端和服务端都是非常轻量级的程序，可以在低配置的计算机上运行</li>
</ol>
<p>但因为 VNC 本身的设计时间很早，因此在 2023 年的今天暴露出了很多的时代局限性：</p>
<ol>
<li>因为其基于像素方块的传输原理，就算是采用部分更新传输的方式，在大量像素变化的情况下会消耗大量的带宽。特别是对于现在的高分屏，其传输的数据量会更大。</li>
<li>VNC 在设计之初被用于局域网内使用，因此没有考虑太多的安全性，虽然密码并不以明文发送，但是如果从网络中嗅探出加密密钥和编码之后的密码，也可能成功破解出密码。</li>
</ol>
<h2 id="rdp">RDP</h2>
<p>RDP 是<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/remote/understanding-remote-desktop-protocol" target="_blank" rel="noopener noreffer">微软提出的一种专有协议</a>，扩展了 T-120 系列协议标准，最早专用于 Windows 系统的终端和服务器之间的远程桌面连接，之后微软也实现了<a href="https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-mac" target="_blank" rel="noopener noreffer">RDP 的 MacOS 客户端</a>，现在也有很多第三方的实现版本实现了其功能的子集，为 GNU/Linux 做了适配如<a href="https://github.com/neutrinolabs/xrdp" target="_blank" rel="noopener noreffer">xrdp</a>。因此，可以说 RDP 也一定程度上具有跨平台的性质。</p>
<p>相比于 VNC，RDP 的实现原理还是比较复杂的：</p>
<p></p>
<p>首先，RDP 的最底层是 TCP，TCP 之上是各层的协议和服务。</p>
<ul>
<li>TPKT：是 TCP 之上的 ISO 传输服务，允许两个组交换 TPDU（传输协议数据单元）或 PDU（协议数据单元）的信息单元。</li>
<li>X.224：连接传输协议，主要用于 RDP 初始连接请求和响应。</li>
<li>T.125 MCS：多点通信服务，允许 RDP 通过多个通道进行通信和管理。</li>
</ul>
<p>RDP 的工作原理是通过 TPKT 实现信息单元的交换，通过 X.224 建立连接，使用 T.125 MCS 打开两个通道来完成两个设备之间的来回数据传输。</p>
<p>RDP 的特点功能比较丰富，比如：</p>
<ul>
<li>支持共享剪切板。</li>
<li>支持多个显示器。</li>
<li>支持虚拟化 GPU。</li>
<li>支持 32 位彩色和 64000 个独立的数据传输通道。</li>
<li>通过 RC4 对称加密算法使用 128 位密钥对数据进行加密。</li>
<li>可以在使用远程计算机时参考本地计算机上的文件系统。</li>
<li>远程计算机的应用程序可以在本地计算机上运行。</li>
</ul>
<p>当然，事物都有两面性，RDP 拥有这么多强大功能，也有一些难以避免的缺点：</p>
<ul>
<li>网络速度较慢时，远程连接容易出现延迟。</li>
<li>两台计算机在不同的网络上时，其配置过程相当复杂。</li>
<li>固定使用 3389 端口监听，可能成为攻击的目标。</li>
<li>RDP 整体上还是受到微软控制，定制性比较差。</li>
</ul>
<h1 id="webrtc-和远程桌面">WebRTC 和远程桌面</h1>
<p>远程桌面的核心需求和 WebRTC 的核心功能完美契合。</p>
<ul>
<li>WebRTC 基于 ICE/STUN/TURN 的 NAT 穿透方案可以很方便地解决不同网络情况下主机连接的问题，</li>
<li>WebRTC 基于 SRTP 的传输方式天然提供了实时特征、端到端的加密的数据传输服务。</li>
<li>WebRTC 针对各种网络情况做了音视频传输的大量优化，可以保证各种网络条件下的可用性。</li>
<li>WebRTC 本身其实是 Chromium 浏览器的一部分，天然具备跨平台的性质。</li>
<li>WebRTC 完全开源，定制性极强，不少公司都基于 WebRTC 来做自家的直播、云游戏业务。</li>
</ul>
<p>整体上来讲，WebRTC 的优势使其很适合用于远程桌面业务，当然，目前市面上已经有 App 基于 WebRTC 实现了远程桌面的功能，比如<a href="https://en.wikipedia.org/wiki/Chrome_Remote_Desktop" target="_blank" rel="noopener noreffer">Chrome Remote Desktop</a>和<a href="https://www.todesk.com/" target="_blank" rel="noopener noreffer">ToDesk</a>。前者可以理解为是 Google 用自己 WebRTC 推出的远程桌面服务，体验了一下，整体上功能比较少，但是连接比较稳定，不过受 GFW 影响，这玩意在国内应该是处于没法用的状态；后者则是国产远程桌面软件，目前已经比较成熟，提供了企业版、个人版、专业版和游戏版四个版本，从其官网上提供的信息来看，应该是做出了一定成绩。</p>
<p>从技术上讲，基于 WebRTC 开发远程桌面应用相当合理，开源可控，还有谷歌背书，WebRTC 本身在不停地与时俱进，作为上层应用开发的远程桌面也可以及时享受到 WebRTC 带来的改进。</p>
<p>从业务上讲，WebRTC 本身具有的功能可以解决上面所说的 VNC 和 RDP 的诸多问题，不过就功能的丰富性而言，可能跟微软的 RDP 还差一些，但是 WebRTC 基于音视频的解决方案本身可以优化的上限还是挺高的，毕竟随着人们需求的上升，高分辨率、高帧率也会成为未来远程桌面应用必不可少的功能需求。</p>
<p>本篇博客从非技术层面探讨了远程桌面技术的当下两大主流技术，以及 WebRTC 应用于远程桌面业务下的可行性。下篇博客将从技术层面详细分析 WebRTC 与远程桌面业务的契合程度及可能的解决方案，就先从核心功能开始吧！</p>
]]></description>
</item>
<item>
    <title>在Linux下如何搭建WebRTC的开发环境</title>
    <link>https://ayamir.github.io/posts/development/webrtc-development-prepare/</link>
    <pubDate>Sun, 23 Apr 2023 21:28:38 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/development/webrtc-development-prepare/</guid>
    <description><![CDATA[<p>本文主要记录笔者在 Gentoo Linux 下面搭建 WebRTC 开发环境的过程。</p>
<h2 id="准备工作">准备工作</h2>
<ol>
<li>网络：可以科学上网的梯子</li>
<li>IDE：VSCode 或者 CLion</li>
</ol>
<h2 id="安装depot_tools">安装<code>depot_tools</code></h2>
<p>Google 有自己的一套用于管理 Chromium 项目的工具，名叫<code>depot_tools</code>，其中有包括<code>git</code>在内的一系列工具和脚本。</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建google目录用于存储google相关的代码</span>
</span></span><span class="line"><span class="cl">mkdir ~/google
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> ~/google
</span></span><span class="line"><span class="cl"><span class="c1"># clone depot_tools</span>
</span></span><span class="line"><span class="cl">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
</span></span></code></pre></td></tr></table>
</div>
</div><p>克隆完成之后需要将<code>depot_tools</code>的路径加到<code>PATH</code>中，Linux 上添加环境变量最简单的方式是修改<code>~/.profile</code>，这种方式与你的登录 shell 是什么没有关系，不管是<code>fish</code>还是<code>bash</code>还是<code>zsh</code>都会吃这种方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># ~/.profile</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">GOOGLE_BIN</span><span class="o">=</span><span class="nv">$HOME</span>/google/depot_tools
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$GOOGLE_BIN</span>:<span class="nv">$PATH</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是这种方式需要你注销重新登录。</p>
<h2 id="克隆代码">克隆代码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir webrtc-checkout
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> webrtc-checkout
</span></span><span class="line"><span class="cl">fetch --nohooks webrtc
</span></span><span class="line"><span class="cl">gclient sync
</span></span></code></pre></td></tr></table>
</div>
</div><p>整个 WebRTC 的项目代码大小约 20G，克隆过程中需要保证网络畅通顺畅，如果你的梯子有大流量专用节点最好，否则可能克隆完你的流量就用光了。</p>
<p>克隆期间可能会因为网络问题中断，重新执行<code>gclient sync</code>即可，直到所有的模块都克隆完毕。</p>
<p>按照官方的建议，克隆完成之后创建自己的本地分支，因为官方分支更新很快，不 checkout 的话，可能你的 commit 还没写完，就被 Remote 的 change 给覆盖了，还要手动处理冲突。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> src
</span></span><span class="line"><span class="cl">git checkout master
</span></span><span class="line"><span class="cl">git new-branch &lt;branch-name&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="编译-webrtc">编译 WebRTC</h2>
<p>关于 WebRTC 的版本可以在<a href="https://chromiumdash.appspot.com/branches" target="_blank" rel="noopener noreffer">Chromium Dash</a>查到：</p>

<p>如上图所示，113 分支是当前的稳定分支，对应的 tag 是<code>branch-heads/5672</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> ~/google/webrtc-checkout/src
</span></span><span class="line"><span class="cl">git checkout branch-heads/5672
</span></span><span class="line"><span class="cl">git switch -c m113
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建本地分支之后就可以用<code>gn</code>生成<code>ninja</code>文件了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gn gen out/Default --root<span class="o">=</span><span class="s2">&#34;.&#34;</span> --args<span class="o">=</span><span class="s1">&#39;is_debug=true target_os=&#34;linux&#34; target_cpu=&#34;x64&#34; rtc_include_tests=false rtc_use_h264=true rtc_enable_protobuf=false is_clang=true symbol_level=0 enable_iterator_debugging=false is_component_build=false use_rtti=true rtc_use_x11=true use_custom_libcxx=false treat_warnings_as_errors=false use_ozone=true&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了<code>clang</code>并且启用了<code>h264</code>，详细的<code>gn</code>参数可以参考<a href="https://www.chromium.org/developers/gn-build-configuration/" target="_blank" rel="noopener noreffer">gn-build-configuration</a>和项目根目录下的<code>webrtc.gni</code>文件。</p>
<p>之后使用<code>autoninja</code>进行编译，编译时会吃满你 PC 的所有核心，编译时间取决于你 PC 的配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">autoninja -C out/Default
</span></span></code></pre></td></tr></table>
</div>
</div>
<p>可以看到默认生成了几个样例的可执行文件。</p>

<p>cd 到<code>obj</code>目录下可以看到<code>libwebrtc.a</code>文件，就是编译链接之后最终生成的可以引用的库文件。</p>
<h2 id="搭建开发环境">搭建开发环境</h2>
<p>Google 官方给出了 Chromium 项目的<a href="https://chromium.googlesource.com/chromium/src.git/&#43;/master/docs/clion.md#Building_Running_and-Debugging-within-CLion" target="_blank" rel="noopener noreffer">CLion 配置指南</a>，所以只需要照猫画虎给 WebRTC 配置一下。</p>
<h3 id="配置-clion-属性">配置 CLion 属性</h3>
<p>因为整个项目比较大，所以需要调大 CLion 的 VM 内存和 intellisence 支持的文件大小：</p>
<p><code>Help</code>-&gt; <code>Edit Custom VM Options</code>，在文件的末尾添加：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">-Xmx8g
</span></span></code></pre></td></tr></table>
</div>
</div><p>表示给 VM 设定<code>8G</code>的可用内存，这样基本上不用担心使用过程因为内存不足而 CLion 性能不够了。</p>
<p><code>Help</code>-&gt;<code>Edit Custom Properties</code>，在文件的末尾添加：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">idea.max.intellisense.filesize=12500
</span></span></code></pre></td></tr></table>
</div>
</div><p>表示为大小为<code>12500KB</code>也就是<code>12M</code>以下的文件提供 intellisense 支持。</p>
<h3 id="配置-gdb">配置 gdb</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim ~/.gdbinit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 添加下面一行</span>
</span></span><span class="line"><span class="cl"><span class="nb">source</span> ~/google/webrtc-checkout/src/tools/gdb/gdbinit
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后在 CLion 中的<code>Settings</code>-&gt;<code>Toolchain</code>-&gt;<code>Debugger</code>选择系统自带的 gdb：<code>/usr/bin/gdb</code>即可。</p>
<h3 id="配置-intellisense">配置 intellisense</h3>
<p>因为 WebRTC 用的是<code>gn</code>+<code>ninja</code>作为构建工具，而<code>CLion</code>目前只支持<code>cmake</code>，所以当要求配置<code>CMakeLists.txt</code>时直接无视即可。网络上有说用<code>gn_to_cmake.py</code>这个脚本的，但是我没看懂这东西的功能，反正是不能生成<code>CMakeLists.txt</code>，只是生成一个<code>json</code>文件，并不能用于 CLion 的索引。</p>
<p>我这边成功开启 IDE 语法高亮和索引的姿势是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plain" data-lang="plain"><span class="line"><span class="cl">cd webrtc-checkout/src
</span></span><span class="line"><span class="cl">python3 ./tools/clang/scripts/generate_compdb.py -p ./out/Default -o ./compile_commands.json --target_os=linux
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一步会生成 CLion 可以自动识别的<code>compile_commands.json</code>文件，从而可以正确索引项目的代码并提供代码补全功能。</p>

<p>之后每次启动项目 CLion 就会自动索引项目文件，就可以愉快地看代码和写代码啦！</p>
]]></description>
</item>
<item>
    <title>WebRTC 中关于视频自适应的相关设置</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/note-for-webrtc-1/</link>
    <pubDate>Thu, 15 Sep 2022 20:48:51 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/note-for-webrtc-1/</guid>
    <description><![CDATA[<h1 id="概况">概况</h1>
<p><code>WebRTC</code>提供了视频自适应机制，其目的主要是通过降低编码的视频的质量来减少带宽和 CPU 消耗。</p>
<p>视频自适应发生的情形：带宽或 CPU 资源发出信号表明自己未被充分使用或被过度使用时，进行视频自适应。过度使用则降低质量，否则提高质量。</p>
<p>视频自适应调整的对象：帧率与分辨率。</p>
<h1 id="资源">资源</h1>
<p><code>Resources</code>监测指标来自于系统或视频流。例如，一个资源可以监测系统温度或者视频流的带宽使用率。</p>
<p>资源实现了<code>Resource</code>接口：</p>
<ul>
<li>当资源检测到被过度使用则调用<code>SetUsageState(kOveruse)</code>；</li>
<li>当资源不再被过度使用则调用<code>SetUsageState(kUnderuse)</code>。</li>
</ul>
<p>对所有的视频而言，默认有两种类型的资源：</p>
<ul>
<li>质量标量资源</li>
<li>编码过度使用资源</li>
</ul>
<h2 id="qp-标量资源">QP 标量资源</h2>
<p>质量标量资源监测发送视频流中编码之后的帧的量化参数（QP），确保视频流的对于当前的分辨率而言可以接受。</p>
<p>每一帧被编码之后，<code>QualityScaler</code>就能获得相应的 QP。</p>
<p>过度使用或者未被充分使用的信号在平均 QP 脱离 QP 阈值之后发出。</p>
<p>QP 阈值在<code>EncoderInfo</code>中的<code>scaling_settings</code>属性中设置。</p>
<p>需要注意的是 QP 标量只在降级偏好设置为<code>MAINTAIN_FRAMERATE</code>或<code>BALANCED</code>时启用。</p>
<h2 id="编码使用资源">编码使用资源</h2>
<p>编码使用资源监测编码器需要花多长时间来编码一个视频帧，实际上这是 CPU 使用率的代理度量指标。</p>
<p>当平均编码使用超过了设定的阈值，就会触发过度使用的信号。</p>
<h2 id="插入其他资源">插入其他资源</h2>
<p>自定义的资源可以通过<code>Call::AddAdaptationResource</code>方法插入。</p>
<h1 id="自适应">自适应</h1>
<p>资源发出过度使用或未充分使用的信号之后，会发送给<code>ResourceAdaptationProcessor</code>，其从<code>VideoStreamAdapter</code>中请求<code>Adaptation</code>提案。这个提案基于视频的降级偏好设置。</p>
<p><code>ResourceAdaptationProcessor</code>基于获得的提案来确定是否需要执行当前的<code>Adaptation</code>。</p>
<h2 id="降级偏好设置">降级偏好设置</h2>
<p>有 3 种设置，在<code>RtpParameters</code>的头文件中定义：</p>
<ul>
<li><code>MAINTAIN_FRAMERATE</code>: 自适应分辨率</li>
<li><code>MAINTAIN_RESOLUTION</code>: 自适应帧率</li>
<li><code>BALANCED</code>: 自适应帧率或分辨率</li>
</ul>
<p>降级偏好设置在<code>RtpParameters</code>中的<code>degradation_perference</code>属性中设置。</p>
<h1 id="videosinkwants和视频流自适应"><code>VideoSinkWants</code>和视频流自适应</h1>
<p>自适应完成之后就会通知视频流，视频流就会转换自适应为<code>VideoSinkWants</code>。</p>
<p>这些接收器需求向视频流表明：在其被送去编码之前需要施加一些限制。</p>
<p>对于自适应而言需要被设置的属性为：</p>
<ul>
<li><code>target_pixel_count</code>: 对于每个视频帧要求的像素点总数，为了保持原始的长宽比，实际的像素数应该接近这个值，而不一定要精确相等，</li>
<li><code>max_pixel_count</code>: 每个视频帧中像素点的最大数量，不能被超过。</li>
<li><code>max_framerate_fps</code>: 视频的最大帧率，超过这个阈值的帧将会被丢弃。</li>
</ul>
<p><code>VideoSinkWants</code>可以被任何视频源应用，或者根据需要可以直接使用其基类<code>AdaptationVideoTraceSource</code>来执行自适应。</p>
]]></description>
</item>
</channel>
</rss>
