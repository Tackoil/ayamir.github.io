<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>WebRTC - 标签 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/tags/webrtc/</link>
        <description>WebRTC - 标签 - Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Thu, 15 Jun 2023 18:21:02 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/tags/webrtc/" rel="self" type="application/rss+xml" /><item>
    <title>远程桌面与WebRTC</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/remote-desktop-with-webrtc/</link>
    <pubDate>Thu, 15 Jun 2023 18:21:02 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/remote-desktop-with-webrtc/</guid>
    <description><![CDATA[<h1 id="关于远程桌面">关于远程桌面</h1>
<p>远程桌面是一种将一台计算机的桌面控制权限交给网络上另一台计算机的技术，两台计算机之间建立连接之后，可以进行音视频以及控制信令的相互传输，从而实现远程控制的功能。</p>
<h1 id="远程桌面技术的实现">远程桌面技术的实现</h1>
<p>基于远程桌面要完成的任务目标，其需要实现以下两个核心功能：</p>
<ol>
<li>音视频的传输，即需要让控制机收到受控机的音频跟视频。</li>
<li>控制信令的传输，即鼠标键盘的控制信号等</li>
</ol>
<p>目前主流的远程桌面技术主要有2种：</p>
<ol>
<li>基于<a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing" target="_blank" rel="noopener noreffer">VNC(Virtual Network Computing)</a>的远程桌面技术</li>
<li>基于<a href="https://en.wikipedia.org/wiki/Remote_Desktop_Protocol" target="_blank" rel="noopener noreffer">RDP(Remote Desktop Protocol)</a>的远程桌面技术</li>
</ol>
<h2 id="vnc">VNC</h2>
<p>VNC使用远程帧缓冲协议即(RFB, Remote FrameBuffer)来远程控制另一台计算机，将控制机的键盘和鼠标事件传输到被控制机，同时将被控制机的屏幕图像传输到控制机。</p>
<p>基于其技术原理，VNC有以下优点：</p>
<ol>
<li>跨平台，可以在不同的操作系统上运行，VNC技术本身也有多个客户端和服务端的实现版本，如RealVNC、TightVNC、UltraVNC等</li>
<li>开源，VNC的源代码及其很多现代衍生品都是在GNU许可证之下发布的</li>
<li>轻量级，VNC的客户端和服务端都是非常轻量级的程序，可以在低配置的计算机上运行</li>
</ol>
<p>但因为VNC本身的设计时间很早，因此在2023年的今天暴露出了很多的时代局限性：</p>
<ol>
<li>因为其基于像素方块的传输原理，就算是采用部分更新传输的方式，在大量像素变化的情况下会消耗大量的带宽。特别是对于现在的高分屏，其传输的数据量会更大。</li>
<li>VNC在设计之初被用于局域网内使用，因此没有考虑太多的安全性，虽然密码并不以明文发送，但是如果从网络中嗅探出加密密钥和编码之后的密码，也可能成功破解出密码。</li>
</ol>
<h2 id="rdp">RDP</h2>
<p>RDP是<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/remote/understanding-remote-desktop-protocol" target="_blank" rel="noopener noreffer">微软提出的一种专有协议</a>，扩展了T-120系列协议标准，最早专用于Windows系统的终端和服务器之间的远程桌面连接，之后微软也实现了<a href="https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-mac" target="_blank" rel="noopener noreffer">RDP的MacOS客户端</a>，现在也有很多第三方的实现版本实现了其功能的子集，为GNU/Linux做了适配如<a href="https://github.com/neutrinolabs/xrdp" target="_blank" rel="noopener noreffer">xrdp</a>。因此，可以说RDP也一定程度上具有跨平台的性质。</p>
<p>相比于VNC，RDP的实现原理还是比较复杂的：</p>
<p></p>
<p>首先，RDP的最底层是TCP，TCP之上是各层的协议和服务。</p>
<ul>
<li>TPKT：是TCP之上的ISO传输服务，允许两个组交换TPDU（传输协议数据单元）或PDU（协议数据单元）的信息单元。</li>
<li>X.224：连接传输协议，主要用于RDP初始连接请求和响应。</li>
<li>T.125 MCS：多点通信服务，允许RDP通过多个通道进行通信和管理。</li>
</ul>
<p>RDP的工作原理是通过TPKT实现信息单元的交换，通过X.224建立连接，使用T.125 MCS打开两个通道来完成两个设备之间的来回数据传输。</p>
<p>RDP的特点功能比较丰富，比如：</p>
<ul>
<li>支持共享剪切板。</li>
<li>支持多个显示器。</li>
<li>支持虚拟化GPU。</li>
<li>支持32位彩色和64000个独立的数据传输通道。</li>
<li>通过RC4对称加密算法使用128位密钥对数据进行加密。</li>
<li>可以在使用远程计算机时参考本地计算机上的文件系统。</li>
<li>远程计算机的应用程序可以在本地计算机上运行。</li>
</ul>
<p>当然，事物都有两面性，RDP拥有这么多强大功能，也有一些难以避免的缺点：</p>
<ul>
<li>网络速度较慢时，远程连接容易出现延迟。</li>
<li>两台计算机在不同的网络上时，其配置过程相当复杂。</li>
<li>固定使用3389端口监听，可能成为攻击的目标。</li>
<li>RDP整体上还是受到微软控制，定制性比较差。</li>
</ul>
<h1 id="webrtc和远程桌面">WebRTC和远程桌面</h1>
<p>远程桌面的核心需求和WebRTC的核心功能完美契合。</p>
<ul>
<li>WebRTC基于ICE/STUN/TURN的NAT穿透方案可以很方便地解决不同网络情况下主机连接的问题，</li>
<li>WebRTC基于SRTP的传输方式天然提供了实时特征、端到端的加密的数据传输服务。</li>
<li>WebRTC针对各种网络情况做了音视频传输的大量优化，可以保证各种网络条件下的可用性。</li>
<li>WebRTC本身其实是Chromium浏览器的一部分，天然具备跨平台的性质。</li>
<li>WebRTC完全开源，定制性极强，不少公司都基于WebRTC来做自家的直播、云游戏业务。</li>
</ul>
<p>整体上来讲，WebRTC的优势使其很适合用于远程桌面业务，当然，目前市面上已经有App基于WebRTC实现了远程桌面的功能，比如<a href="https://en.wikipedia.org/wiki/Chrome_Remote_Desktop" target="_blank" rel="noopener noreffer">Chrome Remote Desktop</a>和<a href="https://www.todesk.com/" target="_blank" rel="noopener noreffer">ToDesk</a>。前者可以理解为是Google用自己WebRTC推出的远程桌面服务，体验了一下，整体上功能比较少，但是连接比较稳定，不过受GFW影响，这玩意在国内应该是处于没法用的状态；后者则是国产远程桌面软件，目前已经比较成熟，提供了企业版、个人版、专业版和游戏版四个版本，从其官网上提供的信息来看，应该是做出了一定成绩。</p>
<p>从技术上讲，基于WebRTC开发远程桌面应用相当合理，开源可控，还有谷歌背书，WebRTC本身在不停地与时俱进，作为上层应用开发的远程桌面也可以及时享受到WebRTC带来的改进。</p>
<p>从业务上讲，WebRTC本身具有的功能可以解决上面所说的VNC和RDP的诸多问题，不过就功能的丰富性而言，可能跟微软的RDP还差一些，但是WebRTC基于音视频的解决方案本身可以优化的上限还是挺高的，毕竟随着人们需求的上升，高分辨率、高帧率也会成为未来远程桌面应用必不可少的功能需求。</p>
<p>本篇博客从非技术层面探讨了远程桌面技术的当下两大主流技术，以及WebRTC应用于远程桌面业务下的可行性。下篇博客将从技术层面详细分析WebRTC与远程桌面业务的契合程度及可能的解决方案，就先从核心功能开始吧！</p>
]]></description>
</item>
<item>
    <title>在Linux下如何搭建WebRTC的开发环境</title>
    <link>https://ayamir.github.io/posts/development/webrtc-development-prepare/</link>
    <pubDate>Sun, 23 Apr 2023 21:28:38 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/development/webrtc-development-prepare/</guid>
    <description><![CDATA[<p>本文主要记录笔者在 Gentoo Linux 下面搭建 WebRTC 开发环境的过程。</p>
<h2 id="准备工作">准备工作</h2>
<ol>
<li>网络：可以科学上网的梯子</li>
<li>IDE：VSCode 或者 CLion</li>
</ol>
<h2 id="安装depot_tools">安装<code>depot_tools</code></h2>
<p>Google 有自己的一套用于管理 Chromium 项目的工具，名叫<code>depot_tools</code>，其中有包括<code>git</code>在内的一系列工具和脚本。</p>

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建google目录用于存储google相关的代码</span>
</span></span><span class="line"><span class="cl">mkdir ~/google
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> ~/google
</span></span><span class="line"><span class="cl"><span class="c1"># clone depot_tools</span>
</span></span><span class="line"><span class="cl">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
</span></span></code></pre></td></tr></table>
</div>
</div><p>克隆完成之后需要将<code>depot_tools</code>的路径加到<code>PATH</code>中，Linux 上添加环境变量最简单的方式是修改<code>~/.profile</code>，这种方式与你的登录 shell 是什么没有关系，不管是<code>fish</code>还是<code>bash</code>还是<code>zsh</code>都会吃这种方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># ~/.profile</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">GOOGLE_BIN</span><span class="o">=</span><span class="nv">$HOME</span>/google/depot_tools
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$GOOGLE_BIN</span>:<span class="nv">$PATH</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是这种方式需要你注销重新登录。</p>
<h2 id="克隆代码">克隆代码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir webrtc-checkout
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> webrtc-checkout
</span></span><span class="line"><span class="cl">fetch --nohooks webrtc
</span></span><span class="line"><span class="cl">gclient sync
</span></span></code></pre></td></tr></table>
</div>
</div><p>整个 WebRTC 的项目代码大小约 20G，克隆过程中需要保证网络畅通顺畅，如果你的梯子有大流量专用节点最好，否则可能克隆完你的流量就用光了。</p>
<p>克隆期间可能会因为网络问题中断，重新执行<code>gclient sync</code>即可，直到所有的模块都克隆完毕。</p>
<p>按照官方的建议，克隆完成之后创建自己的本地分支，因为官方分支更新很快，不 checkout 的话，可能你的 commit 还没写完，就被 Remote 的 change 给覆盖了，还要手动处理冲突。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> src
</span></span><span class="line"><span class="cl">git checkout master
</span></span><span class="line"><span class="cl">git new-branch &lt;branch-name&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="编译-webrtc">编译 WebRTC</h2>
<p>关于 WebRTC 的版本可以在<a href="https://chromiumdash.appspot.com/branches" target="_blank" rel="noopener noreffer">Chromium Dash</a>查到：</p>

<p>如上图所示，113 分支是当前的稳定分支，对应的 tag 是<code>branch-heads/5672</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">cd</span> ~/google/webrtc-checkout/src
</span></span><span class="line"><span class="cl">git checkout branch-heads/5672
</span></span><span class="line"><span class="cl">git switch -c m113
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建本地分支之后就可以用<code>gn</code>生成<code>ninja</code>文件了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gn gen out/Default --root<span class="o">=</span><span class="s2">&#34;.&#34;</span> --args<span class="o">=</span><span class="s1">&#39;is_debug=true target_os=&#34;linux&#34; target_cpu=&#34;x64&#34; rtc_include_tests=false rtc_use_h264=true rtc_enable_protobuf=false is_clang=true symbol_level=0 enable_iterator_debugging=false is_component_build=false use_rtti=true rtc_use_x11=true use_custom_libcxx=false treat_warnings_as_errors=false use_ozone=true&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用了<code>clang</code>并且启用了<code>h264</code>，详细的<code>gn</code>参数可以参考<a href="https://www.chromium.org/developers/gn-build-configuration/" target="_blank" rel="noopener noreffer">gn-build-configuration</a>和项目根目录下的<code>webrtc.gni</code>文件。</p>
<p>之后使用<code>autoninja</code>进行编译，编译时会吃满你 PC 的所有核心，编译时间取决于你 PC 的配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">autoninja -C out/Default
</span></span></code></pre></td></tr></table>
</div>
</div>
<p>可以看到默认生成了几个样例的可执行文件。</p>

<p>cd 到<code>obj</code>目录下可以看到<code>libwebrtc.a</code>文件，就是编译链接之后最终生成的可以引用的库文件。</p>
<h2 id="搭建开发环境">搭建开发环境</h2>
<p>Google 官方给出了 Chromium 项目的<a href="https://chromium.googlesource.com/chromium/src.git/&#43;/master/docs/clion.md#Building_Running_and-Debugging-within-CLion" target="_blank" rel="noopener noreffer">CLion 配置指南</a>，所以只需要照猫画虎给 WebRTC 配置一下。</p>
<h3 id="配置-clion-属性">配置 CLion 属性</h3>
<p>因为整个项目比较大，所以需要调大 CLion 的 VM 内存和 intellisence 支持的文件大小：</p>
<p><code>Help</code>-&gt; <code>Edit Custom VM Options</code>，在文件的末尾添加：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-Xmx8g
</span></span></code></pre></td></tr></table>
</div>
</div><p>表示给 VM 设定<code>8G</code>的可用内存，这样基本上不用担心使用过程因为内存不足而 CLion 性能不够了。</p>
<p><code>Help</code>-&gt;<code>Edit Custom Properties</code>，在文件的末尾添加：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">idea.max.intellisense.filesize=12500
</span></span></code></pre></td></tr></table>
</div>
</div><p>表示为大小为<code>12500KB</code>也就是<code>12M</code>以下的文件提供 intellisense 支持。</p>
<h3 id="配置-gdb">配置 gdb</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">vim ~/.gdbinit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 添加下面一行</span>
</span></span><span class="line"><span class="cl"><span class="nb">source</span> ~/google/webrtc-checkout/src/tools/gdb/gdbinit
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后在 CLion 中的<code>Settings</code>-&gt;<code>Toolchain</code>-&gt;<code>Debugger</code>选择系统自带的 gdb：<code>/usr/bin/gdb</code>即可。</p>
<h3 id="配置-intellisense">配置 intellisense</h3>
<p>因为 WebRTC 用的是<code>gn</code>+<code>ninja</code>作为构建工具，而<code>CLion</code>目前只支持<code>cmake</code>，所以当要求配置<code>CMakeLists.txt</code>时直接无视即可。网络上有说用<code>gn_to_cmake.py</code>这个脚本的，但是我没看懂这东西的功能，反正是不能生成<code>CMakeLists.txt</code>，只是生成一个<code>json</code>文件，并不能用于 CLion 的索引。</p>
<p>我这边成功开启 IDE 语法高亮和索引的姿势是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">cd</span> <span class="n">webrtc</span><span class="o">-</span><span class="n">checkout</span><span class="o">/</span><span class="n">src</span>
</span></span><span class="line"><span class="cl"><span class="n">python3</span> <span class="o">./</span><span class="n">tools</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">scripts</span><span class="o">/</span><span class="n">generate_compdb</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">p</span> <span class="o">./</span><span class="n">out</span><span class="o">/</span><span class="n">Default</span> <span class="o">-</span><span class="n">o</span> <span class="o">./</span><span class="n">compile_commands</span><span class="o">.</span><span class="n">json</span> <span class="o">--</span><span class="n">target_os</span><span class="o">=</span><span class="n">linux</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一步会生成 CLion 可以自动识别的<code>compile_commands.json</code>文件，从而可以正确索引项目的代码并提供代码补全功能。</p>

<p>之后每次启动项目 CLion 就会自动索引项目文件，就可以愉快地看代码和写代码啦！</p>
]]></description>
</item>
<item>
    <title>WebRTC 中关于视频自适应的相关设置</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/note-for-webrtc-1/</link>
    <pubDate>Thu, 15 Sep 2022 20:48:51 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/note-for-webrtc-1/</guid>
    <description><![CDATA[<h1 id="概况">概况</h1>
<p><code>WebRTC</code>提供了视频自适应机制，其目的主要是通过降低编码的视频的质量来减少带宽和 CPU 消耗。</p>
<p>视频自适应发生的情形：带宽或 CPU 资源发出信号表明自己未被充分使用或被过度使用时，进行视频自适应。过度使用则降低质量，否则提高质量。</p>
<p>视频自适应调整的对象：帧率与分辨率。</p>
<h1 id="资源">资源</h1>
<p><code>Resources</code>监测指标来自于系统或视频流。例如，一个资源可以监测系统温度或者视频流的带宽使用率。</p>
<p>资源实现了<code>Resource</code>接口：</p>
<ul>
<li>当资源检测到被过度使用则调用<code>SetUsageState(kOveruse)</code>；</li>
<li>当资源不再被过度使用则调用<code>SetUsageState(kUnderuse)</code>。</li>
</ul>
<p>对所有的视频而言，默认有两种类型的资源：</p>
<ul>
<li>质量标量资源</li>
<li>编码过度使用资源</li>
</ul>
<h2 id="qp-标量资源">QP 标量资源</h2>
<p>质量标量资源监测发送视频流中编码之后的帧的量化参数（QP），确保视频流的对于当前的分辨率而言可以接受。</p>
<p>每一帧被编码之后，<code>QualityScaler</code>就能获得相应的 QP。</p>
<p>过度使用或者未被充分使用的信号在平均 QP 脱离 QP 阈值之后发出。</p>
<p>QP 阈值在<code>EncoderInfo</code>中的<code>scaling_settings</code>属性中设置。</p>
<p>需要注意的是 QP 标量只在降级偏好设置为<code>MAINTAIN_FRAMERATE</code>或<code>BALANCED</code>时启用。</p>
<h2 id="编码使用资源">编码使用资源</h2>
<p>编码使用资源监测编码器需要花多长时间来编码一个视频帧，实际上这是 CPU 使用率的代理度量指标。</p>
<p>当平均编码使用超过了设定的阈值，就会触发过度使用的信号。</p>
<h2 id="插入其他资源">插入其他资源</h2>
<p>自定义的资源可以通过<code>Call::AddAdaptationResource</code>方法插入。</p>
<h1 id="自适应">自适应</h1>
<p>资源发出过度使用或未充分使用的信号之后，会发送给<code>ResourceAdaptationProcessor</code>，其从<code>VideoStreamAdapter</code>中请求<code>Adaptation</code>提案。这个提案基于视频的降级偏好设置。</p>
<p><code>ResourceAdaptationProcessor</code>基于获得的提案来确定是否需要执行当前的<code>Adaptation</code>。</p>
<h2 id="降级偏好设置">降级偏好设置</h2>
<p>有 3 种设置，在<code>RtpParameters</code>的头文件中定义：</p>
<ul>
<li><code>MAINTAIN_FRAMERATE</code>: 自适应分辨率</li>
<li><code>MAINTAIN_RESOLUTION</code>: 自适应帧率</li>
<li><code>BALANCED</code>: 自适应帧率或分辨率</li>
</ul>
<p>降级偏好设置在<code>RtpParameters</code>中的<code>degradation_perference</code>属性中设置。</p>
<h1 id="videosinkwants和视频流自适应"><code>VideoSinkWants</code>和视频流自适应</h1>
<p>自适应完成之后就会通知视频流，视频流就会转换自适应为<code>VideoSinkWants</code>。</p>
<p>这些接收器需求向视频流表明：在其被送去编码之前需要施加一些限制。</p>
<p>对于自适应而言需要被设置的属性为：</p>
<ul>
<li><code>target_pixel_count</code>: 对于每个视频帧要求的像素点总数，为了保持原始的长宽比，实际的像素数应该接近这个值，而不一定要精确相等，</li>
<li><code>max_pixel_count</code>: 每个视频帧中像素点的最大数量，不能被超过。</li>
<li><code>max_framerate_fps</code>: 视频的最大帧率，超过这个阈值的帧将会被丢弃。</li>
</ul>
<p><code>VideoSinkWants</code>可以被任何视频源应用，或者根据需要可以直接使用其基类<code>AdaptationVideoTraceSource</code>来执行自适应。</p>
]]></description>
</item>
</channel>
</rss>
