<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Ayamir&#39;s Blog</title>
        <link>http://localhost:1313/</link>
        <description>Welcome to Ayamir&#39;s blog.</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Sat, 13 Apr 2024 23:39:22 &#43;0800</lastBuildDate>
            <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>同步、异步、阻塞、非阻塞</title>
    <link>http://localhost:1313/posts/knowledge/os/sync-async-block-nonblock/</link>
    <pubDate>Sat, 13 Apr 2024 23:39:22 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/os/sync-async-block-nonblock/</guid>
    <description><![CDATA[<h2 id="概念">概念</h2>
<p>同步和异步、阻塞和非阻塞这两组概念经常出现，并且人们往往会有如下认知：</p>
<ul>
<li>
<p>同步就是程序发出同步调用之后就需要等待调用返回一个结果，然后才能继续指令的执行流。</p>
</li>
<li>
<p>异步就是程序发出异步调用之后能直接得到返回，程序可以继续执行，至于调用发起者想要得到的结果会在未来的某个时刻获取。</p>
</li>
<li>
<p>阻塞就是在调用结果返回之前，当前线程会被挂起。</p>
</li>
<li>
<p>非阻塞就是再不能立刻得到结果之前，当前线程并不会被挂起。</p>
</li>
</ul>
<p>那么这样来看的话，同步调用就是阻塞调用，异步调用就是非阻塞调用，这个认知是有些狭隘的。</p>
<h2 id="同步和异步">同步和异步</h2>
<p>同步和异步主要 focus 的是调用者和被调用者双方消息通信的机制。</p>
<p>同步是调用者等待被调用者返回结果，异步则是调用被直接返回，调用者不会等待被调用者。</p>
<p>以例子来说明的话就是：假如你打开了崩铁想玩，但是却发现需要下载更新客户端：</p>
<ul>
<li>
<p>如果采用同步的方式就是你一直等着下载安装完成，期间什么都不做。</p>
</li>
<li>
<p>不过我相信正常人都不会在这个过程中干等着什么都不做，而是会在点击下载按钮之后玩会儿手机或者干点别的事，这就是异步的方式。</p>
</li>
</ul>
<p>在这个例子中我们可以发现：</p>
<ul>
<li>
<p>如果采用同步的方式，我们一定能在更新完成之后的第一时间立刻玩到游戏，但是在苦苦等待的过程中我们的时间被浪费掉了。</p>
</li>
<li>
<p>如果采用异步的方式，我们在等游戏更新完成的过程中做了其他事情，时间没有被浪费掉，但是我们需要一种机制来知道什么时候游戏就更新好了。假如在下载过程中我们去做了别的事情，那么就可能不会第一时间知道它什么时候更新完成。</p>
</li>
</ul>
<p>如果把我们自己比作 CPU 的话，并且假设目前 OS 上面只有这一个任务，同步的方式会浪费 CPU 时间，而采用异步的方式可以让我们多做一些别的事情，不过异步需要一些消息通知的方式来告诉我们等待的任务什么时候会有结果。假如崩铁下载器在下载完成之后没法通知我们，那么我们可能需要隔一段时间检查一下有没有更新完成。</p>
<p>这么看来，其实同步就是 OS/函数调用 默认支持的通信方式（无非就是等呗），而异步虽然可以解决同步会浪费时间的问题，但是需要引入 消息通知（下载器窗口变成启动游戏的窗口，并且置于最前）/注册回调函数（假如可以派个人替我玩的话）/轮询（隔几分钟看看有没有更新完）这些机制才能保证完成任务。</p>
<p>从线程/协程的角度来看同步和异步的话，其实同步就是完完全全的单线程模式，而异步可以利用协程的特性在单线程中完成异步任务，从而避免大量使用回调函数带来的“回调地狱”。</p>
<p>以实际的例子来说明，在使用 neovim 写代码的时候会使用代码格式化的功能，默认的代码格式化的同步完成的，也就是说我们需要等格式化完成才能执行别的任务（从阻塞的角度看就是，neovim 被格式化的过程阻塞了，这种方式就是同步且阻塞的方式）。在文件很小的时候，因为格式化很快所以以同步的方式进行格式化并不会有太多的影响。但是如果需要进行大文件的格式化，同步的方式会阻塞很久，严重影响体验。从更高的角度来看，格式化器影响的主要是代码的位置（可能也会影响代码的内容例如 <code>goimports</code> ），那么理论上我们不进行与代码内容和代码位置相关的写入操作就不会造成写冲突。但是这种同步的方式就是一种一刀切，使我们只能等格式化完成，这其实不太合理。</p>
<p>为什么说这个例子可以用协程的方式实现异步呢？其实原理就是局部性 + 协程特性。因为我们在写代码的时候通常只是会编辑一处的内容，如果我们下达了对整个大文件的格式化操作，那么理论上是可以按照不同的小部分（比如一个函数）来完成格式化过程的，而在完成格式化一个函数的过程中，CPU 的执行权可以交给格式化器，而在用户需要进行一些别的操作的时候，格式化协程可以挂起(yield)并将 CPU 让给用户操作的协程，而当用户的操作完成之后，格式化协程可以恢复(resume)并获取 CPU 继续执行。这样来看，通过对任务的分割和对协程的交替切换，就实现了异步的机制。</p>
<h2 id="阻塞和非阻塞">阻塞和非阻塞</h2>
<p>阻塞和非阻塞主要 focus 的是调用者在等待调用结果时候的状态。</p>
<p>还是以上面的例子来说：</p>
<ul>
<li>
<p>阻塞描述的是我们在等待游戏更新完毕的过程中，处于什么都干不了的状态（我只想玩崩铁，我啥都不想干！），</p>
</li>
<li>
<p>非阻塞描述的是在游戏更新的时候，我们可以干点别的，比如看一集《葬送的芙莉莲》（这个时间正好能多看一集番，美滋滋~）。</p>
</li>
</ul>
<p>对于实际的编程场景而言，阻塞和非阻塞这组概念常常在 Socket 编程中出现，我们可以利用 <code>fcntl</code> 把 socket 置为阻塞或者非阻塞的状态（默认是非阻塞）</p>
<p>对于 TCP 而言，其对应的发送和接收的 API 是 <code>send</code>/<code>recv</code>，而 <code>send</code>/<code>recv</code> 其实并不是真的直接向网络上发数据/直接从网络上接收数据，而是将数据写入到内核发送缓冲区/从内核接收缓冲区读取数据。</p>
<p>如果发送端一直往发送缓冲区写数据而接收端不读数据的话（其实就是流量的滑动窗口不滑动了），当缓冲区满了之后：</p>
<ul>
<li>
<p>如果 socket 是阻塞模式，继续调用 <code>send</code> 会将程序阻塞在 <code>send</code> 处，不会执行之后的逻辑。</p>
</li>
<li>
<p>如果 socket 是非阻塞模式，继续调用 <code>send</code> 会直接返回错误，然后执行之后的逻辑（通常使用非阻塞模式我们会获取 <code>send</code> 调用的返回值并在循环中判断）。</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>其实总的来看，在实际的编码过程中我们没必要严格区分这两种概念，因为它们之间的区别并不是左与右，正与负这种关系。概念还是需要与实际的例子相结合才有相辅相成的意义。</p>
]]></description>
</item>
<item>
    <title>进程、线程和协程</title>
    <link>http://localhost:1313/posts/knowledge/os/process-and-thread/</link>
    <pubDate>Sat, 06 Apr 2024 19:23:04 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/os/process-and-thread/</guid>
    <description><![CDATA[<h2 id="进程">进程</h2>
<h3 id="是什么">是什么</h3>
<p>学操作系统课的时候学过一句话叫做：进程是操作系统资源分配的最小单位，进程的资源直接由 OS 分配，并存储在进程控制块 PCB 中：</p>
<ul>
<li>进程标识符 PID</li>
<li>进程状态：就绪、运行、阻塞</li>
<li>内存资源：
<ul>
<li>代码段、数据段、堆和栈</li>
</ul>
</li>
<li>文件描述符 fd ：
<ul>
<li>stdin、stdout、stderr、以及进程打开的文件描述符列表比如本地文件以及网络连接等的 fd</li>
</ul>
</li>
<li>寄存器：
<ul>
<li>PC、SP、还有其他的通用寄存器</li>
</ul>
</li>
<li>进程控制信息：
<ul>
<li>父进程 ID ，子进程 ID ，以及信号处理器这些</li>
</ul>
</li>
</ul>
<h3 id="有什么用">有什么用</h3>
<p>在拿进程和程序做对比的时候我们知道，进程就是运行着的程序（这里的运行指的是程序被加载到内存空间中然后开始按照程序指令执行，而不是指进程状态中的运行状态），受 OS 的调度，可以说我们写程序的目的就是要让 CPU 可以按照磁盘上的代码指令来执行操作，进程就是实现这一目的的过程。</p>
<p>因为 OS 使用了虚拟内存这一概念，使得每个进程都认为自己是独占 OS 的，所以一个进程是不知道其他进程的存在的。因而如果面对需要多个进程协作完成一项任务的时候（其实这种情况的描述从逻辑上应该是自上到下的，先有的是一项任务，我们通过分析发现这两个任务需要写多个程序来完成），就会不可避免地引入进程间通信 IPC 。</p>
<p>常用的进程间通信手段大概有 6 种：消息队列、共享内存、匿名管道、命名管道、信号量、Socket，这几种方式根据需求的不同都有自己的用武之地，不过我个人最习惯用的还是 Socket ，因为它具有最优的可扩展性（跨主机、跨语言），可记录性（可以使用 tcpdump/wireshark 抓包），也完美符合我对于通信这一名词想象（明确的通信双方、全双工的信道）。</p>
<p>从我的实际项目经历中来看，我的 Unity 客户端实例需要把游戏运行过程中产生的 2D 轨迹数据输入给 Python 端的 AI 模型，并获取模型输出。对于这一场景，我的首选就是 Socket 通信，首先是因为 Socket 具备全双工的特性可以满足需求，其次是使用 Socket 可以在 AI 模型部署到其他主机上的时候也能正常运行。</p>
<h2 id="线程">线程</h2>
<h3 id="是什么-1">是什么</h3>
<p>上面说到进程是 OS 资源分配的最小单位，这句话的下半句是：线程是操作系统调度的最小单位，这句话其实暗示了，线程和进程的概念对于单线程的进程而言是相同的。</p>
<p>OS 在调度 CPU 的时候是以线程为单位的，也就说明线程其实也是一种 OS 级别的概念。对于 Linux 而言，线程和进程使用的是相同的数据结构 <code>task_struct</code> 来表示的，不过进程的创建使用的是 <code>fork()</code> 这一系统调用，而线程的创建用的是 <code>clone()</code> 这一系统调用。</p>
<p>结合前半句话，说明 OS 在分配资源的时候分配不到线程这个层面上（单线程进程是特例），对于同一个进程的多个线程，他们之间共享进程的代码段、数据段和 fd 这些，不过每个线程都拥有自己独立的堆、栈空间。</p>
<h3 id="有什么用-1">有什么用</h3>
<p>因为每个进程都会拥有上面列出的这些资源，直接受到 OS 的控制，所以进程的创建和销毁不可避免地会涉及到相对比较大的时间开销。</p>
<p>相比之下，线程因为可以直接继承并共享进程的部分资源，所以线程的创建和销毁要更加轻量。</p>
<p>也正因如此，同一进程之间的多个线程之间只需要使用一些编程上的技法就可以完成通信，常用的就是各种锁、条件变量以及阻塞队列。</p>
<h3 id="什么时候用多线程">什么时候用多线程</h3>
<p>首先需要考虑的是能不能使用多线程。多线程的执行过程是 OS 调度 CPU 的多个核心来分别执行多个线程的过程，因而最适合使用多线程的任务一定具备：划分给各个线程之间的任务没有重叠、也无需通信（或者说没有依赖关系）的特性，每个任务都是 Compute-Intensive 的。</p>
<p>从我的实际项目经历中来看，在把 GPU 显存中的 yuv 图像数据回读到内存中的时候，图像的不同部分之间是相互独立的，因而这个过程天然适合使用多线程来完成，主线程只需要等待多个线程读完数据之后执行下一步操作即可。</p>
<p>其次需要考虑的是多线程能带来多大的收益。单线程和多线程的区别其实就是可以占有并利用的 CPU 核心数的区别，因此当任务的瓶颈不在于 CPU 的时候就需要考虑是否有使用多线程的必要。根据 Amdahl&rsquo;s law ，$S(n)=\frac{1}{(1-P)+\frac{P}{n}}$，当处理单元数趋向于无穷的时候，并行化所带来的加速比 $S(n)$ 将趋近于 $\frac{1}{1-P}$​ 。如果任务中可并行的部分比较小的情况下，可能就没有并行化的必要了。</p>
<p></p>
<h3 id="怎么用多线程">怎么用多线程</h3>
<p>默认的多线程使用方式就是在需要多线程执行任务的时候创建线程，在任务执行完毕之后销毁线程（就是直接交给 OS 来进行线程的创建和销毁）。</p>
<p>而实际上，我们常用的是线程池的方式，也就是在任务开始的时候我们就创建多个线程并且保存在一个线程池中，通过任务队列的形式确定将那个任务分配给哪个线程。这样做的方式其实就是把对线程的控制权从 OS 转移到程序员，避免了重复的线程创建和销毁带来的开销。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">)</span> <span class="o">:</span> <span class="n">stop</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">workers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">queueMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">condition</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">stop</span> <span class="o">||</span> <span class="o">!</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">              <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">tasks</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">queueMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tasks</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">condition</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">queueMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">stop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">condition</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="o">&amp;</span><span class="nl">worker</span> <span class="p">:</span> <span class="n">workers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">worker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">workers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">tasks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">queueMutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">condition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">stop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 示例任务函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">printHello</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello from thread &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span> <span class="n">pool</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 创建线程池，包含4个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 向线程池添加任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span> <span class="n">printHello</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="协程">协程</h2>
<h3 id="是什么-2">是什么</h3>
<p>协程这一概念可以理解为“函数plus”，普通的函数只有两种行为：调用(Invoke)和返回(Return)。协程比函数多了一种行为：挂起(Suspend/Yield)。</p>
<p>在只使用函数的情况下，程序的执行流可以只用一个栈就能模拟（调用函数时 push ，函数返回时 pop ），而引入协程之后，因为其具有挂起这一行为，所以需要额外的空间（比如堆）来暂存协程的上下文。</p>
<h3 id="有什么用-2">有什么用</h3>
<p>协程的作用可以用一句话来描述，即：协程就是用单线程的方式完成并发的任务逻辑。</p>
<p>协程其实与进程和线程没有太近的“亲缘关系”，只是在作用上有着相近的效果，即宏观上看是并发执行的。以经典的生产者-消费者任务为例：</p>
<ul>
<li>多进程/多线程：至少需要一个生产者进程/线程，消费者进程/线程，两者之间可能需要使用一个单向管道作为数据缓冲区来提高性能（或者说控制管道大小来实现不同的任务逻辑）。</li>
<li>协程：只需要一个线程，通过两个分别负责生产和消费的协程来完成，即：生产者协程生产一定数量之后挂起，并调用消费者协程。消费者协程消费完之后挂起，并调用生产者协程，如此交替往复进行。</li>
</ul>
<p>协程相比于上面提到的进程和线程，区别在于协程是运行在用户态的，或者说协程的控制权是掌握在程序员手中的，由程序员负责控制在什么时候把 CPU 的使用权交给哪个协程。</p>
<h3 id="什么时候用协程">什么时候用协程</h3>
<p>协程的使用情形其实很简单，即：你需要在只利用一个 CPU 核心的情况下完成并发任务的时候就是使用协程的时候。所以其实协程这个概念诞生的很早（1960年 Melvin Conway 解决COBOL 编译器的问题，使用协程技术只需要遍历一遍源代码）</p>
<h3 id="怎么用">怎么用</h3>
<p>目前 C++ 的协程只是在 C++20 中提供了机制，标准库的实现可能会在下一个版本 C++23 中提供。</p>
<p>Go 中的 Goroutine 其实并不受程序员调度，其挂起行为由 Go runtime 调度。</p>
]]></description>
</item>
<item>
    <title>什么是 RPC ？</title>
    <link>http://localhost:1313/posts/knowledge/backend/what-is-rpc/</link>
    <pubDate>Fri, 29 Mar 2024 23:55:25 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/backend/what-is-rpc/</guid>
    <description><![CDATA[<h2 id="是什么">是什么</h2>
<p>RPC 全名即 Remote Procedure Call：远程过程调用，本质上是一种设计/概念，它允许在一台机器上的 Client 调用运行在另一台机器上的 Server 上的程序接口。</p>
<h2 id="为什么">为什么</h2>
<p>RPC 的出现主要是为了满足现实世界中多机集群的业务分离， Client 端的业务和 Server 端的业务相互分离，目的是更强的性能、可扩展性和可维护性。</p>
<p>RPC 在我看来就是传统的前后端 http RESTful 框架的更加 general 的版本，两者在思想上是一致的，只不过 RESTful 框架是把现实业务中的 <strong>前端的显示</strong> 和 <strong>后端的数据处理</strong> 进行分离，而 RPC 则是更为通用的一种考虑，只要项目的设计者认为某个功能使用 RPC 进行分离会带来如性能、可靠性、可维护性等非功能特性上的收益，那其实就可以引入 RPC 。RPC 能完成的功能性需求不使用 RPC 一般来说也能实现，RPC 的收益主要体现在非功能性需求上。</p>
<h2 id="怎么做">怎么做</h2>
<p>RPC 的核心是面向接口编程的思想，Server 端和 Client 端可以通过定义好语言无关的接口（函数签名），双方的过程调用就可以像调用同一文件中的不同函数一样进行。</p>
<p>既然涉及到了不同主机，那么不可避免地会引入网络通信，而网络通信的本质其实就是需要规定好：消息如何编解码（或者说如何序列化和反序列化）、消息如何通过网络传输。</p>
<p>因而 RPC 在实现上主要需要考虑两部分，第一个部分是<strong>通信协议</strong>，第二部分是<strong>编码协议</strong>，</p>
<ul>
<li>通信协议：HTTP/TCP/UDP</li>
<li>编码协议：xml/json/protobuf</li>
</ul>
<p>目前主流的 RPC 框架在编码协议上基本上都使用 protobuf ，因为 protobuf 作为一种二进制数据可以带来比 xml/json 这种文本数据更高的压缩效率（当然，更加重要的前提条件是 RPC 传输的消息其实不太需要跟人打交道，也就无需可读性）。</p>
<p>对于通信协议，不同的 RPC 框架可能根据自己的用途有着不同的选择，比如 gRPC 使用的是 HTTP/2，而 tRPC 则根据不同的传输形式（unary和stream）设计了不同的自定义的协议格式。</p>
<h2 id="实际操作">实际操作</h2>
<p>以 tRPC 的 helloworld 为例，首先需要做的是写 IDL(Interface Defined Language) ，也就是前面提到的 <code>proto</code> 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">Greeter</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Hello</span> <span class="p">(</span><span class="n">HelloRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">HelloReply</span><span class="p">)</span> <span class="p">{}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">HelloRequest</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">HelloReply</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里首先定义了一个名为 <code>Greeter</code> 的服务，服务包含一个名为 <code>Hello</code> 的函数，其入参为 <code>HelloRequest</code> ，出参为 <code>HelloReply</code>。</p>
<p>后面则定义了 <code>HelloRequest</code> 和 <code>HelloReply</code> 这两种消息的格式，需要注意的是这里的 <code>string msg = 1</code> 并不是将 <code>msg</code> 初始化为 1 的意思（当然，<code>string</code> 类型的数据就算要初始化也应该是 <code>&quot;1&quot;</code> 而不是 <code>1</code>），而是说 <code>msg</code> 这个成员是 <code>HelloReply</code> 和 <code>HelloRequest</code> 的第 <code>1</code> 个成员。</p>
<p>之后可以使用 tRPC 的命令行工具或者是 <code>Makefile</code> 来生成相应的桩代码，供实现实现逻辑的客户端和服务端代码进行调用。</p>
<p>这里体现的其实就是前面所说的，RPC 只是一种对原本功能的一种分离，通过 IDL 确定好 C-S 之间的接口之后，C-S 都只需要调用协商好的接口，而原来的业务逻辑该怎么实现就怎么实现。</p>
]]></description>
</item>
<item>
    <title>WebRTC任务队列学习笔记</title>
    <link>http://localhost:1313/posts/development/webrtc-task-queue/</link>
    <pubDate>Tue, 19 Mar 2024 19:32:57 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/development/webrtc-task-queue/</guid>
    <description><![CDATA[<h2 id="taskqueue">TaskQueue</h2>
<p><code>TaskQueue</code>也即任务队列，不过这个类本身并没有与队列相关的任何代码，所以它是用来干什么的呢？</p>
<p>我们直接来读代码（为了方便，我这里直接把方法的实现代码贴了出来）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RTC_LOCKABLE</span> <span class="n">RTC_EXPORT</span> <span class="n">TaskQueue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TaskQueue priority levels. On some platforms these will map to thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// priorities, on others such as Mac and iOS, GCD queue priorities.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">Priority</span> <span class="o">=</span> <span class="o">::</span><span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueFactory</span><span class="o">::</span><span class="n">Priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">TaskQueue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueBase</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueDeleter</span><span class="o">&gt;</span> <span class="n">task_queue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">impl_</span><span class="p">(</span><span class="n">task_queue</span><span class="p">.</span><span class="n">release</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">TaskQueue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">Delete</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Used for DCHECKing the current queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">IsCurrent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">IsCurrent</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns non-owning pointer to the task queue implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">Get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">impl_</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(tommi): For better debuggability, implement RTC_FROM_HERE.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Ownership of the task is passed to PostTask.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">PostTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">PostTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Schedules a task to execute a specified number of milliseconds from when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the call is made. The precision should be considered as &#34;best effort&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and in some cases, such as on Windows when all high precision timers have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// been used up, can be off by as much as 15 millseconds (although 8 would be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// more likely). This can be mitigated by limiting the use of delayed tasks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">PostDelayedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">uint32_t</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">PostDelayedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">milliseconds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// std::enable_if is used here to make sure that calls to PostTask() with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// std::unique_ptr&lt;SomeClassDerivedFromQueuedTask&gt; would not end up being
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// caught by this template.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">PostTask</span><span class="p">(</span><span class="n">Closure</span><span class="o">&amp;&amp;</span> <span class="n">closure</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PostTask</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">ToQueuedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">&gt;</span><span class="p">(</span><span class="n">closure</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// See documentation above for performance expectations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">Closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">webrtc</span><span class="o">::</span><span class="n">QueuedTask</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="k">nullptr</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">PostDelayedTask</span><span class="p">(</span><span class="n">Closure</span><span class="o">&amp;&amp;</span> <span class="n">closure</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PostDelayedTask</span><span class="p">(</span><span class="n">webrtc</span><span class="o">::</span><span class="n">ToQueuedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">&gt;</span><span class="p">(</span><span class="n">closure</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">milliseconds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">webrtc</span><span class="o">::</span><span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">impl_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DISALLOW_COPY_AND_ASSIGN</span><span class="p">(</span><span class="n">TaskQueue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>private</code>部分：</p>
<p><code>TaskQueue</code>只有一个私有变量，也就是使用<code>TaskQueueBase</code>的裸指针指向的常量<code>impl_</code>，并且<code>TaskQueue</code>禁用了拷贝构造函数和赋值运算符。</p>
<p>这里为什么存放的是裸指针呢，我猜主要是出于性能的考虑。</p>
<p><code>public</code>部分：</p>
<p><code>TaskQueue</code>的构造函数接受 1 个参数，也就是使用<code>unique_ptr</code>管理生命周期的对象，这个对象需要是实现了<code>TaskQueueBase</code>这一接口的对象。</p>
<p><code>TaskQueue</code>有 2 个重要的方法，也就是<code>PostTask</code>和<code>PostDelayedTask</code>。</p>
<ul>
<li><code>PostTask</code>：将<code>task</code>加入到任务队列中进行即时处理；</li>
<li><code>PostDelayedTask</code>：将<code>task</code>加入到任务队列中，过<code>milliseconds</code>毫秒处理。</li>
</ul>
<p>这 2 种方法都有 2 种重载形式。在 webrtc 的代码中，经常使用的是接受一个闭包也就是 lambda 表达式作为参数的这一重载形式。</p>
<p>比如在<code>call/rtp_transport_controller_send.cc</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpTransportControllerSend</span><span class="o">::</span><span class="n">OnSentPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">rtc</span><span class="o">::</span><span class="n">SentPacket</span><span class="o">&amp;</span> <span class="n">sent_packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">task_queue_</span><span class="p">.</span><span class="n">PostTask</span><span class="p">([</span><span class="k">this</span><span class="p">,</span> <span class="n">sent_packet</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_queue_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">SentPacket</span><span class="o">&gt;</span> <span class="n">packet_msg</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">transport_feedback_adapter_</span><span class="p">.</span><span class="n">ProcessSentPacket</span><span class="p">(</span><span class="n">sent_packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pacer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">UpdateOutstandingData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">transport_feedback_adapter_</span><span class="p">.</span><span class="n">GetOutstandingData</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet_msg</span> <span class="o">&amp;&amp;</span> <span class="n">controller_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">PostUpdates</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">OnSentPacket</span><span class="p">(</span><span class="o">*</span><span class="n">packet_msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpTransportControllerSend</span><span class="o">::</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ReceivedPacket</span><span class="o">&amp;</span> <span class="n">packet_msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">task_queue_</span><span class="p">.</span><span class="n">PostTask</span><span class="p">([</span><span class="k">this</span><span class="p">,</span> <span class="n">packet_msg</span><span class="p">]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_queue_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">controller_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">PostUpdates</span><span class="p">(</span><span class="n">controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span><span class="n">packet_msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>TaskQueue</code>的创建基本上都是采用工厂模式完成。</p>
<p>从<code>TaskQueue</code>的实现代码中可以发现，它其实只是为实现了<code>TaskQueueBase</code>这一接口类的子类封装了一个统一的调用接口，实际上起到的是代理的作用。</p>
<p>真正做事的或者说真正核心的代码应该是<code>TaskQueueBase</code>这个接口类的定义以及实现其纯虚函数的子类。</p>
<h2 id="taskqueuebase">TaskQueueBase</h2>
<p><code>TaskQueueBase</code>是 WebRTC 中用来实现异步执行任务的类，保证队列中的任务按照 FIFO 的顺序执行，不同任务的执行时间不会重叠。</p>
<p>不过，同一个任务队列中的不同任务并不一定总是在相同的 worker 线程上执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RTC_LOCKABLE</span> <span class="n">RTC_EXPORT</span> <span class="n">TaskQueueBase</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Starts destruction of the task queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// On return ensures no task are running and no new tasks are able to start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the task queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Responsible for deallocation. Deallocation may happen syncrhoniously during
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Delete or asynchronously after Delete returns.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Code not running on the TaskQueue should not make any assumption when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TaskQueue is deallocated and thus should not call any methods after Delete.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Code running on the TaskQueue should not call Delete, but can assume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TaskQueue still exists and may call other methods, e.g. PostTask.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Delete</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Schedules a task to execute. Tasks are executed in FIFO order.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If |task-&gt;Run()| returns true, task is deleted on the task queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// before next QueuedTask starts executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// When a TaskQueue is deleted, pending tasks will not be executed but they
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// will be deleted. The deletion of tasks may happen synchronously on the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TaskQueue or it may happen asynchronously after TaskQueue is deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This may vary from one implementation to the next so assumptions about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// lifetimes of pending tasks should not be made.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PostTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Schedules a task to execute a specified number of milliseconds from when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the call is made. The precision should be considered as &#34;best effort&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and in some cases, such as on Windows when all high precision timers have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// been used up, can be off by as much as 15 millseconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PostDelayedTask</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">QueuedTask</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="kt">uint32_t</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns the task queue that is running the current thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Returns nullptr if this thread is not associated with any task queue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="nf">Current</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">IsCurrent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">()</span> <span class="o">==</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">CurrentTaskQueueSetter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ABSL_CONST_INIT</span> <span class="k">thread_local</span> <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">CurrentTaskQueueSetter</span><span class="p">(</span><span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">task_queue</span><span class="p">)</span> <span class="o">:</span> <span class="n">previous_</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span> <span class="o">=</span> <span class="n">task_queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">CurrentTaskQueueSetter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">current</span> <span class="o">=</span> <span class="n">previous_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">CurrentTaskQueueSetter</span><span class="p">(</span><span class="k">const</span> <span class="n">CurrentTaskQueueSetter</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CurrentTaskQueueSetter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">CurrentTaskQueueSetter</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">previous_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Users of the TaskQueue should call Delete instead of directly deleting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// this object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="o">~</span><span class="n">TaskQueueBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从代码中的注释可以看明白<code>PostTask</code>这一方法的作用，也就是我们上面所说的：把<code>task</code>加入到事件队列中，按照 FIFO 的顺序进行处理。</p>
<p>需要注意的是，这里还有一个可访问性为<code>protected</code>的类：<code>CurrentTaskQueueSetter</code>，这个类的作用就像它的命名一样，用于设置当前的任务队列，也就是把任务队列绑定到当前线程上。</p>
<ul>
<li>构造时，用传入构造函数的任务队列更新当前线程存放的任务队列，并将更新前的任务队列暂存到当前线程的 TLS(Thread Local Storage)中。</li>
<li>析构时，用构造时暂存的任务队列更新当前线程存放的任务队列。</li>
</ul>
<p>WebRTC 中有好几个实现了<code>TaskQueueBase</code>这一接口的类如<code>TaskQueueStdlib</code>, <code>TaskQueueLibevent</code>, <code>TaskQueueWin</code>, <code>SimulatedTaskQueue</code>等，它们的作用也各不相同。</p>
<p>下面我们以<code>TaskQueueStdlib</code>为例，对实际的<code>PostTask</code>等函数是如何运行的一探究竟。</p>
<h2 id="taskqueuestdlib">TaskQueueStdlib</h2>
]]></description>
</item>
<item>
    <title>虚拟地址空间</title>
    <link>http://localhost:1313/posts/knowledge/os/virtual-memory-space/</link>
    <pubDate>Wed, 07 Feb 2024 15:56:52 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/os/virtual-memory-space/</guid>
    <description><![CDATA[<h2 id="什么是虚拟地址空间">什么是虚拟地址空间？</h2>
<p>虚拟地址空间就是每个程序在运行起来之后所独占的内存空间，也就是进程自己的地址空间。</p>
<p>虚拟地址空间的大小由地址总线的宽度也就是计算机的字长决定：</p>
<ul>
<li>
<p>对于 32 位系统，进程的虚拟地址空间大小为：</p>
<p>$$
2^{32} bit = 4^{30} Byte = 4 GiB
$$</p>
</li>
<li>
<p>对于 64 位系统，进程的虚拟地址空间大小为：
$$
2^{64}bit = 16^{30} GiB = 16 ^{20} TiB = 16^{10} PiB= 16 EiB
$$</p>
</li>
</ul>
<p>不过理论是理论，实际是实际。</p>
<ul>
<li>对于 32 位的<code>linux</code>系统而言，操作系统占用了空间中上面的 1GiB（从<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），程序可以使用的虚拟空间原则上只有 3GiB（从<code>0x00000000</code>到<code>0xBFFFFFFF</code>），对于 64 位的 OS 跟进程各自占用 128T 的空间，分别在最高处和最低处。</li>
<li>对于 32 位的<code>windows</code>系统而言，操作系统 2GiB，程序 2GiB（不过<code>windows</code>系统可以设置启动参数来将 OS 占用的虚拟地址空间大小缩小到 1GiB）.</li>
</ul>
<p>进程的虚拟地址空间用于存放进程运行所必不可少的数据，内存地址从低到高生长，各个区域分别为：</p>
<ul>
<li>代码段(.text)：程序代码段</li>
<li>数据段(.data)：已初始化的静态常量、全局变量</li>
<li>BSS 段(.bss)：未初始化的静态变量、全局变量</li>
<li>堆：动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段：动态库、共享内存等，从高地址开始向下增长；</li>
<li>栈：局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>，从高地址开始向下增长。</li>
</ul>
<h2 id="为什么需要虚拟地址空间">为什么需要虚拟地址空间？</h2>
<p>虚拟地址空间其实是一种应对多进程环境下的策略，这种对程序员透明的抽象方式可以使每个进程都无法感知到其他进程的存在，让各个进程之间的内存空间相互隔离，程序员也无需关心进程运行的物理地址的事情，极大地降低了程序员的心智负担。</p>
<h2 id="32-位的机器程序使用的空间大小能超过-4gib-吗">32 位的机器，程序使用的空间大小能超过 4GiB 吗？</h2>
<p>如果指的是虚拟地址空间，那么答案是“否”。因为 32 位的 CPU 只能使用 32 位的指针，最大的寻址范围就到 4GiB。</p>
<p>如果指的是计算机的内存空间，答案为“是”。Intel 从 95 年推出的 Pentium Pro CPU 开始采用 36 位的物理地址，可以访问达 64GiB 的物理内存。同时，Intel 修改了页映射的方式，使得新的映射方式<strong>Physical Address Extension, PAE</strong>可以访问到更多的物理内存。</p>
<ul>
<li>
<p>在<code>windows</code>下，进程可以拿一段连续的内存地址作为窗口，然后从高于 4GiB 的物理空间中申请多个大小等于窗口大小的物理空间并进行编号 A, B, C 等，用到哪部分就把窗口映射到哪部分。这一操作也叫做<strong>AWE</strong>(Address Windowing Extensions)。</p>
</li>
<li>
<p>在<code>linux</code>下则使用<code>mmap</code>系统调用来实现。<code>mmap</code>系统调用的主要作用是使进程之间通过映射同一个普通文件来实现共享内存(IPC)。普通文件被映射到地址空间之后，进程可以像访问普通内存一样对文件进行访问，而不需要调用<code>write</code>, <code>read</code>函数。<code>mmap</code>本质上并不分配空间，只是将文件映射到进程地址空间（当然，会占掉虚拟内存空间），映射成功后就可以直接用<code>memcpy</code>等操作来写文件，因而用户对这段内存区域的修改就可以直接反映到内核空间（当然反过来也一样）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="n">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对映射空间所写的内容并不会立刻更新到文件中，而是有一段时间的延迟，内核会挑个时间进行写入操作。如果需要即使写入可以调用<code>msync</code>来强制同步。</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>ABI是什么？</title>
    <link>http://localhost:1313/posts/knowledge/cpp/abi/</link>
    <pubDate>Wed, 07 Feb 2024 12:51:01 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/cpp/abi/</guid>
    <description><![CDATA[<h2 id="abi-是什么">ABI 是什么？</h2>
<p>ABI: Application Binary Interface（应用<strong>二进制</strong>接口）。</p>
<p>其实就是针对 <strong>编译器</strong> 和 <strong>链接器</strong> 的<strong>二进制级别</strong>的一些规范和约束，主要规范的内容有：</p>
<ul>
<li>规定函数的调用顺序，也称为“调用约定”，规定了如何将“函数”转换成汇编代码。</li>
<li>规定库函数如何表示，主要对链接过程有指导作用。</li>
<li>规定可以使用什么类型的数据，这些数据如何对齐以及其他低级细节。</li>
<li>ABI 还涉及到 OS 的内容，包括可执行文件的格式、虚拟地址空间布局等细节。</li>
</ul>
<h2 id="为什么会有-abi-">为什么会有 ABI ？</h2>
<p>原因其实很简单，硬件架构、OS、编译工具链以及编程语言的发展和逐层抽象让大部分程序员可以不太在意底层程序的执行过程，而只需要负责编写表明业务逻辑的源代码。大部分程序员不需要在意并不意味着这部分不存在，实际上，这部分内容是通向二进制文件执行的必经之路。</p>
<p>通过上面的分析可以知道， ABI 这个概念基本上是由<code>(硬件架构, OS, 编译工具链, 编程语言)</code>这个四元组决定的。</p>
<ul>
<li>架构兼容性：<code>amd64</code>架构和<code>arm64</code>架构对应的指令集不同，因而一个可执行文件要想在这两个架构上成功运行，就需要编译这两个架构的二进制文件（也就是交叉编译）。</li>
<li>OS 兼容性：<code>windows(PE-COFF)</code>, <code>linux(ELF)</code>和<code>macos(MACH-O)</code>上规定的程序二进制文件格式不同，因而也需要为不同的 OS 编译不同的二进制文件。</li>
<li>编译工具链兼容性：这个我们平时遇到的比较多，常见原因是不同的编译器或不同的编译器版本的<strong>名字修饰</strong>规则不同，导致链接器在链接时找不到对应名字的库函数。</li>
<li>编程语言兼容性：C 语言中的一些基本内容如不同类型数据在内存中存放的形式，寄存器的使用形式等，以及 C++的众多特性：虚函数如何调用、虚表的内容和分布形式、template 如何实例化等等，都是 ABI 所需要规定的内容。</li>
</ul>
<h2 id="abi-compatible-">ABI-Compatible ?</h2>
<p>ABI-compatible 允许编译好的目标代码可以无需修改或重新编译链接就能直接运行，而从上面举的例子就可以发现，ABI 兼容是一件很难做到的事情，光是架构和 OS 的不同就需要不同的目标文件了。</p>
<p>而编译工具链的兼容性容易做到吗？其实也不容易。目前主流的 C++编译工具链有<code>gcc</code>, <code>llvm(clang)</code>和<code>msvc</code>，这三者之间对于名字修饰的规定都不同，因而一个用<code>clang</code>编译的库函数是无法被一个用<code>msvc</code>编译的<code>main</code>文件调用的。当然，这里指的是默认进行名字修饰的情况，如果使用<code>extern &quot;C&quot;</code>对函数进行修饰，从而要求编译器使用 C 语言的编译和链接规范进行处理就可以解决这个问题。</p>
<p>C++一直被诟病的原因之一就是二进制兼容性不好，对于小型项目而言使用同一种编译器进行编译可能可行，但是对于大型项目而言不太现实，库代码的提供者通常只是提供编译链接好的库，并不提供源代码，所以要想做到对于所有的编译器（的所有版本）都进行支持是一件困难且不太现实的事情。</p>
]]></description>
</item>
<item>
    <title>孤儿进程</title>
    <link>http://localhost:1313/posts/development/orphan-process/</link>
    <pubDate>Mon, 29 Jan 2024 10:31:56 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/development/orphan-process/</guid>
    <description><![CDATA[<h2 id="问题背景">问题背景</h2>
<p>前两天室友问我，怎么 kill 掉在 Shell 脚本中调用的 Python 进程，我第一时间想到的是：打开 <code>htop</code>，把它调整成树形布局，然后搜索 Shell 脚本，选中之后把它 kill 掉，Python 进程应该也会被 kill 掉。</p>
<p></p>
<p>但是结果是 Python 进程并没有变红，而是成为了 init 进程的子进程。</p>
<h2 id="孤儿进程是怎么产生的">孤儿进程是怎么产生的</h2>
<p>大二学 OS 学到父进程和子进程的概念的时候，还是只是以为父进程和子进程之间应该存在牢固的控制关系，父进程退出时子进程也应该默认退出。</p>
<p>但是 OS 的实际行为不是这样，子进程和父进程只是说明了二者之间存在谁创建谁的关系，并不存在牢固的控制关系（而是类似于现实中的父子关系）。</p>
<ul>
<li>
<p>父进程结束时子进程并没有结束，子进程成为孤儿进程，会被 init 进程收养</p>
</li>
<li>
<p>父进程崩溃或异常终止</p>
</li>
<li>
<p>并发和竞争条件导致父子进程的结束顺序错误</p>
</li>
</ul>
<h2 id="如何避免孤儿进程的产生">如何避免孤儿进程的产生</h2>
<p>其实就是需要在程序设计时，考虑到上述的这几种可能导致孤儿进程产生的原因，然后对异常情况进行注册和处理。对于开始时的这个引入问题而言，答案可以写成以下两个脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># 定义一个函数来处理信号</span>
</span></span><span class="line"><span class="cl">cleanup<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="nb">echo</span> <span class="s2">&#34;捕捉到终止信号，正在终止 Python 进程...&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">kill</span> <span class="nv">$PYTHON_PID</span>
</span></span><span class="line"><span class="cl">	<span class="nb">exit</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在接收到 SIGINT || SIGTERM || SIGKILL 时执行 cleanup 函数</span>
</span></span><span class="line"><span class="cl"><span class="nb">trap</span> <span class="s1">&#39;cleanup&#39;</span> SIGINT SIGTERM
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 启动 Python 脚本并获取其进程 ID</span>
</span></span><span class="line"><span class="cl">python example_python.py <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="nv">PYTHON_PID</span><span class="o">=</span><span class="nv">$!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 等待 Python 进程结束</span>
</span></span><span class="line"><span class="cl"><span class="nb">wait</span> <span class="nv">$PYTHON_PID</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">time</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">signal</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义信号处理函数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Python 脚本接收到终止信号，正在退出...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置 SIGINT SIGTERM 的处理器</span>
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Python 脚本的主逻辑</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Python 脚本正在运行...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过在父进程和子进程中都注册相应的事件，就可以保证 kill 作为父进程的 Shell 进程之后，作为子进程的 Python 进程也会终止。</p>
<p>实际演示：<code>chmod +x example.sh example_python.py &amp;&amp; bash example.sh</code></p>
<p></p>
<p>执行 <code>SIGTERM</code> 信号的 kill 之后，父子进程都被终止。</p>
<p></p>
<p>需要注意的是，如果使用 <code>kill -9 $PARENT_PID</code> 的形式来杀死父进程的话，子进程并不会被杀死。</p>
<p>因为 <code>9</code> 这个编号对应的是 <code>SIGKILL</code> 信号，<code>SIGKILL</code> 信号被设计为不能被捕捉、阻塞或忽略的。<code>SIGKILL</code> 的主要用途是允许操作系统或用户强制终止一个进程，即使该进程处于非响应状态。（类似的还有 <code>SIGSTOP</code> 信号，用于暂停一个进程的执行，也不能被捕捉、阻塞或忽略。）</p>
<p>所以我们也无法在 Python 脚本中注册监听这个信号（强行注册 Python 脚本会无法运行）。</p>
<p></p>
]]></description>
</item>
<item>
    <title>Git 常用用法记录</title>
    <link>http://localhost:1313/posts/development/git-usage/</link>
    <pubDate>Tue, 23 Jan 2024 09:50:29 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/development/git-usage/</guid>
    <description><![CDATA[<p>这篇博客用来记录平时用到的一些 Git 操作，用到之后会不定时更新。</p>
<h2 id="clone-相关">clone 相关</h2>
<p>克隆指定 branch ： <code>git clone --branch &lt;branch-name&gt; &lt;remote-repo-url&gt;</code></p>
<p>递归克隆（包括 submodule ）：<code>git clone --recursive</code></p>
<p>已经 clone 完的仓库：<code>git submodule update --init --recursive</code></p>
<h2 id="checkout-相关">checkout 相关</h2>
<p>切换分支：<code>git checkout &lt;branch-name&gt;</code> / <code>git switch &lt;branch-name&gt;</code></p>
<p>新建分支：<code>git checkout -b &lt;branch-name&gt;</code> / <code>git switch -c &lt;branch-name&gt;</code></p>
<p>切换到一个 tag ：<code>git fetch --all --tags --prune</code> -&gt; <code>git tag</code> -&gt; 使用 <code>/</code> 快速搜索 -&gt; <code>git checkout tags/&lt;tag-name&gt; -b &lt;branch-name&gt;</code></p>
<h2 id="commit-相关">commit 相关</h2>
<p>undo 本地改动（还未 commit）：<code>git restore &lt;file-path&gt;</code></p>
<p>修改 commit 消息（还未 push）：<code>git commit --amend</code></p>
<p>undo 前 1 次 commit（还未 push）：<code>git reset --soft HEAD~</code></p>
<p>undo 前 2 次 commit（还未 push）：<code>git reset --soft HEAD~2</code></p>
<p>undo 某次 commit（已经 push）：<code>git revert &lt;commit-hash&gt;</code></p>
<p>undo 某个区间内的 commit（已经 push）：</p>
<p><code>git revert --no-commit &lt;left-commit-hash&gt;..&lt;right-commit-hash&gt;</code> （左开右闭） -&gt; <code>git commit</code></p>
<h2 id="协作相关">协作相关</h2>
<p>Review 并且 Commit 别人提出的 PR 的流程：</p>
<ol>
<li>
<p><code>git remote add &lt;remote-name&gt; &lt;remote-repo-url&gt;</code></p>
</li>
<li>
<p><code>git remote -v</code></p>
</li>
<li>
<p><code>git fetch &lt;remote-name&gt;</code></p>
</li>
<li>
<p><code>git checkout -b &lt;local-branch-name&gt; &lt;PR-branch-name&gt;</code></p>
</li>
<li>
<p><code>git commit -sm &quot;&lt;commit-message&gt;&quot;</code></p>
</li>
<li>
<p><code>git push &lt;remote-name&gt; HEAD:&lt;PR-branch-name&gt;</code></p>
</li>
</ol>
]]></description>
</item>
<item>
    <title>H264 Encode</title>
    <link>http://localhost:1313/posts/knowledge/h264-encode/</link>
    <pubDate>Tue, 23 Jan 2024 01:05:20 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/h264-encode/</guid>
    <description><![CDATA[<h2 id="编码框架">编码框架</h2>
<p>编码器包含两个方向的码流分支：</p>
<p></p>
<p>从左到右的前向码流分支为编码过程；</p>
<p>从右到左的反向码流分支为重建过程。</p>
<h3 id="前向编码分支">前向编码分支</h3>
<p>以 16x16 像素的 MB 为单位进行处理，首先从当前输入的视频图像(Frame or Field)中取一个待编码宏块$F_n$，该宏块以帧内或者帧间的模式进行编码，生成一个预测宏块$P$。</p>
<p>如果是帧内编码，$P$由当前 Slice 里面已经编码、解码、重构并且还没进行去块滤波的宏块 $μF_n&rsquo;$ 使用帧内预测得到。当前宏块 $μF_n&rsquo;$ 减去预测宏块 $P$，得到残差块$D_n$，对残差块 $D_n$ 进行整数变换（一般是 4x4，或者 8x8）、量化后得到一组系数 $X$ ，再对 $X$ 进行重排序和熵编码，就完成了一个宏块的编码过程。对于 P 帧和 B 帧，如果 ME 时候找不到最佳匹配块那也会使用帧内预测编码。</p>
<p>经过熵编码的码流加上宏块解码所需的一些信息，如预测模式、量化步长、描述宏块运动预测补偿的运动矢量信息等，就组成了该宏块压缩后的码流，Slice 中所有 MB 的码流加上 Slice 头信息就组成了 Slice 的编码码流，再通过 NAL 层进行传输或存储。图像参数集 PPS 和序列参数集 SPS 则由 NAL 单独进行传输。</p>
<h3 id="后向重建分支">后向重建分支</h3>
<p>在后向重建分支中，对量化后的宏块系数 $X$ 进行解码从而得到重建宏块，后续宏块进行编码需要从已重建的宏块中寻找参考块。宏块重建过程如下：
宏块系数 $X$ 经过反量化和反变换之后，得到残差宏块 $D_n$ 的近似值 $D_n&rsquo;$ ，预测块 $P$ 加上 $D_n&rsquo;$ 得到未滤波的重构宏块 $μF_n&rsquo;$ ，再做环路滤波来减少块效应，即得到了最终的重构宏块 $F_n&rsquo;$ ，当图像中所有宏块都重建完成后，就形成了重建图像。</p>
<p>后向重建分支其实就是包含在编码中的完整解码流程，与真正解码器的唯一区别是： 其预测块 P 直接从前向编码分支中得到，而真正的解码器需要利用码流中解出的预测块信息获得预测块 P。当前图像的已重建宏块会被用做帧内预测的参考，而完整的重建图像会被加入参考帧列表，作为未来编码图像帧预测的参考图像。</p>
<h2 id="预测编码">预测编码</h2>
<p>预测编码（Prediction Coding）利用相邻像素之间的空间和时间相关性，用已传输的像素对当前正在编码的像素进行预测，然后对预测值和真实值的差值——预测误差进行编码和传输。</p>
<p>消除空间冗余：利用一帧图像已经编码的部分来预测还没有被编码的部分</p>
<p>消除时间冗余：利用之前编码过的图像来预测当前图像需要编码的部分</p>
<p>通过预测可以得到预测值，预测值通常不等于实际值，所以用实际值减去预测值可以得到预测残差。预测方法越好，残差越小，因而对残差进行编码得到的码流要比对实际值直接进行编码的码流要小</p>
<p>在解码端可以解码出残差，使用与编码端相同的预测过程来获取预测值，加上残差便可以得到相应的实际值。</p>
<p>目前使用较广的预测方法是线性预测。用已传像素的线性组合对正在编码的像素进行预测。</p>
<p>编码器输出预测值和实际值之间的差值，选择最优的预测系数，使预测误差的分布在 0 附近。经过非均匀量化之后，最终传输的是量化之后的预测误差。</p>
<p>重建的图像与编码前的图像之间的区别是量化带来的。</p>
<p>如果取消量化操作，那么预测编码和解码就是一个无失真的编解码系统，但是这样的压缩率要远远低于使用量化的压缩率。</p>
<p>量化的事实依据是图像中存在人眼感知并不明显的区域，通过非均匀量化可以过滤掉这部分数据（也被称为量化噪声），能达到提高压缩率但不降低主观质量的效果。</p>
<h2 id="帧间预测">帧间预测</h2>
<p>帧间预测消除的是时间冗余，主要利用的是运动估计和运动补偿。</p>
<p>运动估计 ME 的过程其实就是计算运动向量 MV 的过程：</p>
<p>寻找当前编码的块在已编码图像中的最佳对应快，并且计算出对应块的偏移量：运动向量</p>
<p>假设当前编码块是 $B$ ，在参考帧 $P_r$ 中寻找与 $B$ 块相减残差最小的块 $B_r$ ， $B_r$ 就是 $B$ 块的最佳匹配块。</p>
<p>$$
MV=B_r-B=(x_r  - x,y_r  - y)
$$</p>
<p>$B_r$ 块就是 $B$ 块的参考块， $B_r$ 的像素值就作为 $B$ 块像素值的预测值。
运动向量 MV 也需要用合适的方式编码到码流中。</p>
<p>运动补偿 MC：根据 MV 和帧间预测方法，求出当前帧的估计值的过程。</p>
<p>当前帧的估计值是对当前图像的描述，用来说明当前图像的每一个像素怎么由它的参考图像的像素块得到。</p>
<p>ME 是动态的过程，MC 是静态的描述。</p>
<ul>
<li>
<p>ME 设计很多算法和技巧。</p>
</li>
<li>
<p>MC 可以看作是索引表，一个描述像素块的最佳匹配块分布情况的索引表。</p>
</li>
</ul>
<p>实际计算过程中会对树状结构分块的 8 种模式都尝试一遍。
H264 支持亮度 1/4 像素、色度 1/8 像素的运动估计，在亚像素 ME 之前需要先用插值法得到亚像素值。</p>
<ul>
<li>
<p>在噪声大的视频中，提高搜索精度没法提高预测精确度。</p>
</li>
<li>
<p>在噪声小的视频中，1/4 像素精度可以达到比较好的预测效果。</p>
</li>
<li>
<p>视频会议里 1/2 像素精度基本可以满足需求。</p>
</li>
</ul>
<h3 id="运动估计算法">运动估计算法</h3>
<p>假设匹配误差随着离全局误差最小点的距离增加而单调增加，从原点开始，采用固定的搜索模板和搜索策略得到最佳匹配块。</p>
<p>理论最优的算法是全搜索法，但是计算量巨大，效率低, 一般作为其他搜索算法的一种效率参考。</p>
<p>还有其他的快速法：X264 里面主要使用的是钻石搜索法 DIA、六边形搜索法 HEX 和 UMH。</p>
<p>钻石搜索法以搜索起点为中心，先用 LDSP 进行搜索，直到最佳匹配点位于大菱形的中心位置，然后再用小菱形搜索，直至最佳匹配点位于小菱形的中心位置。</p>
<p>六边形搜索法采用 1 个大模板（六边形模板）和 2 个小模板（小菱形模板和小正方形模板）。</p>
<ul>
<li>步骤 1：以搜索起点为中心，采用图中左边的六边形模板进行搜索。计算区域中心及周围 6 个点处的匹配误差并比较，如最小 MBD 点位于模板中心点，则转至步骤 2；否则以上一次的 MBD 点作为中心点，以六边形模板为模板进行反复搜索。</li>
<li>步骤 2：以上一次的 MBD 点为中心点，采用小菱形模板搜索，计算各点的匹配误差，找到 MBD 点。然后以 MBD 点为中心点，采用小正方形模板搜索，得到的 MBD 点就是最优匹配点。</li>
</ul>
<p>UMH 是基于 MV 具有时空相关性，所以可以结合上一帧和上一步中 MV 的方向和角度，来修改多层六边形的形状，UMH 算法包含四中搜索模式:不均匀交叉搜索、多六边形网格搜索、迭代六边形搜索、菱形搜索。</p>
<ul>
<li>步骤 1：进行一次小菱形搜索，根据匹配误差值和两个门限值（对于一种尺寸的宏块来说是固定大小的 threshold1 和 threshold2）之间的关系作相应的处理，可能用到中菱形模板或者正八边形模板，也有可能直接跳到步骤 1。</li>
<li>步骤 2：使用非对称十字模板搜索。“非对称”的原因是一般水平方向运动要比垂直方向运动剧烈，所以将水平方向搜索范围定为 W，垂直方向搜索范围定为 W/2。</li>
<li>步骤 3：使用 5x5 逐步搜索模板搜索。</li>
<li>步骤 4：使用大六边形模板搜索。</li>
<li>步骤 5：使用六边形搜索算法找到最优匹配点。</li>
</ul>
<p>码率不变的前提下，“Dia”、“HEX”、“UMH”编码获得的质量依次提高，速度依次降低。快速算法（“Dia”、“HEX”、“UMH”）的编码质量比全搜索算法低不了太多，但是速度却高了很多倍。</p>
<h3 id="多参考帧预测">多参考帧预测</h3>
<p>编码端存储参考帧的缓冲区就是 DPB，主要有三种参考帧：短期参考帧、长期参考帧和非参考帧。</p>
<ul>
<li>短期参考帧就是和当前帧相邻的帧，按照从近到远的顺序排序。</li>
<li>长期参考帧是较早之前的帧，按照从远到近的方式排列。</li>
<li>不使用的参考帧是因为某些原因废弃了的参考帧，并且没有被新的参考帧替换掉。比如遇到 IDR 帧的时候 DPB 里面的所有参考帧都会标记成非参考状态。所以 I 帧之后的 P 帧也可以参考这个 I 帧之前的图像。</li>
</ul>
<h3 id="mv-预测和-skip-模式">MV 预测和 Skip 模式</h3>
<p>需要对 MV 进行压缩，方式是使用临近分块 MV 之前的相关性对当前块的 MV 进行预测，只对预测残差 MVD 进行编码。</p>
<p>Skip 模式：Skip 模式只针对宏块编码，也就是完全不用编码只需要在码流里面标明是 SKIP 宏块就行。P_Skip 宏块就是 COPY 宏块，既没有 MVD，也不编码量化残差，解码时候直接用 MVp 作为运动向量得到像素的预测值作为像素重建值。B_Skip 宏块也是既没有 MVD 也没有量化残差，解码时候通过 Direct 预测模式计算出前向和后向 MV，然后得到像素预测值作为重建值。</p>
<ul>
<li>
<p>P_Skip：最佳模式是 Inter16x16、参考帧是 List0 里面的第一个参考帧、MVD=0、变换系数被量化成 0，或者在 RDO 模型中被抛弃。</p>
</li>
<li>
<p>B_Skip：最佳模式是 B_direct_16x16，变换系数要么全是 0 要么被算法抛弃。</p>
</li>
</ul>
<h3 id="加权预测">加权预测</h3>
<p>用来应对明暗/亮度变化的场景，使用两种预测模式：显式模式(P 帧、B 帧)和隐式模式(B 帧)。</p>
<ul>
<li>显式模式：加权系数由编码器决定并且在 Slice Header 里面传输。</li>
<li>隐式模式：加权系数由参考图像的时间位置推算，越接近当前图像，加权系数越大。</li>
</ul>
<p>步骤：</p>
<ol>
<li>
<p>亮度变化检测：</p>
<p>使用直方图计算前后两幅图像在各个灰度级别 SAD，然后采用阈值法判断有没有发生亮度变化。</p>
</li>
<li>
<p>计算加权系数：
第一种方法：计算参考帧和当前帧的亮度均值比值，利用比值作为加权系数（全局加权补偿的效果有限）</p>
<p>第二种方法：全局补偿，但是使用使前后图像 MSE 和偏移量最小的加权系数：使 MSE 的表达式（加权系数$W_1$和偏移量$W_2$）分别基于$W_1$和$W_2$的偏微分等于 0。</p>
</li>
<li>
<p>亮度补偿：</p>
<p>原则上需要做到宏块级别的亮度补偿，但是为了降低复杂度只做帧级亮度补偿。</p>
<p>根据求出的加权系数和偏移量进行全局亮度补偿得到新图像。</p>
<p>把新图像存到一个列表中作为带亮度补偿运动估计的参考帧。</p>
</li>
</ol>
<h2 id="帧内预测">帧内预测</h2>
<p>帧内预测实质是消除空间冗余，利用已编码的块的像素的来预测未编码的像素值。</p>
<p>未编码的块像素的实际值-预测值=残差，传输只需要传输残差。</p>
<p>H264 引入了基于空域的帧内预测技术，在空域中利用当前块的相邻像素直接对每个像素做预测，并对预测残差进行变换、量化。</p>
<p>H264 帧内预测中，色度和亮度信息是被分开预测的。</p>
<ul>
<li>对于亮度待编码块，可以按照 4x4 块方式预测(I4MB)或 16x16 宏块方式预测(I16MB)。
<ul>
<li>4x4 预测时有 9 种模式（水平、垂直、DC、6 个方向），用于图像细节部分的预测。</li>
<li>16x16 预测时有 4 种模式（水平、垂直、DC、平面），用于图像平坦区域的预测。</li>
</ul>
</li>
<li>对于色度待编码块，基于 8x8 块进行预测。
<ul>
<li>8x8 预测有 4 种模式（水平、垂直、DC、平面）。</li>
</ul>
</li>
</ul>
<p>亮度和色度的最佳帧内预测模式相互独立：</p>
<ul>
<li>
<p>色度的只需要比较 4 种模式的代价，选择最小的。</p>
</li>
<li>
<p>亮度的需要：算出代价最小的 Intra4x4 模式、算出代价最小的 Intra16x16 模式、取两者最小的。</p>
<ul>
<li>Intra4x4：用 RDO 模型也就是拉格朗日模型计算代价。</li>
<li>Intra16x16：用 SATD，变换使用哈达马变换（看作是简单的时频变换，可以反映生成码流的大小）</li>
</ul>
</li>
</ul>
<h2 id="变换编码">变换编码</h2>
<p>变换编码（Transform Coding）将空间域描述的图像，经过某种变换形成变换域中的数据，达到改变数据分布，减少有效数据量的目的。</p>
<p>变换编码中主要使用方式是正交变换。正交变换不会改变信源的熵值，变换之后图像的信息量并没有损失，完全可以通过反变换得到原来的图像值。</p>
<p>正交变换可以改变数据的分布，将数据集中分布之后就可以使用进一步的量化操作来去除大部分的 0 值和接近 0 的值。</p>
<p>正交变换中的理论最优变换是 K-L 变换。</p>
<p>实际中常用的正交变换有 DCT 变换，DFT 变换(离散傅里叶变换)，Hadamard 变换。</p>
<p>因为 DCT 系数主要集中在低频区域，越是高频区域系数值越小，通过设置不同的视觉阈值的量化电平，将许多能量较小的高频系数量化为 0，可以增加变换系数中 0 的个数，同时保留能量较大的系数分量，对量化之后的系数进行熵编码可以获得进一步的压缩。</p>
<p>H264 使用的是整数变换，变换核只用加减法和左移操作实现，不需要乘法器。</p>
<p>各种变换的比较：</p>
<ul>
<li>压缩比和重建质量：
<ul>
<li>较小分块时，DCT 的 MSE 接近 K-L 变换。</li>
<li>块大小超过 16x16 时，除傅里叶变换之外，其他几种变换的 MSE 下降很慢。</li>
<li>大方块尺寸时，傅里叶变换趋向于 K-L 变换。</li>
</ul>
</li>
<li>计算复杂度：
<ul>
<li>Hadamard 计算复杂度最小。</li>
<li>其次是 DFT 和 DCT，具有固定的核函数。</li>
<li>K-L 变换的核函数与输入相关，计算量很大，不实用。</li>
</ul>
</li>
</ul>
<p>变换编码中的失真还是由量化器引起，正反变换和变长编解码都是无损处理。</p>
<h3 id="dct-变换">DCT 变换</h3>
<p>离散余弦变换与 DFT 变换相似，但是 DCT 变换只使用实数。</p>
<p>DCT 变换具有能量集中性，大多数的声音和图像信号的能量都集中在 DCT 变换之后的低频部分。</p>
<p>当信号具有接近马尔可夫过程的统计特性时，DCT 变换的去相关性接近于 K-L 变换。</p>
<p>图像处理领域中，DCT 变换的效果要强于 DFT 变换，因而图像处理中更多应用的是 DCT 变换。</p>
<p>DCT 产生的系数很容易被量化，因而可以获得较好的块压缩。</p>
<p>DCT 算法的性能好，有快速算法，采用快速傅里叶变换可以进行高效的运算。</p>
<h2 id="量化">量化</h2>
<p>量化的思想就是映射一个输入间隔到一个整数，减少信源编码的 bit 数。</p>
<p>量化器的设计就是率失真优化问题，在允许一定失真的条件下，获得尽可能高的压缩比。</p>
<p>量化步长决定量化器的编码压缩率和图像精度。</p>
<p>量化最简单的方法就是均匀（线性）量化，但均匀量化的效果往往并不好，因为它没有考虑到量化对象的概率分布。</p>
<p>对 DCT 系数这样的数据而言，其分布大部分集中在直流和低频附近，如果采用非均匀量化，对低频区域进行细量化，对高频区域进行粗量化，在相同的量化步长的条件下，非均匀量化比均匀量化所造成的量化误差要小得多。</p>
<p>量化之后，熵编码之前，可以根据从高到低的统计特性，对系数进行 Zigzag 锯齿扫描和游程长度编码。这样做的原因在于：量化之后的 DCT 系数更为稀疏，只有少数的 AC 系数不为 0，Zigzag 扫描能增加连 0 的长度，减少统计事件的个数，从而进一步增加对 DCT 系数熵编码的压缩率。</p>
<p>量化区间上的最优量化值应该是区间的期望值，所以需要知道残差变换系数的统计分布。</p>
<p>引入量化偏移量 f 来进行非均匀量化，在帧内预测时 f=Qstep/3，帧间预测时 f=Qstep/6.</p>
<p>f 可以控制量化死区大小，f 变大，量化死区减少，f 变小，量化死区增加。死区大小直接影响图像的主观质量。</p>
<h2 id="去块滤波不是很了解细节">去块滤波（不是很了解细节）</h2>
<p>环路滤波器是被放置在编解码的图像重建环路当中。</p>
<p>在启用了环路滤波的编解码环境中，无论是编码器还是解码器，都是在图像被重建后才进行滤波。</p>
<p>在编码器中，滤波后的图像会作为后续编码运动补偿的参考图像；</p>
<p>在解码器中，滤波后的图像会被输出显示并且作为后续图像解码重建的参考图像。</p>
<h3 id="块效应出现的原因">块效应出现的原因</h3>
<ol>
<li>基于块的量化会破坏相邻块之间的相关性，并且在低码率情况下会放大这种误差。</li>
<li>运动补偿加剧了由变换量化导致的块效应。因为运动补偿块的匹配不可能绝对准确，各个块的残差大小程度存在差异，尤其是当相邻两个块用的参考帧不同、运动矢量或参考块的差距过大时，块边界上产生的数据不连续就更加明显。</li>
</ol>
<h3 id="过程">过程</h3>
<p>估算边界强度、区分真假边界、滤波运算</p>
<h2 id="熵编码">熵编码</h2>
<p>主要利用信源的统计特性进行码率压缩，是无损压缩编码方法。</p>
<p>H264 支持 CAVLC（变长编码）和 CABAC（二进制算术编码）。</p>
<p>CAVLC 本质是哈夫曼编码，所以必须为所有可能的长度为 N 的序列设计和存储编码表，复杂度随 N 指数增长。</p>
<p>CABAC 的思想是用 0 到 1 区间上的一个数来表示整个字符输入流，而不是为输入流中的每个字符分别指定码字。</p>
<ul>
<li>算术编码用区间递进的方法为输入流寻找码字，从第一个符号确定的初始区间开始，逐个读入输入流，在每个新的字符出现后递归地划分当前区间，划分的依据是各个字符的概率，将当前区间按照各个字符的概率划分成若干子区间，将当前字符对应的子 2 区间取出，作为处理下一个字符时的当前区间。到处理完最后一个字符后，得到了最终区间，在最终区间中任意挑选一个数作为输出。在解码时候也采用相同的方法和步骤，但是解码器每划分一个子区间就能得到输入流中的一个字符。</li>
<li>在实际过程中，输入流中字符的概率分布是动态改变的，这需要维护一个概率表去记录概率变化的信息。在作递进计算时，通过对概率表中的值估计当前字符的概率，当前字符处理后，需要重新刷新概率表。这个过程表现为对输入流字符的自适应。编码器和解码器按照同样的方法估计和刷新概率表，从而保证编码后的码流能够顺利解码。</li>
</ul>
<p>一般来讲，只要计算量允许，就应该选择使用算术编码。</p>
<p>H264 对不同的数据采用不同的熵编码模式，对于宏块和子块的残差数据经过变换之后的系数采用 CAVLC，对于其他相对重要的语法元素使用指数哥伦布编码。在 CABAC 方案里，对不同的语法元素也使用了不同的编码树结构。</p>
<h2 id="gopframesliceibp">GOP/Frame/Slice/I/B/P</h2>
<p>帧 Frame 包含切片 Slice，Slice 包含宏块 Macroblock(MB)。</p>
<p>一个 Frame 至少包含一个 Slice，一个 Slice 至少包含一个 MB。</p>
<p>Slice 是 MB 的载体，出现的原因是为了防止误码的扩散和传播。</p>
<p>每个 Slice 都是互相独立被传输的，某个 Slice 不能以其他 Slice 中的 MB 为参考。</p>
<p>Slice 存储在 NAL 单元 NALU 中，是 NALU 的有效载荷 Payload。</p>
<p>Slice 中包含 Slice Header 和 Slice Payload。</p>
<p>Slice Header 中存放的是 Slice 类型、Slice 中的宏块类型、Slice 属于哪个 Frame、对应的帧的设置和参数等信息，Slice Payload 中存放的是 MB</p>
<p>MB 中包含了 MB 类型、预测类型、Coded Block Pattern(CBP)、量化参数 QP、像素的亮度和色度数据等信息</p>
<p>GOP 由 IDR 帧开始，中间存在多个 P 帧或 B 帧（基本档次 Baseline Profile 不存在）</p>
<p>I 帧只进行帧内编码，IDR 帧是每个 GOP 的第一个帧，IDR 帧是 I 帧，I 帧不一定是 IDR 帧</p>
<p>P 帧参考前面的 I 帧或者 P 帧进行编码；</p>
<p>B 帧参考前向、后向的 I 帧或 P 帧进行编码；</p>
<p>P/B 帧进行编码时候只能参考当前 GOP 的 I/P 帧，不能越过当前 GOP 开始时的 IDR 帧，但是 I 帧之后的 P 帧也可以参考这个 I 帧之前的图像。</p>
<h2 id="spsppsdtspts">SPS/PPS/DTS/PTS</h2>
<p>SPS：序列参数集，描述的是整个视频序列的参数信息，如图像的宽度、高度、帧率、色度空间等，一个视频序列只有一个 SPS，用于描述整个视频序列的基本特性。SPS 一般在视频码流的开头发送，是一种全局静态的描述方式。当然，如果编码器在编码过程中改变了 SPS 中描述的参数如分辨率时也需要发送新的 SPS。</p>
<p>PPS：图像参数集，描述的是一个序列中一个或多个图像的参数，例如编码图像的配置、QP 这些，可以在视频序列的任何时刻发送，PPS 相对与 SPS 来说比较灵活动态。</p>
<p>发 I 帧之前至少要发一次 SPS 和 PPS</p>
<p>DTS：解码时间序列，编码帧时的顺序</p>
<p>PTS：展示时间序列，展示帧时的顺序，当有 B 帧时 PTS 不等于 DTS</p>
<p>编码之后的 VCL 数据被封装进 NALU 中，构成了 h264 原始码流</p>
<p></p>
<h2 id="nalu">NALU</h2>
<p>NALU 是视频编码的基本单位，同时也是后续进行视频传输的基本单位。</p>
<p>不同应用需求采用不同的传输方式，NALU 根据传输方式可以以两种方式应用于传输业务。</p>
<ul>
<li>
<p>一类是字节流，即把 NALU 按照解码顺序生成连续的比特流进行传输和处理。</p>
</li>
<li>
<p>一类是分组流应用，也是本文使用的实时视频通信的应用场景，网络可以根据不同网络分组的重要性优化视频流的服务质量，分组流通过将编码后得到的 NALU 作为网络传输的载荷。</p>
</li>
</ul>
<p>NALU 由 NAL Header 和 RBSP 组成，Header 占一个字节，分为 3 个部分。</p>
<p>第 1 个部分是第 0 位，禁止位，值为 0，值为 1 表示语法错误。</p>
<p>第 2 个部分是第 1~2 位，表示当前 NAL 的优先级。值越高表示当前 NAL 越重要，越需要优先保护。SPS/PPS/IDR 帧非常重要，I/P 帧重要，B 帧/SEI 不重要</p>
<p>第 3 个部分是第 3~7 位，表示当前 NALU 的类型：</p>
<p></p>
<p>RBSP：原始字节序列载荷，是 NALU 数据部分的封装格式，封装的数据来自于 SODB（原始数据比特流）。</p>
<p>SODB 是编码后的原始数据。SODB 到 RBSP 的过程：
如果 SODB 是空的，生成的 RBSP 也是空的。
否则：
RBSP 的第一个字节直接取自 SODB 的第 1~8 个 bit，（RBSP 字节内的 bit 按照从左到右对应位从高到低的顺序排列），RBSP 其余的每个字节都直接取自 SODB 的相应 bit。RBSP 的最后一个字节包含 SODB 的最后几个 Bit 和 rbsp_trailing_bits()
rbsp_trailing_bits 的第一个 bit 是 1，接下来填充 0 直到字节对齐。
最后添加几个 cabac_zero_word，值为 0x0000.</p>
<p>NALU 主要涉及到 SPS/PPS/SEI 和 Slice 这几种类型。</p>
<p>SEI 是补充增强信息，提供了向视频码流中加入额外信息的方法，不是解码过程中的必须选项，可能对解码过程有帮助，集成在视频码流中。</p>
<p>RBSP 字节流加上 0x0300 就得到 NALU 载荷字节流：</p>
<p></p>
<h2 id="profilelevel">Profile/Level</h2>
<p>Profile 主要对视频编码的特性做了差异化支持。</p>
<p></p>
<p>H264 中的常用 Profile 有 Baseline，Extended，Main 和 High</p>
<p>Baseline Profile：基本画质，只支持 I/P 帧和 CAVLC 和无交错</p>
<p>Extended Profile：进阶画质，支持 I/P/B/SP/SI，只支持 CAVLC 和无交错</p>
<p>Main Profile：主流画质，支持 I/P/B 帧和，交错和无交错、CAVLC 和 CABAC</p>
<p>High Profile：高级画质：在 Main 的基础上增加了 8x8 内部预测、自定义量化和更多的 yuv 格式。</p>
<p>Baseline Profile 主要用于实时视频通信，Main Profile 和 High Profile 主要用于流媒体领域。</p>
<p>Level 主要根据设备能力来确定编解码时的码率/分辨率上限支持</p>
<h2 id="cbrvbrabrcrf">CBR/VBR/ABR/CRF</h2>
<p>CBR：恒定码率，每秒传输的 bit 数固定，每个视频帧都被分配相同数量的 bit，和复杂度无关，适用于要求网络或者存储带宽具有固定容量的场景，但可能导致复杂场景下的帧质量下降。WebRTC 中使用的就是 CBR。</p>
<p>VBR：可变码率，允许每个帧使用不同的比特数，根据图像复杂度和需要进行动态分配。适合于在不同场景下需要保持一致质量的情况，但是消耗的带宽会有较大波动。适合用于视频存储，不适合网络传输。</p>
<p>ABR：平均码率，允许在整个视频序列中有一定的变化，但是在一个时间窗口内保持一定的平均码率。在此时间内，对简单、静态的图像分配低于平均码率的码率，对于复杂的、大量运动的图像分配高于平均码率的码流。码率分配比较均衡，比较适合网络传输。</p>
<p>CRF：恒定质量因子，追求的是恒定的视觉质量，编码器根据图像内容自动调整码率，以保持相对恒定的质量。适合于追求质量而不在乎码率的场景如视频剪辑和存档。</p>
<h2 id="openh264-码控">OpenH264 码控</h2>
<p>编码第一个 IDR 帧时使用固定的 QP，具体的值使用视频分辨率作为判断依据并查表得出并将其初始化为 initialQP：</p>
<p></p>
<p>将 QP 查表转换为 QStep 完成初始化：</p>
<p></p>
<p>之后进行 IDR 帧的量化及后续编码操作，并得到 frameDqBits（已编码的比特数），由此可以计算 intraCmplx：</p>
<p></p>
<p>对于第一个 PFrame，linearCmplx 也使用下面的公式计算，其中 QStep 使用 initialQP 查表。</p>
<p></p>
<p>之后计算 QStep&amp;QP 时就使用一阶 RQ 模型计算，frameComplexity 在预处理阶段得出。</p>
<p></p>
<h2 id="rtp">RTP</h2>
<p>RTP（Real-time Transport Protocol，实时传输协议）是一种应用层协议，通常基于 UDP 协议，但也支持 TCP 协议。</p>
<p>它提供了端到端的实时传输数据的功能，但不包含资源预留存 1（resource reservation）、不保证实时传输质量，这些功能都需要 WebRTC 自己实现。</p>
<p>RTP 协议分为两种子协议，分别是 RTP Data Transfer Protocol 和 RTP Control Protocol。</p>
<p>前者顾名思义，是用来传输实时数据的；后者则是我们常说的 RTCP 协议，可以提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包。</p>
<p>RT(D)P 包分为两部分，分别是 header 和 payload，header 包含了实时音视频的同步信息（和一些额外参数），payload 则承载了具体的音视频数据。这里我们只需要关注 header 结构就好，payload 是编解码器关心的。</p>
<p></p>
<p>如图所示，RT(D)P header 最小为 12 bytes；红色部分为可选字段。字段的含义分别如下：</p>
<ul>
<li>Version 表示 RTP 协议的版本，目前版本为 2。</li>
<li>P (Padding) 表示 RT(D)P 包末尾是否有 padding bytes，且 padding bytes 的最后一个 byte 表示 bytes 的数量。Padding 可以被用来填充数据块，比如加密算法可能会用到。</li>
<li>X (Extension) 表示是否有头部扩展，头部扩展可以用于存储信息，比如视频旋转角度。</li>
<li>CC (CSRC count) 表示红色部分的 CSRC（参见下文）数量，显然最多只能有 15 个 CSRC。</li>
<li>M (Marker) 表示当前数据是否与应用程序有某种特殊的相关性。比如传输的是一些私有数据，或者数据中的某些标志位具有特殊的作用。</li>
<li>PT (Payload type) 表示 payload 的数据类型，音视频的默认映射格式可参见 RFC 3551。</li>
<li>Sequence number 是递增的序列号，用于标记每一个被发送的 RT(D)P 包。接收方可以根据序列号按顺序重新组包，以及识别是否有丢包。序列号的初始值应当是随机的（不可预测的），从而增加明文攻击的难度。</li>
<li>Timestamp 即时间戳，接收方根据其来回放音视频。时间戳的间隔由传输的数据类型（或具体的应用场景）确定，比如音频通常以 125µs（8kHz）的时钟频率进行采样，而视频则以 90kHz 的时钟频率采样。这里时间戳的初始值也是随机选取的，是一种相对时间戳。</li>
<li>SSRC (Synchronization source) 即同步源标识符。相同 RTP 会话中的 SSRC 是唯一的，且生成的 SSRC 也需要保持随机。尽管多个源选中同一个标识符的概率很低，但具体实现时仍然需要这种情况发生，即避免碰撞。</li>
<li>CSRC (Contributing source) 在 MCU 混流时使用，表示混流出的新的音视频流的 SSRC 是由哪些源 SSRC 贡献的。根据上述 CC 得知，我们最多可以同时混 15 路音视频流。</li>
<li>Extension header 即头部扩展，包含了音视频的一些额外信息，比如视频旋转角度。</li>
</ul>
<h3 id="rtp-与-nalu-分组">RTP 与 NALU 分组</h3>
<p>RFC3984 给出了 3 中不同的 RTP 打包方案：</p>
<ol>
<li>Single NALU Packet：在一个 RTP 包中只封装一个 NALU，对于小于 1400 字节的 NALU 便采用这种打包方案。</li>
<li>Aggregation Packet：在一个 RTP 包中封装多个 NALU，对于较小的 NALU 可以采用这种打包方案，从而提高传输效率。</li>
<li>Fragmentation Unit：一个 NALU 封装在多个 RTP 包中，在本文中，对于大于 1400 字节的 NALU 便采用这种方案进行拆包处理。</li>
</ol>
<h2 id="rtcp">RTCP</h2>
<p>RTCP 协议提供实时传输过程中的统计信息，如网络延迟、丢包率等。</p>
<p>在传统的实时通讯过程中，RT(D)P 协议占用偶数位的端口，而 RTCP 协议占用随后的奇数位端口。</p>
<p>不过如果接收方的 SDP 中包含 rtcp-mux 字段 6，即表明接收方支持 RT(D)P 协议和 RTCP 协议共用同一个端口，即多路复用。在 Chrome 57 版本已经强制开启了 rtcp-mux 。</p>
<p>对于 RTCP 包而言，我们不只要关注 header 的结构，还要关注具体的 report block 内容。不过我们先来看一个典型的 RTCP header 结构，如下图所示：</p>
<p></p>
<p>RTCP header 的固定大小为 8 bytes，其中 Version、P、SSRC 的含义同上述 RTP header 相同，在此不与赘述。其他几个字段的含义分别如下：
RC (Reception report count) 表示当前 RTCP 包有几个 block，显然最多只能有 32 个。</p>
<ul>
<li>PT (Packet type) 表示 RTCP 包的类型，比如 SR=200、RR=201（SR、RR 参见下文）。</li>
<li>Length 等于整个 RTCP 包的长度减一（使得 Length = 0 是合法的），其值包含 header 的长度和所有 padding 占用的空间长度。值的单位是以 32 位字长（32-bit words）描述的。</li>
</ul>
<h2 id="psnrssimvmafbd-rate">PSNR/SSIM/VMAF/BD-Rate</h2>
<h3 id="psnr">PSNR</h3>
<p>峰值信噪比，基于均方误差（MSE）计算。</p>
<p>公式：</p>
<p>$$
PSNR = 10 \cdot log_{10}(\frac{MAX_I^2}{MSE})
$$</p>
<p>$$
MSE = \frac{1}{MN}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1}[I(i,j) - K(i,j)]^2
$$</p>
<p>对于用 8bit 表示的视频图像而言，MAX 就是 255</p>
<p>PSNR 的物理含义就是信号的峰值与平均误差的比值，如果误差越小，那么 PSNR 值越高。如果完全没有误差，那么 PSNR 值就是无穷大。</p>
<p>对于图像数据来说，通常有 Y、U、V 三个分量，可以对三个分量各自计算 PSNR。</p>
<p>也可以把三个分量的 PSNR 值以一定的权重加起来作为总的 PSNR 值。</p>
<p>对于整个视频来说，可以计算单帧的 PSNR 值，然后平均，也可以计算整个视频的 Overall PSNR。</p>
<ul>
<li>
<p>一般，psnr 值高于 40dB，表示画面质量极好，（非常接近于原始图像）；</p>
</li>
<li>
<p>psnr 值在 30dB-40dB 之间，表示画面质量较好（有失真但可接受）；</p>
</li>
<li>
<p>psnr 值在 20dB-30dB 之间，表示画面质量差；</p>
</li>
</ul>
<h3 id="ssim">SSIM</h3>
<p>PSNR 指标比较常用，但是不能体现编码前后图像之间的相关性，SSIM 可以从亮度，对比度和结构三个方面来描述编码前后图像之间的相似性。</p>
<ul>
<li>
<p>亮度维度的相似性用均值计算，𝝁𝒙为均值：</p>
<p></p>
</li>
<li>
<p>对比度维度的相似性用方差计算，𝝈𝒙 为方差：</p>
<p></p>
</li>
<li>
<p>结构维度的相似性用协方差计算， 𝝈𝒙𝒚 表示协方差：</p>
<p></p>
</li>
</ul>
<p>SSIM 指标和 SSIM 计算公式：</p>
<p></p>
<p>SSIM 性质：</p>
<p></p>
<h3 id="vmaf">VMAF</h3>
<p>VMAF 是一种 Full reference 的视频质量评估方法，适用于视频流媒体质量评估。</p>
<p>主要包括三种指标：视觉信息保真度 (VIF: visualquality fidelity) 、细节损失指标 (DLM: detail loss measure) 、时域运动指标/平均相关位置像素差 (Tl: temporal information) 。</p>
<ul>
<li>其中 VIF 和 DLM 是空间域的一个画面之内的特征。</li>
<li>TI 是时间域的，多个画面之间相关性的特征。</li>
</ul>
<p>这些特性之间融合计算总分的过程使用了训练好的 SVM 来预测。</p>
<p>VMAF 基于 SVM 的 nuSvr 算法，在运行的过程中，根据事先训练好的 model，赋予每种视频特征以不同的权重。对每一帧画面都生成一个评分。最终以均值算法进行汇总，算出该视频的最终评分</p>
<p>使用方式：</p>
<p>计算时需要保证编码后图像的分辨率与原始图像分辨率一致，如果不一致需要向上或者向下缩放编码图像，而不能缩放原始图像。</p>
<h3 id="bd-rate">BD-Rate</h3>
<p>比较两个编码器的 RD 曲线（Rate-Distortion）的差异：</p>
<ul>
<li>一种是相同质量下的码率差异，指标为 BD-Rate。</li>
<li>一种是相同码率下的质量差异，指标为 BD-PSNR。</li>
</ul>
<p>BD-Rate 是选取一个范围的的多个采样点（通常是 4 个），然后进行曲线拟合插值，最后计算出平均的指标差异。目前大部分测试数据的对比，都是基于 BDRate 指标的。</p>
<h2 id="视频封装">视频封装</h2>
<p>视频的封装格式定义的是多媒体数据的存储结构，包括如何组织和存储音频、视频、字幕、元数据等信息，以及怎么进行同步和时间标记。</p>
<p>感觉封装其实可以理解为是一个柜子，并且对柜子里的不同抽屉里面能存放哪些数据以及怎么存放数据做了规定。\</p>
<p>常见的封装格式有 Mp4、Mkv，微软的 AVI、苹果的 MOV、Adobe 的 FLV、Google 的 Webm。</p>
<p>不同的封装格式提供了一种统一的方式来存储和传输各种编码格式的多媒体数据。</p>
<p>H264 支持 AnnexB 和 AVCC 两种封装模式。</p>
<ul>
<li>
<p>AnnexB 模式是传统模式，有 startcode，SPS 和 PPS 在码流中分别作为一个 NALU。</p>
</li>
<li>
<p>AVCC 模式没有 startcode，SPS 和 PPS 以及其它信息被封装在 container 中，每个 frame 前面 4 个字节是这个 frame 的长度。一般在 mp4 和 mkv 中使用 AVCC。</p>
</li>
</ul>
<h2 id="硬件编码和软件编码">硬件编码和软件编码</h2>
<p>硬编码是通过专用的硬件编码器，比如 GPU 或者专用的视频编码芯片来进行的，硬件编码可以利用专为编码设计的电路从而提供更高的编码速度和更低的功耗，适用于实时性要求较高的应用比如云游戏、视频会议这些场景。硬编码也通常会在移动设备比如手机或者其他的专业视频设备中使用</p>
<p>软编码是通过通用的计算设备，一般来讲就是用 CPU 编码。软编码的性能和功耗一般来讲要比硬件编码差，但是可以跨平台运行，容易升级和更新，编码的画质也会更好。一般用于需要更大灵活性和可定制性的应用，比如短视频录制、非实时的转码等。</p>
<h2 id="码率和分辨率">码率和分辨率</h2>
<p>码率提高和分辨率提高都会增大视频的体积，两者之间需要平衡。</p>
<ul>
<li>
<p>在码率一定的情况下，提高分辨率可能会导致每个像素获得的比特数减少，从而降低整体感知质量。</p>
</li>
<li>
<p>在分辨率一定的情况下，提高码率可以分配更多的比特给每个像素，从而提高每个像素的清晰度。</p>
</li>
</ul>
<p>高分辨率主要是为了适应更大的屏幕尺寸，或者需要更多图像细节的任务。</p>
<p>其实屏幕尺寸和分辨率之间的关系有点类似于分辨率和码率之间的关系。</p>
<h2 id="一个视频文件能否倒放">一个视频文件能否倒放</h2>
<p>一个文件不行，至少需要两个文件才可以。</p>
<p>理论上方式有两种：</p>
<ul>
<li>
<p>第一种是先顺序解码视频到一个 yuv 文件中，然后倒序读入内存进行编码。</p>
</li>
<li>
<p>第二种是先遍历视频，获取一共有多少个 GOP，跳到最后一个 GOP 的 IDR 帧，对这个 GOP 进行解码输出到 yuv 文件中，再逆序读出这个解码之后的 yuv 文件然后编码，这样最后一个 GOP 就变成了第一个 GOP，按照从后往前的顺序依次类推就可以。</p>
</li>
</ul>
<p>第一种方式简单粗暴好实现，但是对于磁盘存储空间的要求比较高。</p>
<h2 id="h265hevc比-h264avc做了哪些改进">H265(HEVC)比 H264(AVC)做了哪些改进</h2>
<ul>
<li>
<p>H265 针对编码的各个环节都引入各自对应的单元。</p>
<ul>
<li>
<p>与 H264 中宏块类似的是，在 H.265 里面用的是一系列互不重叠的编码树单元 CTU 处理信息，CTU 内部可以以四叉树结构递归向下划分成更小的正方形编码单元 CU。CU 可以支持最大 64x64 的尺寸，因而可以对高分辨率视频中的平坦和复杂区域做有针对性的 CTU 划分。</p>
</li>
<li>
<p>预测单元 PU 是定义在 CU 上的一个矩形区域，用来存储和预测相关的所有信息如帧内预测方向、帧间预测的参考帧、和 MV 等。</p>
</li>
<li>
<p>变换单元 TU 是变换和量化的基本单位，支持 4 种正方形的尺寸大小(4/8/16/32)。变换时采用 RQT 技术，基于四叉树结构进行自适应变换。大块的 TU 模式能够将能量更好地集中，小块的 TU 模式能够保存更多的图像细节。根据当前 CU 内残差特性，自适应选择变换块大小，可以在能量集中和细节保留两者做最优的折中。与传统的固定块大小变换相比，RQT 对编码效率贡献更大。</p>
</li>
<li>
<p>CU 划分成 PU 和 TU，PU 和 TU 之间存在交叉重叠关系，Inter 预测时允许 CU 内的 TU 跨越 PU 边界，Intra 预测时，TU 不能跨越 PU 边界。</p>
</li>
</ul>
</li>
<li>
<p>在帧内预测模块，H265 支持更多的帧内预测模式。H265 的亮度分量支持 35 种帧内预测模式包括平面模式、DC 模式和 33 种角度模式，色度分量有 5 种帧内预测模式包括平面模式、DC 模式、水平、垂直方向模式和对应于亮度分量的帧内预测模式。</p>
</li>
<li>
<p>在帧间预测模块，H265 引入了更加复杂的 ME 方式，主要包括 Merge 和 AMPV 以及基于 Merge 的 Skip 模式。</p>
<ul>
<li>Merge：取相邻 PU 的运动参数作为当前 PU 的运动参数（利用空域相关性和时域相关性）</li>
<li>AMVP 得到的 MV 一方面为 ME 提供了搜索起点，另一方面也用于预测 MV。AMVP 根据周围块预测 MV，MV=MVP+MVD(矢量差值)</li>
</ul>
</li>
<li>
<p>H265 把变换和量化模块结合了起来，降低了计算复杂度，支持加权量化矩阵。</p>
</li>
<li>
<p>在环路滤波模块，H265 新增了采样点自适应偏移滤波 SAO，通过解析去方块滤波后的像素的统计特性，为像素添加相应的偏移值，削弱振铃效应。</p>
</li>
<li>
<p>因为 H265 的解码要比 h264 的解码复杂很多，所以提供了很多可以并行优化的思路。</p>
</li>
</ul>
<h2 id="simd">SIMD</h2>
<p>SIMD 是一种并行计算技术，允许单一指令处理多个数据元素。SIMD 指令集通常由处理器提供，用于加速向量化计算。视频编码中，SIMD 可以用于加速压缩和解压算法。</p>
<h2 id="h264-中的差错控制">H264 中的差错控制</h2>
<p>Slice 分割、Data Partition (DPA &gt; DPB &gt; DPC)、对 SPS 和 PPS 提供使用高传输优先级、差异化的熵编码（对重要的 SPS 和 PPS 采用指数哥伦布编码）</p>
<p>FMO 通过宏块分配映射把同一帧里的不同宏块划分到不同的 Slice Group 里，在同一个 Slice Group 里的 MB 按照普通的光栅扫描顺序编码。</p>
<p>因为不管是 Intra Coding 还是 Inter Coding 都必须使用同一个 Slice group 的宏块数据，这样当一个 Slice group 里的某一个或者某几个宏块发生错误时候，因为相邻的宏块可能分布在不同的 Slice group，就可以从其他正确接收的 Slice group 里拿到和丢失宏块相邻的宏块信息来进行错误掩盖。</p>
<h2 id="svc">SVC</h2>
<p>SVC：(Scalable Video Coding)可伸缩视频编码，编码器产生的码流包含一个或者多个子码流或者层，子码流可以有不同的码流、帧率和分辨率。基本层编码最低层的时域、空域和质量流；增强层以基本层作为起始点，对附加信息进行，从而在解码过程中重构更高层的质量、分辨率和时域层。通过解码基本层和相邻增强层，解码器能生成特定层的视频流。</p>
<ul>
<li>
<p>时域分层：从码流中提取出有不同帧频的码流。</p>
</li>
<li>
<p>空域分层：从码流中提取出有不同分辨率的码流。</p>
</li>
<li>
<p>质量分层：从码流中提取出有不同质量的码流。</p>
</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<p>监控：监控视频流产生两路，一路质量好的用于存储，一路低码率的用于预览。</p>
<p>视频会议：会议终端利用 SVC 编出多种分辨率、分层质量的码流，会议中心替代传统的 MCU 二次编解码方法改成视频路由分解转发。也可以在丢包环境下利用时域分级，抛弃一些时域级别实现网络适应性。</p>
<p>流媒体 IPTV：服务器可以根据不同的网络情况丢弃质量层，保证视频的流畅。兼容不同网络环境和终端。</p>
<h3 id="优缺点">优缺点</h3>
<p>优点：分级码流优点是应用非常灵活，因为能根据需要产生不同的码流或者提取出不同的码流。使用 SVC 实现一次分层编码比用 AVC 编多次更高效。
SFU 从发布客户端复制音视频流的信息，然后分发到多个订阅客户端。典型的应用场景是 1 对多的直播服务。SFU 是解决服务端性能问题的好方法，因为它不涉及视频解码和编码的计算费用，用最低的开销来转发各路媒体流，能实现海量的客户端接入。重终端，轻平台。</p>
<p>缺点：因为 SVC 解码控制复杂不利于流式处理，硬件编解码器支持差，协议协商细节复杂，业界标准不统一。</p>
<h2 id="rtc-应用中提高实时性">RTC 应用中提高实时性</h2>
<p>因为编码主要的时间开销在运动预测过程中，如果在云游戏的场景下，可以得到游戏画面中物体的运动信息然后考虑用来辅助运动预测，或者说对搜索过程进行剪枝。</p>
]]></description>
</item>
<item>
    <title>远程桌面与WebRTC</title>
    <link>http://localhost:1313/posts/knowledge/webrtc/remote-desktop-with-webrtc/</link>
    <pubDate>Thu, 15 Jun 2023 18:21:02 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>http://localhost:1313/posts/knowledge/webrtc/remote-desktop-with-webrtc/</guid>
    <description><![CDATA[<h1 id="关于远程桌面">关于远程桌面</h1>
<p>远程桌面是一种将一台计算机的桌面控制权限交给网络上另一台计算机的技术，两台计算机之间建立连接之后，可以进行音视频以及控制信令的相互传输，从而实现远程控制的功能。</p>
<h1 id="远程桌面技术的实现">远程桌面技术的实现</h1>
<p>基于远程桌面要完成的任务目标，其需要实现以下两个核心功能：</p>
<ol>
<li>音视频的传输，即需要让控制机收到受控机的音频跟视频。</li>
<li>控制信令的传输，即鼠标键盘的控制信号等</li>
</ol>
<p>目前主流的远程桌面技术主要有 2 种：</p>
<ol>
<li>基于<a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing" target="_blank" rel="noopener noreffer">VNC(Virtual Network Computing)</a>的远程桌面技术</li>
<li>基于<a href="https://en.wikipedia.org/wiki/Remote_Desktop_Protocol" target="_blank" rel="noopener noreffer">RDP(Remote Desktop Protocol)</a>的远程桌面技术</li>
</ol>
<h2 id="vnc">VNC</h2>
<p>VNC 使用远程帧缓冲协议即(RFB, Remote FrameBuffer)来远程控制另一台计算机，将控制机的键盘和鼠标事件传输到被控制机，同时将被控制机的屏幕图像传输到控制机。</p>
<p>基于其技术原理，VNC 有以下优点：</p>
<ol>
<li>跨平台，可以在不同的操作系统上运行，VNC 技术本身也有多个客户端和服务端的实现版本，如 RealVNC、TightVNC、UltraVNC 等</li>
<li>开源，VNC 的源代码及其很多现代衍生品都是在 GNU 许可证之下发布的</li>
<li>轻量级，VNC 的客户端和服务端都是非常轻量级的程序，可以在低配置的计算机上运行</li>
</ol>
<p>但因为 VNC 本身的设计时间很早，因此在 2023 年的今天暴露出了很多的时代局限性：</p>
<ol>
<li>因为其基于像素方块的传输原理，就算是采用部分更新传输的方式，在大量像素变化的情况下会消耗大量的带宽。特别是对于现在的高分屏，其传输的数据量会更大。</li>
<li>VNC 在设计之初被用于局域网内使用，因此没有考虑太多的安全性，虽然密码并不以明文发送，但是如果从网络中嗅探出加密密钥和编码之后的密码，也可能成功破解出密码。</li>
</ol>
<h2 id="rdp">RDP</h2>
<p>RDP 是<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/remote/understanding-remote-desktop-protocol" target="_blank" rel="noopener noreffer">微软提出的一种专有协议</a>，扩展了 T-120 系列协议标准，最早专用于 Windows 系统的终端和服务器之间的远程桌面连接，之后微软也实现了<a href="https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-mac" target="_blank" rel="noopener noreffer">RDP 的 MacOS 客户端</a>，现在也有很多第三方的实现版本实现了其功能的子集，为 GNU/Linux 做了适配如<a href="https://github.com/neutrinolabs/xrdp" target="_blank" rel="noopener noreffer">xrdp</a>。因此，可以说 RDP 也一定程度上具有跨平台的性质。</p>
<p>相比于 VNC，RDP 的实现原理还是比较复杂的：</p>
<p></p>
<p>首先，RDP 的最底层是 TCP，TCP 之上是各层的协议和服务。</p>
<ul>
<li>TPKT：是 TCP 之上的 ISO 传输服务，允许两个组交换 TPDU（传输协议数据单元）或 PDU（协议数据单元）的信息单元。</li>
<li>X.224：连接传输协议，主要用于 RDP 初始连接请求和响应。</li>
<li>T.125 MCS：多点通信服务，允许 RDP 通过多个通道进行通信和管理。</li>
</ul>
<p>RDP 的工作原理是通过 TPKT 实现信息单元的交换，通过 X.224 建立连接，使用 T.125 MCS 打开两个通道来完成两个设备之间的来回数据传输。</p>
<p>RDP 的特点功能比较丰富，比如：</p>
<ul>
<li>支持共享剪切板。</li>
<li>支持多个显示器。</li>
<li>支持虚拟化 GPU。</li>
<li>支持 32 位彩色和 64000 个独立的数据传输通道。</li>
<li>通过 RC4 对称加密算法使用 128 位密钥对数据进行加密。</li>
<li>可以在使用远程计算机时参考本地计算机上的文件系统。</li>
<li>远程计算机的应用程序可以在本地计算机上运行。</li>
</ul>
<p>当然，事物都有两面性，RDP 拥有这么多强大功能，也有一些难以避免的缺点：</p>
<ul>
<li>网络速度较慢时，远程连接容易出现延迟。</li>
<li>两台计算机在不同的网络上时，其配置过程相当复杂。</li>
<li>固定使用 3389 端口监听，可能成为攻击的目标。</li>
<li>RDP 整体上还是受到微软控制，定制性比较差。</li>
</ul>
<h1 id="webrtc-和远程桌面">WebRTC 和远程桌面</h1>
<p>远程桌面的核心需求和 WebRTC 的核心功能完美契合。</p>
<ul>
<li>WebRTC 基于 ICE/STUN/TURN 的 NAT 穿透方案可以很方便地解决不同网络情况下主机连接的问题，</li>
<li>WebRTC 基于 SRTP 的传输方式天然提供了实时特征、端到端的加密的数据传输服务。</li>
<li>WebRTC 针对各种网络情况做了音视频传输的大量优化，可以保证各种网络条件下的可用性。</li>
<li>WebRTC 本身其实是 Chromium 浏览器的一部分，天然具备跨平台的性质。</li>
<li>WebRTC 完全开源，定制性极强，不少公司都基于 WebRTC 来做自家的直播、云游戏业务。</li>
</ul>
<p>整体上来讲，WebRTC 的优势使其很适合用于远程桌面业务，当然，目前市面上已经有 App 基于 WebRTC 实现了远程桌面的功能，比如<a href="https://en.wikipedia.org/wiki/Chrome_Remote_Desktop" target="_blank" rel="noopener noreffer">Chrome Remote Desktop</a>和<a href="https://www.todesk.com/" target="_blank" rel="noopener noreffer">ToDesk</a>。前者可以理解为是 Google 用自己 WebRTC 推出的远程桌面服务，体验了一下，整体上功能比较少，但是连接比较稳定，不过受 GFW 影响，这玩意在国内应该是处于没法用的状态；后者则是国产远程桌面软件，目前已经比较成熟，提供了企业版、个人版、专业版和游戏版四个版本，从其官网上提供的信息来看，应该是做出了一定成绩。</p>
<p>从技术上讲，基于 WebRTC 开发远程桌面应用相当合理，开源可控，还有谷歌背书，WebRTC 本身在不停地与时俱进，作为上层应用开发的远程桌面也可以及时享受到 WebRTC 带来的改进。</p>
<p>从业务上讲，WebRTC 本身具有的功能可以解决上面所说的 VNC 和 RDP 的诸多问题，不过就功能的丰富性而言，可能跟微软的 RDP 还差一些，但是 WebRTC 基于音视频的解决方案本身可以优化的上限还是挺高的，毕竟随着人们需求的上升，高分辨率、高帧率也会成为未来远程桌面应用必不可少的功能需求。</p>
<p>本篇博客从非技术层面探讨了远程桌面技术的当下两大主流技术，以及 WebRTC 应用于远程桌面业务下的可行性。下篇博客将从技术层面详细分析 WebRTC 与远程桌面业务的契合程度及可能的解决方案，就先从核心功能开始吧！</p>
]]></description>
</item>
</channel>
</rss>
