<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/</link>
        <description>Welcome to Ayamir&#39;s blog.</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Thu, 16 Dec 2021 19:53:10 &#43;0800</lastBuildDate>
            <atom:link href="https://ayamir.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Note for RnnQoE</title>
    <link>https://ayamir.github.io/2021/12/note-for-rnnqoe/</link>
    <pubDate>Thu, 16 Dec 2021 19:53:10 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/12/note-for-rnnqoe/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p>Link：<a href="https://ieeexplore.ieee.org/document/9580281" target="_blank" rel="noopener noreffer">QoE-driven Mobile 360 Video Streaming: Predictive
View Generation and Dynamic Tile Selection</a></p>
<p>Level：ICCC 2021</p>
<p>Keywords：QoE maximization，Trajectory-based viewport prediction，Dynamic tile selection</p>
]]></description>
</item>
<item>
    <title>Note for OpTile</title>
    <link>https://ayamir.github.io/2021/12/note-for-optile/</link>
    <pubDate>Mon, 13 Dec 2021 16:19:02 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/12/note-for-optile/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p>Link：<a href="https://dl.acm.org/doi/10.1145/3123266.3123339" target="_blank" rel="noopener noreffer">OpTile: Toward Optimal Tiling in 360-degree Video Streaming</a></p>
<p>Level：ACM MM 17</p>
<p>Keyword：Dynamic tile division, Optimize encoding efficiency, Optimize tile size</p>
<h2 id="背景知识">背景知识</h2>
<h3 id="编码过程概述">编码过程概述</h3>
<ol>
<li>
<p>对一帧图像中的每一个 block，编码算法在当前帧的已解码部分或由解码器缓冲的临近的帧中搜索类似的 block。</p>
<p>当编码器在邻近的帧中找到一个 block 与当前 block 紧密匹配时，它会将这个类似的 block 编码进一个动作向量中。</p>
</li>
<li>
<p>编码器计算当前 block 和引用 block 之间像素点的差异，通过应用变换（如离散余弦变换），量化变换系数以及对剩余稀疏矩阵系数集应用无损熵编码（如 Huffman 编码）对计算出的差异进行编码。</p>
</li>
</ol>
<h3 id="对编码过程的影响">对编码过程的影响</h3>
<ol>
<li>基于 tile 的方式会减少可用于拷贝的 block 数量，增大了可供匹配的 tile 之间的距离。</li>
<li>不同的投影方式会影响编码变换输出的系数稀疏性，而这会降低视频编码效率。</li>
</ol>
<h3 id="投影过程">投影过程</h3>
<p>因为直接对 360 度图像和视频的编码技术还没有成熟，所以 360 度推流系统目前还需要先将 3D 球面投影到 2D 平面上。</p>
<p>目前应用最广的投影技术主要是 ERP 和 CMP，分别被 YouTube 和 Meta 采用。</p>
<h4 id="erp-投影">ERP 投影</h4>
<p>基于球面上点的左右偏航角$\theta$与上下俯仰角$\phi$将其映射到宽高分别为$W$和$H$的矩形上。</p>
<p>对于平面坐标为$(x, y)$的点，其球面坐标分别为：</p>
<p>$$
\theta = (\frac{x}{W} - 0.5) * 360
$$</p>
<p>$$
\phi = (0.5 - \frac{y}{H}) * 180
$$</p>
<h4 id="cmp-投影">CMP 投影</h4>
<p>将球面置于一个立方体中，光线从球心向外发射，并分别与球面和立方体相交于两点，这两点之间便建立了映射关系。</p>
<p>之后将立方体 6 个平面拼接成矩形，就可以使用标准的视频编码方式进行压缩。</p>
<p>关于投影方式还可以参考这里的讲解：<a href="https://zhuanlan.zhihu.com/p/106922217" target="_blank" rel="noopener noreffer">谈谈全景视频投影方式</a></p>
<h3 id="tile-方式的缺点">tile 方式的缺点</h3>
<ul>
<li>
<p>降低编码效率</p>
<p>tile 划分越细，编码越低效</p>
</li>
<li>
<p>增加更大的整体存储需求</p>
</li>
<li>
<p>可能要求更多的带宽</p>
</li>
</ul>
<h2 id="optile-的设计">OpTile 的设计</h2>
<p>直觉上需要增大一些 tile 的大小来使与这些 tile 相关联的片段能捕获高效编码所需的类似块。</p>
<p>同时也需要 tile 来分割视频帧来减少传输过程中造成的带宽浪费。</p>
<ul>
<li>
<p>为了明白哪些片段的空间部分可以被高效独立编码，需要关于 tile 的存储大小的不同维度的信息。</p>
</li>
<li>
<p>为了找到切分视频的最好位置，需要在片段播放过程中用户 viewport 运动轨迹的偏好。</p>
</li>
</ul>
<p>将编码效率和浪费数据的竞争考虑到同一个问题之中，这个问题关注的是<strong>一个片段中所有可能的视图的分布</strong>。</p>
<p>片段的每个可能的视图可以被 tile 的不同组合所覆盖。</p>
<p>目标是为一个片段选择一个 tile 覆盖层，以<strong>最小化固定时间段内视图分布的总传输带宽</strong>。</p>
<ul>
<li>目标分离的部分考虑整个固定时间段的表示（representation）的存储开销。</li>
<li>目标的存储部分与下载的带宽部分相竞争。例如，如果一个不受欢迎的视频一年只观看一次，那么我们更喜欢一个紧凑的表示，我们可以期望向用户发送更多未观看的像素。</li>
</ul>
<h2 id="问题形式化">问题形式化</h2>
<table>
<thead>
<tr>
<th style="text-align:center">segment/片段</th>
<th style="text-align:center">推流过程中可以被下载的连续播放的视频单元</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">basic sub-rectangle/基本子矩形</td>
<td style="text-align:center">推流过程中可以被下载的片段中最小的空间划分块</td>
</tr>
<tr>
<td style="text-align:center">solution sub-rectangle/解子矩形</td>
<td style="text-align:center">片段中由若干基本子矩形组成的任何矩形部分</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center">用于表示子矩形在解中的存在的二元向量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$c^{(stor)}$</td>
<td style="text-align:center">每个子矩形存储开销相关的向量</td>
</tr>
<tr>
<td style="text-align:center">$c^{(view)}$</td>
<td style="text-align:center">给定一个 segment 中用户 viewport 的分布，$c^{(view)}$指相关子矩形的预期下载字节</td>
</tr>
<tr>
<td style="text-align:center">$\alpha$</td>
<td style="text-align:center">分配到$c^{(view)}$的权重，以此来控制相对于传输一个片段的存储开销</td>
</tr>
</tbody>
</table>
<p>考虑将 1 个矩形片段划分成 4 个基本子矩形，其对应的坐标如下：</p>
<p></p>
<p>4 个基本子矩形可以有 9 种分配方式，成为解子矩形，如下（因为需要保持对应的空间关系，所以只有 9 种）：</p>
<p></p>
<ul>
<li>
<p>$x$的形式化</p>
<p>可以用向量$x$来分别表示上图中子矩形在解中的存在：</p>
<p>$$
[1 \times 1\ at\ (0, 0),\ 1 \times 1\ at\ (0, 1),\ 1 \times 1\ at\ (1, 0),
\
1 \times 1\ at\ (1, 1),\ 1 \times 2\ at\ (0, 0),\ 1 \times 2\ at\ (1, 0),
\
2 \times 1\ at\ (0, 0),\ 2 \times 1\ at\ (0,1),\ 2 \times 2\ at\ (0,0).]
$$</p>
<p>（$x$中每个二元变量的的组成：$1 \times 1$表示子矩形的形状，$(0,0)$表示所处的位置）</p>
<p>要使$x$有效，<strong>每个基本子矩形必须被$x$中编码的子矩形精确覆盖一次</strong>。例如：</p>
<ul>
<li>
<p>$[0, 0, 0, 0, 1, 1, 0, 0, 0]$=&gt;有效（第 5 和第 6 次序的位置分别对应$e$和$f$子矩形，恰好覆盖了所有基本子矩形 1 次）</p>
</li>
<li>
<p>$[0,0,0,1,1,0,0,0,0]$=&gt;无效（第 4 和第 5 次序的位置分别对应$d$和$e$子矩形，没有覆盖到$(1,0)$基本子矩形）</p>
</li>
<li>
<p>$[0,0,0,1,1,1,0,0,0]$=&gt;无效（第 4、第 5 和第 6 次序的位置分别对应$d$、$e$和$f$子矩形，$(1,1)$基本子矩形被覆盖了两次）</p>
</li>
</ul>
</li>
<li>
<p>$c^{(stor)}$的形式化</p>
<p>与每个$x$相对应的向量$c^{(stor)}$长度与$x$相等，其中每个元素是$x$中对应位置的子矩形的存储开销的估计值。</p>
</li>
<li>
<p>$c^{(view)}$的形式化</p>
<p>考虑分发子矩形的网络带宽开销时，需要考虑所有可能被分发的 360 度表面的视图。</p>
<p>为了简化问题，将片段所有可能的视图离散化到一个大小为$V$的集合中。</p>
<p>集合中每个元素表示一个<strong>事件</strong>，即向观看 360 度视频片段的用户显示基本子矩形的唯一子集。</p>
<p>注意到片段中被看到的视频区域可以包含来自多个视角的区域。</p>
<p>将之前离散化好的大小为$V$的集合中每个元素与可能性相关联：$[p_1, p_2, &hellip;, p_V]$。</p>
<p>考虑为给定的解下载视图$V$的开销，作为需要为该视图下载的数据量：</p>
<p>$$
quantity = x^{\top}diag(d_v)c^{(stor)}
$$</p>
<p>$d_v$是一个二元向量，其内容是按照$x$所描述的表示方案，对所有覆盖视图的子矩形的选择。</p>
<p>例如对于 ERP 投影中位置坐标为$yaw = 0, pitch = 90$即处于等矩形顶部的图像，对应的$d_{view-(0, 90)} = [1, 1, 0, 0, 1, 0, 1, 1, 1]$</p>
<p>（即上面图中$a, b, e, g, h, i$位置的子矩形包含此视图所需的基本子矩形）。</p>
<p>给出一个片段中的用户 viewport 分布，$c^{(view)}$的元素是相关联的子矩形预期的下载字节。</p>
<p>$$
c^{(view)} = \sum_v p_v diag(d_v) c^{(stor)}
$$</p>
<p>最后，将优化问题的基本子矩形覆盖约束编码为矩阵$A$。</p>
<p>$A$是一个列中包含给定子矩形解所覆盖的基本子矩形信息的二元矩阵。</p>
<p>对于$2 \times 2$的矩形片段，其$A$有 4 行 9 列，例子如下：</p>
<p></p>
<p>因此最终的问题可以形式化为一个整数线性程序：</p>
<p></p>
<ul>
<li>
<p>$c^{(stor)}$</p>
<p>可以理解为存储一段$\Delta t$时间长的片段的子矩形的存储开销；</p>
</li>
<li>
<p>$c^{(view)}$</p>
<p>可以理解为传输一个视图所需要的所有的子矩形的传输开销。</p>
</li>
<li>
<p>$\alpha$</p>
<p>控制相比于传输一个片段的相对存储开销，同时应该考虑片段的流行度。</p>
<p>即$\alpha$应该与所期望的片段在$\Delta t$的时间间隔内的下载次数成比例，$\alpha$应该可以通过经验测量以合理的精度进行估计。</p>
<p>可以通过将$x$的二元离散限制放松到$0 \le x_i \le 1\ \forall i$构成一个线性程序，其解为整数。</p>
<p>（对于有 33516 个变量的$x$，其解可以在单核 CPU 上用 7~10 秒求出）</p>
</li>
</ul>
</li>
</ul>
<h2 id="开销向量建构">开销向量建构</h2>
<p>首先需要建构出存储开销向量$c^{(stor)}$，但是对于有$n$个基本子矩形的子矩形，其建构复杂度为$O(n^2)$。</p>
<p>因此对每个子矩形进行编码来获得存储开销并不可行，所以利用视频压缩与运动估计之间的强相关性来预测$c^{(stor)}$的值。</p>
<ol>
<li>
<p>给定一个视频，首先暂时将其分成长度为 1 秒的片段，每个片段被限定为只拥有 1 个 GOP，片段的大小表示为$S_{orig}$。</p>
</li>
<li>
<p>接着抽取出每个片段中的动作序列用于之后的分析。</p>
</li>
<li>
<p>将片段从空间上划分成基本子矩形，每个基本子矩形包含$4 \times 4 = 16$个宏块（例如：$64 \times 64$个像素点）。</p>
</li>
<li>
<p>独立编码每个基本子矩形，其大小表示为$S_i$。</p>
</li>
<li>
<p>通过分析动作向量信息，可以推断出如果对基本子矩形$i$进行独立编码，指向基本子矩形$i$的原始运动向量应该重新定位多少。</p>
<p>将其表示为$r_i$。</p>
</li>
<li>
<p>每个运动向量的存储开销可以计算为：</p>
<p>$$
o = \frac{\sum_i S_i - S_{orig}}{\sum_i r_i}
$$</p>
<p>即：存储开销的整体增长除以被基本子矩形边界所分割的运动向量数。</p>
</li>
<li>
<p>如果基本子矩形被融合进更大的子矩形$t$，使用$m_t$来表示由于融合操作而无须再进行重定位的运动向量的数量：</p>
<p>$$
m_t = \sum_{i \in t} r_i - r_t
$$</p>
<p>$i \in t$表示基本子矩形位于子矩形$t$中。</p>
</li>
<li>
<p>为了估计任意子矩形$t$的大小，使用下面 5 个参数：
$$
\sum_{i \in t} S_i,\ \sum_{i \in t} r_i,\ m_t,\ o,\ n
$$
$n$表示$t$中基本子矩形的数量。</p>
</li>
</ol>
<p>实际操作：</p>
<ol>
<li>
<p>创建了来自 4 个单视角 360 度视频的 6082 个 tile 数据集。4 个视频都以两种分辨率进行编码：$1920 \times 960$和$3980 \times 1920$。</p>
</li>
<li>
<p>为了产生 tile，从视频中随机选取片段，随机选取 tile 的位置，宽度和高度。</p>
<p>设置 tile 的 size 最大为$12 \times 12$个基本子矩形。</p>
<p>对于每个选择的 tile，为其建构一个数据集元素：</p>
<ol>
<li>计算上面提到的 5 参数的特性向量。</li>
<li>使用 FFmpeg 编码 tile 的视频段来得到存储该段需要的空间。</li>
</ol>
</li>
<li>
<p>使用多层感知机 MLP 来估计 tile 的大小。</p>
<p>MLP 中包含 50 个节点的单隐层，激活函数为 ReLU 函数，300 次迭代的训练过程使用<a href="https://zhuanlan.zhihu.com/p/29672873" target="_blank" rel="noopener noreffer">L-BFGS 算法</a>。</p>
<p>为了评估 MLP 的预测效果，使用 4 折的交叉验证法。</p>
<p>每次折叠时先从 3 个视频训练 MLP，接着使用训练好的模型去预测第 4 个视频的 tile 大小。</p>
</li>
</ol>
<h2 id="实现">实现</h2>
<p></p>
<p>将视频划分成1秒长的片段，之后为每个片段解决整数线性问题来确定最优的tile划分策略。</p>
<ol>
<li>使用MLP模型估计每个tile的存储开销。</li>
<li>根据视图的集合$d$及其对应的可能性分布$p$，来估计视图的下载开销$c^{(view)}$。</li>
<li>构造矩阵$A$时，限制最大的tile大小为$12 \times 12$的基本子矩形（如果设置每个基本子矩形包含$64 \times 64$的像素，tile的最大尺寸即为$768 \times 768$的像素）。</li>
<li>使用<a href="https://www.gnu.org/software/glpk/" target="_blank" rel="noopener noreffer">GNU Linear Programming Kit</a>来解决问题。</li>
<li>将所有可能的解子矩形编码进一个二元向量$x$中来表示解。</li>
<li>GLPK的解表明一个可能的解子矩形是否应该被放入解中。</li>
<li>基于最终得到的解，划分片段并使用ffmepg以同样参数的x264格式进行编码。</li>
</ol>
<h2 id="评估">评估</h2>
<ul>
<li>
<p>度量指标</p>
<ol>
<li>服务端存储需求。</li>
<li>客户端需要下载的字节数。</li>
</ol>
</li>
<li>
<p>数据来源</p>
<p>数据集：<a href="http://dash.ipv6.enstb.fr/headMovements/" target="_blank" rel="noopener noreffer">dash.ipv6.enstb.fr</a></p>
</li>
<li>
<p>评估准备</p>
<p>下载5个使用ERP投影的视频，抽取出测试中用户看到的对应部分。</p>
<p>每个视频都有$1920 \times 960$和$3840 \times 1920$的两种分辨率的版本。</p>
<p>$1920 \times 960$视频的基本子矩形尺寸为$64 \times 64$的像素。</p>
<p>$3840 \times 1920$视频的基本子矩形尺寸为$128 \times 128$的像素。</p>
<p>将视频划分成1秒长的片段，对每个片段都产生出MLP所需的5元组特性。</p>
<p>之后使用训练好的MLP模型来预测所有可能的tile的大小。</p>
</li>
<li>
<p>数据选择</p>
<ol>
<li>
<p>从数据集中随机选择出40个用户的集合。</p>
</li>
<li>
<p>假设100°的水平和垂直FOV，并使用40个用户的头部方向来为每个片段产生$p_v$和$d_v$。</p>
<p>即：分块的决策基于每个片段的内容特征信息与用户的经验视图模式。</p>
</li>
</ol>
</li>
<li>
<p>参数设定：$\alpha = 0,1,1000$.</p>
</li>
<li>
<p>对比实验：</p>
<p>一组使用由ILP得出的结构进行分块；</p>
<p>另外一组：</p>
<ul>
<li>
<p>$1920 \times 960$的视频片段分别使用$64 \times 64$，$128 \times 128$，$256 \times 256$，$512 \times 512$的方案固定大小分块。</p>
</li>
<li>
<p>$3840 \times 1920$的视频片段分别使用$128 \times 128$，$256 \times 256$，$512 \times 512$，$1024 \times 1024$的方案固定大小分块。</p>
</li>
</ul>
</li>
<li>
<p>划分结果对比</p>
<p></p>
</li>
</ul>
<h3 id="服务端的存储大小">服务端的存储大小</h3>
<p></p>
<p>按照$\alpha = 0$方案分块之后的视频大小几乎与未分块之前的视频大小持平，有时甚至略微小于未分块前的视频大小。</p>
<p>因为所有分块方案都使用相同的编码参数，所以重新编码带来的有损压缩并不会影响竞争的公平性。</p>
<p>如果将$\alpha$的值调大，存储的大小会略微增大；固定分块大小的方案所得到的存储大小也会随tile变小而变大。</p>
<h3 id="客户端的下载大小">客户端的下载大小</h3>
<ul>
<li>
<p>预测完美的情况——下载的tile没有任何浪费</p>
<p></p>
<p>$\alpha= 1000$的情况下，OpTile的表现总是最好的。</p>
</li>
<li>
<p>正常预测的情况</p>
<p>预测的方法：假设用户的头部方向不会改变，预测的位置即为按照当前方向几秒之后的位置。</p>
<p></p>
<p>相比于完美假设的预测，所有分块方案的下载大小都增大了。</p>
<p>$\alpha = 1000$的方案在两个视频的情况下都取得了最小的下载大小。在剩下的3个视频中，OpTile方案的下载大小比起最优的固定分块大小方案不超过25%。</p>
<p>尽管固定分块大小的方案可能表现更好，但是这种表现随视频的改变而变化显著。</p>
<p><strong>因为固定分块的方案没有考虑视频内容的特性与用户的观看行为。</strong></p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>多媒体基础知识</title>
    <link>https://ayamir.github.io/2021/12/mm-base/</link>
    <pubDate>Mon, 13 Dec 2021 10:03:17 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/12/mm-base/</guid>
    <description><![CDATA[<h1 id="媒体处理过程">媒体处理过程</h1>
<p></p>
<h2 id="解协议">解协议</h2>
<p>将流媒体传输方案中要求的数据解析为标准的相应封装格式数据。</p>
<p>音视频在网络中传播时需要遵守对应的传输方案所要求的格式，如DASH、HLS将媒体内容分解成一系列小片段，每个片段有不同的备用码率版本。</p>
<p>同时应用层的协议会要求在媒体文件本身之外，传输信令数据（如对播放的控制或网络状态的描述）</p>
<p>解协议的过程会去除信令数据并保留音视频内容，需要的话还要对视频段进行拼接，最终将其还原成传输之前的媒体格式如MP4，FLV等。</p>
<h2 id="封装格式">封装格式</h2>
<p>封装格式如AVI、MPEG、Real Video将音频和视频组合打包成一个完整的文件.</p>
<p>封装格式不会影响视频的画质，影响画质的是视频的编码格式。</p>
<p>解封装过程就是将打包好的封装格式分离成某种编码的音频压缩文件和视频压缩文件，有时也包含字幕和脚本。</p>
<p>比如FLV或TS格式数据，解封装之后得到H.264-AVC编码的视频码流和AAC编码的音频码流。</p>
<h2 id="编码">编码</h2>
<p>视频的本质是一帧又一帧的图片。</p>
<p>所以对于一部每秒30帧，90分钟，分辨率为1920x1080，24位的真彩色的视频，在压缩之前的大小$S$满足：
$$
一帧大小s = 1920 * 1080 * 24 = 49766400(bit) = 6220800(Byte)
\
总帧数n = 90 * 60 * 30 = 162000
\
总大小S = s * n = 6220800 * 162000 = 1.0077696*10^{12}(Byte) \approx 939(GB)
$$
因为未经压缩的视频体积过于庞大，所以需要对其进行压缩，而压缩就是通常所说的编码。</p>
<p>视频编码方式：H.264-AVC，H.265-HEVC，H.266-VVC</p>
<p>音频编码方式：MP3，AAC</p>
<p>压缩比越大，解压还原之后播放的视频越失真，因为压缩过程中不可避免地丢失了视频中原有图像的数据信息。</p>
<h2 id="解码">解码</h2>
<p>解码就是解压缩过程。</p>
<p>解码之后能够得到系统音频驱动和视频驱动能识别的音频采样数据（如PCM数据）和视频像素数据（如YUV420，RGB数据）。</p>
<h2 id="音视频同步">音视频同步</h2>
<p>根据时间，帧率和采样率采用一定的算法，同步解码出来的音频和视频数据，将其分别送至声卡和显卡播放。</p>
<h1 id="视频质量指标">视频质量指标</h1>
<h2 id="分辨率">分辨率</h2>
<ul>
<li>
<p>分辨率指的是视频图像在一个单位尺寸内的精密度。</p>
</li>
<li>
<p>将视频放大足够大的倍数之后就能看到组成影像的基本单元：像素。</p>
</li>
<li>
<p>视频的分辨率从数值上描述了像素点的个数，如1920x1080：视频在水平方向有1920个像素，垂直方向有1080个像素。</p>
</li>
<li>
<p>常见的描述方式：</p>
<ul>
<li>1080P：指视频有<strong>1080行</strong>像素，P=&gt;Progressive（逐行扫描）</li>
<li>2K：指视频有<strong>2000列</strong>像素</li>
<li>MP：像素总数，指像素的行数P与列数K乘积的结果（百万像素）</li>
<li>1080P的分辨率为1920x1080=2073600，所以1080P通常也称为200万像素分辨率</li>
</ul>
</li>
<li>
<p>通常视频在同样大小的情况下，分辨率越高，所包含的像素点越多，画面就越细腻清晰</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.reneelab.com.cn/m/2k-4k-video-resolution.html" target="_blank" rel="noopener noreffer">科普：视频分辨率是什么？</a></li>
<li><a href="https://www.zhihu.com/question/24205632/answer/648608086" target="_blank" rel="noopener noreffer">「1080p」和「2k、4k」的关系与差别在哪里？</a></li>
</ul>
</li>
</ul>
<h2 id="视频帧率">视频帧率</h2>
<ul>
<li>
<p>帧率的单位FPS(Frame Per Second)或Hz，即每秒多少帧，决定视频画面的流畅程度。</p>
</li>
<li>
<p>低帧率会导致播放卡顿，镜头移动不顺畅，并伴随画面模糊的主观体验；</p>
<p>帧率过高则会造成眩晕的感觉。</p>
</li>
<li>
<p>不同帧率的视频在支持不同帧率的设备上播放：</p>
<ol>
<li>
<p>若设备最高支持60fps，则播放120fps视频的时候，设备会每隔一帧删除一帧，被删除的帧即成为无效帧。</p>
<p>所以高帧率的视频在低帧率设备上播放时会导致播放卡顿。</p>
</li>
<li>
<p>若设备最高支持120fps，则播放60fps视频的时候，设备会每隔一帧复制一帧，来填补空缺的帧位置。</p>
<p>但是效果和在60fps上的设备播放一样，不能提升播放流畅度。</p>
</li>
</ol>
</li>
<li>
<p>关于显卡对帧率的影像：</p>
<ol>
<li>显示器帧率低而显卡输出帧率高时，会导致<a href="https://zh.wikipedia.org/wiki/%E7%95%AB%E9%9D%A2%E6%92%95%E8%A3%82" target="_blank" rel="noopener noreffer">画面撕裂</a>：显示器同时将两帧或几帧显示在同一个画面上</li>
<li>显示器帧率高而显卡输出帧率低时，同视频帧率高显示器帧率低的情况。</li>
</ol>
</li>
</ul>
<h2 id="视频码率">视频码率</h2>
<ul>
<li>
<p>码率的概念出现在视频编码之后，因为压缩之后的视频已经成为二进制数据，所以使用码率的称呼。</p>
</li>
<li>
<p>码率的单位是bps(bit per second)，即每秒多少比特。</p>
</li>
<li>
<p>与视频质量的关系：</p>
<ol>
<li>
<p>分辨率不变的情况下，码率越大，压缩比越好，画面质量越清晰。</p>
<p>码率越高，精度越高，处理出的文件就越接近压缩前的原始状态，每一帧的图像质量越高，画质越清晰，当然对播放设备的解码能力要求也越高。</p>
<p>压缩比越小，视频体积越大，越接近源文件。</p>
</li>
</ol>
</li>
</ul>
<p></p>
]]></description>
</item>
<item>
    <title>Note for RainbowDQN and Multitype Tiles</title>
    <link>https://ayamir.github.io/2021/12/note-for-rainbowdqn-tiles/</link>
    <pubDate>Sat, 11 Dec 2021 16:14:15 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/12/note-for-rainbowdqn-tiles/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p>Level：IEEE Transaction on multimedia 21</p>
<p>Keyword：Rainbow-DQN, Multi-type tiles, Full streaming system</p>
<h2 id="问题形式化">问题形式化</h2>
<h3 id="模型">模型</h3>
<ol>
<li>
<p>原始视频用网格划分成$N$块tile，每个tile都被转码成$M$个不同的质量等级$q_i$。</p>
</li>
<li>
<p>基于传输控制模块得出的结果，播放器请求$t_i$个tile的$q_i$质量的版本并将其存储在缓冲区中，对应的缓冲区大小为$l_i$。</p>
</li>
<li>
<p>用户Viewport的信息用$V$表示，可以确定FOV的中心。</p>
</li>
<li>
<p>根据$V$可以将tile划分成3种类型：FOV、OOS、Base。</p>
</li>
<li>
<p>FOV中的tile被分配更高的码率；</p>
<p>OOS按照与$V$的距离逐步降低质量等级$q_i$；</p>
<p>Base总是使用低质量等级$q_{Base}$但使用完整的分辨率。</p>
</li>
<li>
<p>传输的tile在同步完成之后交给渲染器渲染。</p>
</li>
<li>
<p>播放器根据各项指标计算可以评估播放性能：</p>
<p>$&lt;V, B, Q, F, E&gt;$：viewport信息$V$，网络带宽$B$，FOV质量$Q$，重缓冲频率$F$，传输效率$E$。</p>
</li>
<li>
<p>传输控制模块用于确定每个tile的质量等级$q_i$和缓冲区大小$l_i$。</p>
</li>
<li>
<p>传输控制模块优化的最终目标是获取最大的性能：
$$
performance = E_{max},\ QoE \in accept\ range
$$</p>
</li>
</ol>
<h3 id="带宽评估">带宽评估</h3>
<ol>
<li>
<p>收集每个tile的下载日志来评估带宽。</p>
</li>
<li>
<p>使用<a href="https://zhuanlan.zhihu.com/p/32335746" target="_blank" rel="noopener noreffer">指数加权移动平均算法EWMA</a>使评估结果光滑，来应对网络波动。</p>
</li>
<li>
<p>第$t$次评估结果使用$B_t$表示，用下式计算：
$$
B_t = \beta B_{t-1} + (1-\beta)b_t
$$
$b_t$是B的第$t$次测量值；$\beta$是EWMA的加权系数。</p>
</li>
<li>
<p>$t=0$时，$B_0$被初始化为0；所以在初始的$t$比较小的时候，$B_t$与理想值相比就很小。</p>
<p>这种影响会随着$t$增大而减少。</p>
</li>
<li>
<p>为了优化启动过程，对公式做出修改：
$$
B_t = \frac{\beta B_{t-1} + (1-\beta)b_t}{1 - \beta^t}
$$
$t$较小的时候，分母会放大$B_t$；$t$较大时，分母趋近于1，影响随之消失。</p>
</li>
</ol>
<h3 id="fov表示和预测">FOV表示和预测</h3>
<ol>
<li>
<p>3D虚拟相机用于渲染视频，处于全景视频球面上的某条轨道，其坐标可以表示为$(\theta, \phi)$，可以直接从系统中获取。</p>
<p>相机始终朝向球的中心，所以用户的FOV中心坐标$(\theta^{'}, \phi^{'})$可以用$(\theta, \phi)$表示：
$$
\begin{cases}
\theta^{'} = (\theta + \pi)\ mod\ 2\pi,\ 0 \le \theta \le 2\pi
\
\phi^{'} = \pi - \phi,\ 0 \le \phi \le \pi
\end{cases}
$$</p>
</li>
<li>
<p>2D网格中tile坐标$(u, v)$可以通过球面坐标使用ERP投影获得
$$
\begin{cases}
u = \frac{\theta^{'}}{2\pi} \cdot W, 0 \le u \le W.
\
v = \frac{\phi^{'}}{\pi} \cdot H, 0 \le v \le H.
\end{cases}
$$
$W$和$H$分别表示使用ERP投影得到的矩形宽度和高度</p>
</li>
<li>
<p>短期的FOV预测基于目前和历史的FOV信息。</p>
<p>使用$(U_t, V_t)$表示$t$时刻的FOV中心位置；$U_{t1:t2}$和$V_{t1:t2}$分别表示从$t1$到$t2$过程中$U$和$V$的序列；
$$
\begin{cases}
\hat{U}<em>{t+T_f} = f_U (U</em>{t-T_p:t}).
\
\hat{V}<em>{t+T_f} = f_V (V</em>{t-T_p:t}).
\end{cases}
$$
$T_p$是过去记录的滑动窗口；$T_f$是短期的预测窗口；$f_U$和$f_V$分别对应$U$和$V$方向上的映射函数；</p>
<p>因为是时间序列回归模型，所以映射函数使用LSTM。</p>
</li>
</ol>
<h3 id="qoe评估">QoE评估</h3>
<p>QoE由3个部分组成：平均FOV质量$Q$、重缓冲频率$F$与FOV内tile的质量变化（因为平均分配所以不考虑）。</p>
<ol>
<li>
<p>FOV质量$Q$</p>
<p>第$t$次的FOV质量评估表示为$Q_t$：
$$
Q_t = \frac{\beta Q_{t-1} + (1-\beta) \frac{1}{k} \cdot \sum_{j=1}^{k} max{q_j, q_b}}{1 - \beta^t}
$$
$q_j$表示第$j$条FOV tile流的质量；$k$表示FOV内tile的数量；</p>
<p>为了避免评估结果的大幅波动，使用了EWMA来光滑结果。</p>
<p>当第$j$条tile流因为缓冲区不足不能成功播放时，$q_j = q_{Base}$（这表明了Base tile在提高QoE中的作用）。</p>
</li>
<li>
<p>重缓冲频率$F$</p>
<p>在基于tile的传输中，每条流都属于一个缓冲区。所以当FOV中tile的缓冲区处于饥饿状态时，重缓冲就会发生。</p>
<p>重缓冲频率描述了FOV内的tile流在一段时间内的重新缓冲频率。</p>
<p>第$t$次重缓冲频率的评估表示为$F_t$：
$$
F_t = \frac{\beta F_{t-\tau} + (1-\beta) \frac{f_t}{\tau}}{1 - \beta^{\tau}}
$$
$f_t$表示播放失败的次数；$\tau$表示一段时间；</p>
</li>
</ol>
<h3 id="传输效率评估">传输效率评估</h3>
<p>第$t$次传输效率评估表示为$E_t$，$E_t$通过传输的FOV内tile占总tile的比率来计算：
$$
E_t = \frac{\beta E_{t-1} + (1-\beta) \frac{total^{FOV}}{total^{ALL}}}{1 - \beta^t}
$$
$total^{FOV}$表示FOV内tile的数据量；$total^{ALL}$表示tile的总共数据量；</p>
<p>效率计算并不在传输过程中完成，因为需要获取哪些tile在FOV中的信息，效率评估滞后于播放过程。</p>
<h3 id="问题形式化-1">问题形式化</h3>
<p>传输控制的任务：确定所有tile流的质量等级$\chi$和缓冲区大小$\psi$。
$$
\chi = &lt;q_1, q_2, &hellip;, q_N&gt;
\
\psi = &lt;l_1, l_2, &hellip;, l_N&gt;
\
&lt;Q, F, E&gt; = \xi (B, V, \chi, \psi)
$$
$\chi$和$\psi$与带宽$B$和Viewport轨迹$V$一起作用于系统$\xi$，最终影响FOV质量$Q$，重缓冲频率$F$和传输效率$E$。</p>
<p>进一步，将目标形式化为获得每条tile流的$q_i$和$l_i$通过限制QoE满足可接受的范围、在此基础上最大化传输效率：
$$
\underset{\chi, \psi}{argmax} \sum_{t=0}^{+\infty} E_t,
$$</p>
<p>$$
s.t.:\ 0 \le q_i \le M,
$$</p>
<p>$$
0 \le l_i \le L,
$$</p>
<p>$$
Q^{min} \le Q_t \le M,
$$</p>
<p>$$
0 \le F_t \le F^{max}.
$$</p>
<p>$q_i$和$l_i$分别受限于质量版本数$M$和最大缓冲区大小$L$；</p>
<p>$Q_t$受限于最低QoE标准$Q^{min}$；</p>
<p>$F_t$受限于最大能忍受的重缓冲频率$F^{max}$。</p>
<h2 id="系统架构">系统架构</h2>
<h3 id="服务端">服务端</h3>
<ol>
<li>将原始视频转码为有不同比特率的多个版本。</li>
<li>转码后的视频被划分成多个tile。</li>
<li>传输协议使用MPEG-DASH。</li>
</ol>
<h3 id="客户端">客户端</h3>
<h4 id="评估器">评估器</h4>
<ul>
<li>任务：获取 QoE、FOV预测、传输效率、网络带宽</li>
<li>组成：
<ul>
<li>QoE评估器：评估当前FOV质量=&gt;Q和重缓冲频率=&gt;F（近似为Q+F=QoE）</li>
<li>FOV预测器：基于历史FOV信息预测短期未来的FOV=&gt;P</li>
<li>根据下载和播放日志：计算传输效率=&gt;E并估计带宽=&gt;B</li>
</ul>
</li>
</ul>
<h4 id="控制器">控制器</h4>
<ul>
<li>任务：控制传输过程中的推流</li>
<li>目标：保证QoE在可接受的范围之内、最大化传输效率</li>
<li>详细：基于FOV预测将tile划分成3种类型：FOV、OOS、Base</li>
<li>输入：Q、F、E、B（QoE+传输效率和带宽）</li>
<li>过程：Rainbow-DQN</li>
<li>输出：决定每个tile流的码率和缓冲区大小（作为下载器的输入）</li>
</ul>
<h4 id="下载器">下载器</h4>
<ul>
<li>输入：tile码率和缓冲区大小</li>
<li>过程：基于HTTP/2进行并行下载</li>
<li>输出：下载好的tile</li>
</ul>
<h4 id="视频缓冲区">视频缓冲区</h4>
<ul>
<li>任务：解码、同步、存储下载好的tile等待渲染器消耗，大小供控制器调节</li>
<li>随着FOV的切换缓冲区内容可能被循环利用</li>
</ul>
<h4 id="全景渲染器">全景渲染器</h4>
<ul>
<li>任务：将同步好的tile拼接，tile质量：FOV&gt;OOS&gt;Base</li>
<li>投影方式：ERP</li>
</ul>
<h2 id="控制器-1">控制器</h2>
<h3 id="控制过程">控制过程</h3>
<ol>
<li>
<p>设定QoE的可接受范围。</p>
</li>
<li>
<p>将网络带宽和用户FOV设定为外部因素而非环境</p>
<p>为什么：因为这两个因素变化太快，在面对不同传输条件时，直接作为环境会导致决策过程的不稳定性并且难以收敛。</p>
</li>
<li>
<p>最优化的对象只是最大化累积的传输效率。</p>
<p>为什么：简单</p>
</li>
</ol>
<h3 id="tile聚合和决策">tile聚合和决策</h3>
<ol>
<li>
<p>tile分类原则：</p>
<ul>
<li>
<p>控制器无需为每个tile独立决定码率Q和缓冲区大小L</p>
</li>
<li>
<p>FOV内的tile应该被分配相近的码率，FOV内的tile应该聚集成一组，OSS和Base同理</p>
<p>为什么：避免相邻tile的锐利边界，只考虑3组而非所有tile降低了计算复杂性和决策延迟</p>
<p>（能否实现独立的tile码率计算或更细粒度的划分值得调研？与内容感知的方案结合？）</p>
</li>
</ul>
</li>
<li>
<p>基于距离的tile分类实现方式：</p>
<ul>
<li>
<p>使用评估器预测出的FOV坐标来分类FOV和OOS的tile</p>
</li>
<li>
<p>tile出现在未来FOV的可能性由距离计算</p>
<p>tile中心点坐标$(\omega_i, \mu_i)$、FOV坐标$(\hat{U}, \hat{V})$</p>
<p>距离的变化区间内存在一个临界点，临界点之内的划分为FOV，之外的划分为OOS</p>
<ul>
<li>
<p>度量距离的方式：
$$
\Delta Dis_U = min{|\omega_i - \hat{U}|, |1+\omega_i - \hat{U}|}
$$</p>
<p>（这里为何不直接使用$|\omega_i - \hat{U}|$？）
$$
Dis_i =
\begin{cases}
{\sqrt{({\Delta Dis_{U}})^2 + {(\mu_i - \hat{V})}^2},\  \frac{R}{H} \le \hat{V} \le 1 - \frac{R}{H}}
\
{\Delta Dis_U + |\mu_i - \hat{V}|,\ Others}
\end{cases}
$$</p>
</li>
<li>
<p>因为ERP的投影方式会在两级需要更多的tile，因此使用一个矩形来代表两极的FOV</p>
<p>（可以深入调研ERP在两极处的处理方式）</p>
</li>
<li>
<p>$Dis_i$使用曼哈顿距离来测量。临界点初始化为$2\cdot R$，并随着FOV中心和两极的垂直距离增长。</p>
</li>
<li>
<p>FOV看作是半径为R的圆，使用欧式距离测量。临界点初始化为$R$</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>聚合tile的决策</p>
<ul>
<li>使用2个变量：$K$作为FOV和非FOV的tile的带宽分配比率；$Len$作为tile缓冲区的大小。
<ul>
<li>
<p>$K$确定之后，分配给FOV内tile的带宽被均匀分配（可否非均匀分配）</p>
<p>$K$不直接与网络状况相关因此可以保持控制的稳定性</p>
</li>
<li>
<p>$Len$：所有传输的tile的缓冲区长度$l_i$都被设为$Len$  （文中并没有这样做的原因解释）</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="基于drl的传输控制算法">基于DRL的传输控制算法</h3>
<p>相关术语解释：<a href="https://www.jianshu.com/p/1dfd84cd2e69" target="_blank" rel="noopener noreffer">Rainbow DQN</a>、<a href="https://towardsdatascience.com/the-complete-reinforcement-learning-dictionary-e16230b7d24e" target="_blank" rel="noopener noreffer">RL Dictionary</a>、<a href="https://zhuanlan.zhihu.com/p/38358183" target="_blank" rel="noopener noreffer">PER</a>、<a href="https://zhuanlan.zhihu.com/p/34747205" target="_blank" rel="noopener noreffer">TD-Error</a></p>
<ol>
<li>
<p>控制过程</p>
<ol>
<li>
<p>首先调整buffer长度Len，并划分FOV与非FOV的带宽分配。</p>
</li>
<li>
<p>等viewport预测完成之后，tile被分类为属于FOV和OOS的tile。</p>
</li>
<li>
<p>FOV的带宽被平均分给其中每一个tile并决定FOV内tile的质量等级$q_i$。</p>
<p>非FOV的带宽按照与FOV的距离分配，每超过一个距离单位$Dis_i$就降低一级质量$q_i$。</p>
</li>
<li>
<p>最终的输出是请求序列，每个请求序列中包括质量等级$q_i$和预期的缓冲区大小$l_i$。</p>
</li>
<li>
<p>根据输出做出调整之后，接收奖励反馈并不断完成自身更新。</p>
</li>
</ol>
</li>
<li>
<p>状态设计</p>
<p>状态设计为5元组：$&lt;K, Len, Q, F, E&gt;$（传输控制参数$K$，$Len$、QoE指标：FOV质量Q和重缓冲频率$F$、传输效率$E$）</p>
<p>没有直接使用带宽$B$和viewport轨迹$V$，因为：</p>
<ol>
<li>随机性强与变化幅度较大带来的不稳定性（如何定义随机性强弱和变化幅度大小？）</li>
<li>希望设计的模型有一定的通用性，可以与不同的网络情况和用户轨迹相兼容</li>
</ol>
</li>
<li>
<p>动作设计</p>
<p>两种动作：调整$K$和$Len$（两者的连续变化区间被离散化，调整的每一步分别用$\Delta k$和$\Delta l$表示）</p>
<p>调整的方式被形式化为二元组：$&lt;n_1, n_2&gt;$，$n_1$和$n_2$分别用于表示$K$和$Len$的调整</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">-n</th>
<th style="text-align:center">0</th>
<th style="text-align:center">n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">K</td>
<td style="text-align:center">减少n$\Delta k$</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">增加n$\Delta k$</td>
</tr>
<tr>
<td style="text-align:center">Len</td>
<td style="text-align:center">减少n$\Delta l$</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">增加n$\Delta l$</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>奖励函数</p>
<p>因为QoE的各项指标权重难以确定，没有使用传统的基于加权的方式。</p>
<p>设定了<strong>能接受的QoE范围</strong>和<strong>在此基础上最大化的传输效率</strong>作为最后的<strong>性能</strong>指标，形式化之后如下：
$$
Reward =
\begin{cases}
-INF,\ F \ge F^{max}
\
-INF,\ E \le E^{min}
\
E,\ Others
\end{cases}
$$</p>
<p>$-INF$意味着终止当前episode；动作越能使系统满足高QoE的同时高效运行，得分越高；</p>
<p>为了最大化传输效率，使用$E$作为奖励回报。</p>
<p>FOV质量$Q$并没有参与到奖励函数中，因为：<strong>高Q意味着高性能，但是低Q不一定意味着低性能</strong>，详细解释如下：</p>
<ul>
<li>在带宽不足的情况下，低Q可能已经是这种条件下的满足性能的最好选择。</li>
<li>高传输效率意味着传输了更多的FOV数据，也能满足高FOV质量的目标。</li>
</ul>
</li>
<li>
<p>模型设计
基于Rainbow-DQN模型：</p>
<ul>
<li>
<p>输入是5元组$&lt;K, Len, Q, F, E&gt;$。</p>
</li>
<li>
<p>神经网络使用64维的3隐层模型。</p>
</li>
<li>
<p>为了提高鲁棒性，神经网络的第3层使用Dueling DQN的方式，将Q值$Q(s, a)$分解为状态价值$V(s)$和优势函数$A(s,a)$：
$$
Q(s, a) = V(s) + A(s, a)
$$</p>
<p>$V(s)$表示系统处于状态$s$时的性能；$A(s,a)$表示系统处于状态$s$时动作$a$带来的性能；</p>
</li>
<li>
<p>为了避免价值过高估计，使用Double DQN的方式，设计了两个独立的神经网络：评估网络和目标网络。</p>
<p>评估网络用于动作选择；目标网络是评估网络从最后一个episode的拷贝用于动作评估。</p>
</li>
<li>
<p>为了缓解神经网络的不稳定性（更快收敛），使用大小为$v$的回放池来按照时间序列保存客户端的经验。</p>
<p>因为网络带宽和FOV轨迹在短期内存在特定的规律性，回放池中有相似状态和相似采样时间的样本更加重要，出现了优先级</p>
<p>所以使用优先经验回放PER，而优先级使用时间查分误差TD-error定义
$$
\delta_i = r_{i+1} + \gamma Q(s_{i+1}, arg\underset{a}{max}Q(s_{i+1}, a; \theta_i); \theta_i^{'}) - Q(s_i, a_i; \theta_i)
$$</p>
<p>$r_i$是奖励；$\gamma$是折扣因子</p>
</li>
<li>
<p>损失函数使用均方误差定义
$$
J = \frac{1}{v} \sum_{i=1}^{v} \omega_i(\delta_i)^2
$$</p>
<p>$\omega_i$是回放缓冲中第i个样本的重要性采样权重</p>
</li>
</ul>
</li>
</ol>
<h2 id="实验验证">实验验证</h2>
<ol>
<li>
<p>环境设定</p>
<ul>
<li>
<p>传输控制模块：基于<a href="https://tensorforce.readthedocs.io/en/latest/" target="_blank" rel="noopener noreffer">TensorForce</a>（配置教程：<a href="https://zhuanlan.zhihu.com/p/60241809" target="_blank" rel="noopener noreffer">用TensorForce快速搭建深度强化学习模型</a>）；</p>
<p>开发工具集：<a href="https://gym.openai.com/" target="_blank" rel="noopener noreffer">OpenAI Gym</a></p>
</li>
<li>
<p>数据来源：使用全景视频播放设备收集，加入高斯噪声来产生更多数据。</p>
</li>
</ul>
</li>
<li>
<p>结果分析</p>
<ul>
<li>
<p>与其他DQN算法的对比——DQN、Double DQN、Dueling DQN</p>
<ul>
<li>
<p>对比训练过程中每个episode中的最大累计奖励：$MAX_{reward}$</p>
</li>
<li>
<p>对比模型收敛所需要的最少episode：$MIN_{episode}$</p>
<p>相同的带宽和FOV轨迹</p>
</li>
</ul>
</li>
<li>
<p>与其他策略对比性能——高QoE和高传输效率</p>
<ul>
<li>
<p>随机控制策略：随机确定K和Len</p>
</li>
<li>
<p>固定分配策略：固定K和Len的值</p>
</li>
<li>
<p>只预测Viewport策略：使用LSTM做预测，不存在OSS与Base，所有带宽都用于FOV</p>
<p>带宽和FOV轨迹的均值和方差相等</p>
</li>
</ul>
</li>
<li>
<p>与其他全景视频推流系统的对比</p>
<ul>
<li>
<p>DashEntire360：使用Dash直接传送完整的360度视频，使用线性回归来估计带宽并动态调整视频比特率</p>
</li>
<li>
<p>360ProbDash：在DashEntire360的基础上划分tile基于Dash传输，使用可能性模型为tile分配比特率</p>
</li>
<li>
<p>DRL360：使用DRL来优化多项QoE指标</p>
<p>实现三种系统、使用随机网络带宽和FOV轨迹。</p>
<p>使用DRL360中提出的方式测量QoE：
$$
V_{QoE} = \eta_1 Q - \eta_2 F - \eta_3 A
$$</p>
<p>$A$是viewport随时间的平均变化，反映FOV质量Q的变化；</p>
<p>$\eta_1, \eta_2, \eta_3$分别是3种QoE指标的非负加权，使用4种加权方式来训练模型并对比：</p>
<p>$&lt;1, 1, 1&gt;$，$&lt;1, 0.25, 0.25&gt;$，$&lt;1, 4, 1&gt;$，$&lt;1,1,4&gt;$</p>
</li>
</ul>
</li>
<li>
<p>在不同环境下的性能评估——带宽是否充足、FOV轨迹是否活跃（4种环境）</p>
</li>
</ul>
</li>
</ol>
]]></description>
</item>
<item>
    <title>Note for 360ProbDASH</title>
    <link>https://ayamir.github.io/2021/12/note-for-360probdash/</link>
    <pubDate>Thu, 09 Dec 2021 10:20:15 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/12/note-for-360probdash/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p>Link: <a href="https://dl.acm.org/doi/10.1145/3123266.3123291" target="_blank" rel="noopener noreffer">360ProbDASH: Improving QoE of 360 Video Streaming Using Tile-based HTTP Adaptive Streaming</a></p>
<p>Level: ACM MM 17</p>
<p>Keyword:</p>
<p>Pre-fetch tiles, QoE-driven optimization, Probabilistic model, Rate and Viewport adaptation</p>
<h2 id="工作范围与目标">工作范围与目标</h2>
<p>应用层-&gt;基于tile-&gt;viewport预测的可能性模型+预期质量的最大化</p>
<ul>
<li>
<p>针对小buffer提出了<code>target-buffer-based rate control</code>算法来避免重缓冲事件（避免卡顿）</p>
</li>
<li>
<p>提出viewport预测的可能性模型计算tile被看到的可能性（避免边缘效应）</p>
</li>
<li>
<p>形式化QoE-driven优化问题：</p>
<p>在传输率受限的情况下最小化viewport内的质量失真和空间质量变化（获取受限状态下最好的视频质量）</p>
</li>
</ul>
<h2 id="问题建模">问题建模</h2>
<ol>
<li>
<p>形式化参数</p>
<p>$M*N$个tile，M指tile序列的序号，N指不同的码率等级</p>
<p>$r_{i, j}$指比特率，$d_{i, j}$指失真，$p_{i}$指被看到的可能性（$\sum_{i=1}^{N}p_{i} = 1$）</p>
<p>$\Phi(X)$指质量失真，$\Psi(X)$指质量变化</p>
</li>
<li>
<p>目标</p>
<p>找到推流段的集合：$X = {x_{i, j}}$，其中${x_{i, j}} = 1$指被第$&lt;i, j&gt;$个tile被选中；$x_{i, j} = 0$则是未选中。
$$
\underset{X}{min}\ \Phi(X) + \eta \cdot \Psi(X) \
s.t. \sum_{i=1}^{N}\sum_{j=1}^{M}x_{i, j}\cdot r_{i, j} \le R, \
\sum_{j=1}^{M}x_{i, j} \le 1, x_{i, j} \in {0, 1}, \forall i.
$$
整个公式即为前所述的问题的形式化表达的公式化结果。</p>
</li>
<li>
<p>模型细节</p>
<ol>
<li>
<p>$\Phi(X)$和$\Psi(X)$的计算=&gt;通过考虑球面到平面的映射</p>
<p>通过计算球面上点的Mean Squared Error来得到S-PSNR进而评估质量：$d_{i, j}$来表示第${&lt;i, j&gt;}$个段的MSE</p>
<p>
$$
\phi_i = \frac{\pi}{2} - h_i \cdot \frac{\pi}{H}, \Delta\phi = \Delta h \cdot \frac{\pi}{H}, \
\theta_i = w_i \cdot \frac{2\pi}{W}, \ \Delta\theta = \Delta w \cdot \frac{2\pi}{W},
$$
$H$和$W$分别指按照ERP格式投影之后的视频高度和宽度</p>
<p>第$i$个tile的空间面积用$s_i$表示：
$$
s_i\ =\ \iint_{\Omega_i}Rd\phi Rcos\phi d\theta \
=\Delta\theta R^2[sin(\phi_i + \Delta\phi) - sin\phi_i],
$$
$R$指球的半径（$R = W/2\pi$），所以整体的球面质量失真$D_{i, j}$可以计算出来：
$$
D_{i, j} = d_{i, j} \cdot s_i,
$$
结合每个tile被看到的概率$p_i$可以得出$\Phi(X)$和$\Psi(X)$
$$
\Phi(X)=\frac{\sum_{i=1}^N\sum_{j=1}^MD_{i, j}\cdot x_{i,j}\cdot p_i}{\sum_{i=1}^N\sum_{j=1}^Mx_{i,j}\cdot s_i},\
\Psi(X) = \frac{\sum_{i=1}^N\sum_{j=1}^Mx_{i, j}\cdot p_i \cdot\ (D_{i,j}-s_{i} \cdot \Phi(X))^2}{\sum_{i=1}^N\sum_{j=1}^Mx_{i,j}\cdot s_i}.
$$</p>
</li>
<li>
<p>Viewport的可能性模型</p>
<ol>
<li>
<p>方向预测=&gt;<strong>线性回归模型</strong></p>
<p>将用户的欧拉角看作是$yaw(\alpha)$，$pitch(\beta)$和$rool(\gamma)$，应用线性回归做预测
$$
\begin{cases}
\hat{\alpha}(t_0 + \delta) = m_{\alpha}\delta+\alpha(t_0),\
\hat{\beta}(t_0 + \delta) = m_{\beta}\delta+\beta(t_0),\
\hat{\gamma}(t_0 + \delta) = m_{\gamma}\delta+\gamma(t_0).
\end{cases}
$$</p>
</li>
<li>
<p>预测错误的分布=&gt;<strong>高斯分布</strong>，根据公式均值和标准差都能从统计信息中计算出来</p>
<p>收集5名志愿者的头部移动轨迹并投影到3个方向上绘制成图，实验结果为预测错误呈现高斯分布（样本数可能不够？）</p>
<p>
$$
\begin{cases}
P_{yaw}(\alpha) = \frac{1}{\sigma_{\alpha}\sqrt{2\pi}}exp{-\frac{[\alpha-(\hat{\alpha}+\mu_{\alpha})]^2}{2\sigma_{\alpha}^2}},\
P_{pitch}(\beta) = \frac{1}{\sigma_{\beta}\sqrt{2\pi}}exp{-\frac{[\beta-(\hat{\beta}+\mu_{\beta})]^2}{2\sigma_{\beta}^2}},\
P_{roll}(\gamma) = \frac{1}{\sigma_{\gamma}\sqrt{2\pi}}exp{-\frac{[\gamma-(\hat{\gamma}+\mu_{\gamma})]^2}{2\sigma_{\gamma}^2}}.
\end{cases}
$$
3个方向各自<strong>独立</strong>，因此最终的预测错误$P_E(\alpha,\beta,\gamma)$可以表示为：
$$
P_E(\alpha, \beta, \gamma) = P_{yaw}(\alpha)P_{pitch}(\beta)P_{roll}(\gamma).
$$</p>
</li>
<li>
<p>球面上点被看到的可能性</p>
<p>球面坐标为$(\phi, \theta)$点的可能性表示为$P_s(\phi, \theta)$</p>
<p>因为一个点可能在多个不同的viewport里面，所以定义按照用户方向从点$(\phi, \theta)$出发能看到的点集$L(\phi, theta)$</p>
<p>因此空间点$s$被看到的可能性可以表示为：
$$
P_s(\phi, \theta) = \frac{1}{|L(\phi, \theta)|}\sum_{(\alpha, \beta, \gamma) \in L(\phi, \theta)}P_E(\alpha, \beta, \gamma),
$$</p>
</li>
<li>
<p>球面上tile被看到的可能性</p>
<p>tile内各个点被看到的可能性的<strong>均值</strong>即为tile被看到的可能性（可否使用其他方式？）
$$
p_i = \frac{1}{|U_i|} \sum_{(\phi, \theta) \in U_i} P_s(\phi, \theta).
$$
$U_i$表示tile内的空间点集</p>
</li>
</ol>
</li>
<li>
<p><code>Target-Buffer-based</code> Rate Control</p>
<p>因为长期的头部移动预测会产生较高的预测错误，所以不能采用大缓冲区（没有cite来证明这一点）</p>
<p></p>
<p>将处于相同时刻的段集合成一个块存储在缓冲区中。</p>
<p>在自适应的第k步，定义$d_k$作为此时的buffer占用情况（等到第k个块被下载完毕）
$$
b_k = b_{k-1} - \frac{R_k \cdot T}{C_k} + T
$$
$C_k$表示平均带宽，$R_k$表示总计的码率</p>
<p>为了避免重新缓冲设定目标buffer占用$B_{target}$，并使buffer占用保持在$B_{target}$（$b_k = B_{target}$）</p>
<p>因此总计的码率需要满足：
$$
R_k = \frac{C_k}{T} \cdot (b_{k-1} - B_{target} + T),
$$
这里的$C_k$表示可以从历史的段下载信息中估计出来的带宽</p>
<p>设定$R$的下界$R_{min}$之后（没有说明为何需要设定下界），公式12可以修正为如下：
$$
R_k = max{\frac{C_k}{T} \cdot (b_{k-1} - B_{target} + T), R_{min}}.
$$</p>
</li>
</ol>
</li>
</ol>
<h2 id="实现">实现</h2>
<h3 id="服务端">服务端</h3>
<ol>
<li>
<p>视频裁剪器</p>
<p>将视频帧切割成tile</p>
</li>
<li>
<p>编码器</p>
<p>对tile进行划分并将其编码成多种码率的段</p>
</li>
<li>
<p>MPD产生器</p>
<p>添加<strong>SRD特性</strong>来表示段之间的空间关系</p>
<p>添加经度和<strong>纬度</strong>属性来表示</p>
<p>添加<strong>质量失真</strong>和<strong>尺寸</strong>属性</p>
</li>
<li>
<p>Apache HTTP服务器</p>
<p>存储视频段和mpd文件，向客户端推流</p>
</li>
</ol>
<h3 id="客户端">客户端</h3>
<ol>
<li>
<p>基础：dash.js</p>
</li>
<li>
<p>额外的模块</p>
<ul>
<li>
<p><code>QoE-driver Optimizer</code>
$$
Output = HTTP\ GET请求中的最优段
$$</p>
<p>$$
Input = Output\ of\
\begin{cases}
Target\ buffer\ based\ Rate\ Controller\
Viewport\ Probabilistic\ Model\
QR\ Map
\end{cases}
$$</p>
</li>
<li>
<p><code>Target-buffer-based Rate Controller</code>
$$
Output = 总计的传输码率，按照公式13计算而来
$$</p>
<p>$$
Input = Output\ of\ {Bandwidth\ Estimation\ module
$$</p>
</li>
<li>
<p><code>Viewport Probabilistic Model</code>
$$
Output = 每个tile被看到的可能性，按照公式10计算而来
$$</p>
<p>$$
Input = Output\ of\
\begin{cases}
Orientation\ Prediction\ module\
SRD\ information
\end{cases}
$$</p>
</li>
<li>
<p><code>QR Map</code>QR=&gt;Quality-Rate
$$
Output = 所有段的QR映射
$$</p>
<p>$$
Input = MPD中的属性
$$</p>
</li>
<li>
<p><code>Bandwidth Estimation</code>（没有展开研究，因为不是关键？）
$$
Output = 前3秒带宽估计的平均值
$$</p>
<p>$$
Input = 下载段过程中的吞吐量变化
$$</p>
<p>可以通过<code>onProgess()</code>的回调函数<code>XMLHttpRequest API</code>获取</p>
</li>
<li>
<p><code>Orientation Prediction</code>
$$
Output = 用户方向信息的预测结果（yaw, pitch, roll）
$$</p>
<p>$$
Input = Web\ API中获取的DeviceOrientation信息，使用线性回归做预测
$$</p>
</li>
</ul>
</li>
</ol>
<h2 id="评估">评估</h2>
<ul>
<li>
<p>整体设定</p>
<ol>
<li>将用户头部移动轨迹编码进播放器来模拟用户头部移动</li>
<li>积极操控网络状况来观察不同方案对网络波动的反应</li>
</ol>
</li>
<li>
<p>详细设定</p>
<ul>
<li>
<p>服务端</p>
<ol>
<li>
<p>视频选择</p>
<p>2880x1440分辨率、时长3分钟、投影格式ERP</p>
</li>
<li>
<p>切分设置</p>
<p>每个块长1s（$T=1$）、每个块被分成6x12个tile（$N=72$）</p>
<p>每个段的码率设置为${20, 50, 100, 200, 300}$，单位kpbs</p>
</li>
<li>
<p>视频编码</p>
<p><a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="noopener noreffer">开源编码器x264</a></p>
</li>
<li>
<p>视频分包</p>
<p><a href="https://gpac.wp.mines-telecom.fr/mp4box/" target="_blank" rel="noopener noreffer">MP4Box</a></p>
</li>
<li>
<p>注意事项</p>
<p>每个段的确切尺寸可能与其码率不同，尤其对于长度较短的块。</p>
<p>为了避免这影响到码率自适应，将段的确切尺寸也写入MPD文件中</p>
</li>
</ol>
</li>
<li>
<p>客户端</p>
<ol>
<li>
<p>缓冲区设定（经过实验得出的参数）</p>
<p>$B_{max}=3s$，$B_{target}=2.5s$，$R_{min}=200kbps$，$权重\eta=0.0015$</p>
</li>
</ol>
</li>
<li>
<p>高斯分布设定</p>
<table>
<thead>
<tr>
<th style="text-align:center">Yaw</th>
<th style="text-align:center">Pitch</th>
<th style="text-align:center">Roll</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\mu_{\alpha}=-0.54,\ \sigma_{\alpha}=7.03$</td>
<td style="text-align:center">$\mu_{\beta}=0.18,\ \sigma_{\beta}=2.55$</td>
<td style="text-align:center">$\mu_{\gamma}=2.16,\ \sigma_{\gamma}=0.15$</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>比较对象</p>
<ul>
<li>ERP：原始视频格式</li>
<li>Tile：只请求用户当前viewport的tile，不使用viewport预测，作为baseline</li>
<li>Tile-LR：使用线性回归做预测，每个tile的码率被平均分配</li>
</ul>
</li>
<li>
<p>性能指标</p>
<ul>
<li>卡顿率：卡顿时间占播放总时长的比例</li>
<li>Viewport PSNR：直接反应Viewport内的视频质量</li>
<li>空间质量差异：Viewport内质量的协方差</li>
<li>Viewport偏差：空白区域在Viewport中的比例</li>
</ul>
</li>
</ul>
]]></description>
</item>
<item>
    <title>Note for Dante</title>
    <link>https://ayamir.github.io/2021/12/note-for-dante/</link>
    <pubDate>Wed, 08 Dec 2021 22:14:15 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/12/note-for-dante/</guid>
    <description><![CDATA[<h2 id="论文概况">论文概况</h2>
<p>Link: <a href="https://dl.acm.org/doi/10.1145/3232565.3234686" target="_blank" rel="noopener noreffer">https://dl.acm.org/doi/10.1145/3232565.3234686</a></p>
<p>Level: SIGCOMM 18</p>
<p>Keyword: UDP+FOV-aware+FEC</p>
<h2 id="工作范围">工作范围</h2>
<p></p>
<h2 id="目标">目标</h2>
<p>在给定序列的帧中，为<strong>每个tile</strong>设定FEC冗余，根据其被看到的可能性的加权最小化平均质量降低。</p>
<h2 id="问题建模">问题建模</h2>
<ol>
<li>
<p>输入
估计的丢包率$p$、发送速率$f$、有$n$个tile的$m$个帧($&lt;i, j&gt;$来表示第$i$个帧的第$j$个tile</p>
<p>第$&lt;i, j&gt;$个tile的大小$v_{i, j}$、第$&lt;i, j&gt;$个tile被看到的可能性$\gamma_{i, j}$、</p>
<p>如果第$&lt;i, j&gt;$ 个tile没有被恢复的质量降低率、最大延迟$T$</p>
</li>
<li>
<p>输出</p>
<p>第$&lt;i, j&gt;$个tile的FEC冗余率$r_{i, j} = \frac{冗余包数量}{原始包数量}$</p>
</li>
<li>
<p>最优化问题的形式化
$$
minimize\  \sum_{0&lt;i\le m}\sum_{0&lt;j\le n} \gamma_{i, j}d_{i, j}(p, r_{i, j})
$$</p>
<p>$$
subject\ \ to\ \  \frac{1}{f}\sum_{0&lt;i\le m}\sum_{0&lt;j\le n}v_{i, j}(1+r_{i, j}) \le T
$$</p>
<p>$$
r_{i, j} \le 0
$$</p>
<p>（1）：最小化最终被看到的tile的质量衰减的加权和，权重按照被看到的可能性分配。</p>
<p>（2）：经过重新编码的包和原始的包需要在T时刻之前发出。</p>
<p>​      Dante将1个GOP(Group of Pictures)中的所有帧当作一批处理，$T$作为GOP的持续时间</p>
<p>​      $f$：使用TCP Friendly Rate Control algorithm，基于估计的丢包率和网络延迟来计算得出</p>
<p>（3）：确保冗余率总是非负的。</p>
</li>
<li>
<p>关键变量是$d_{i, j}(p, r)$：丢包率是p情况下，采用r作为冗余率的第$&lt;i, j&gt;$个tile的质量衰减
$$
d_{i, j}(p, r) = \delta_{i, j},\ if\ r &lt; \frac{1}{1-p}; 0, otherwise.
$$</p>
<p>假设帧中有k个原始包，质量衰减发生在丢失的包不能被恢复的情况下。</p>
<p>FEC可以容忍 $r \cdot k$ 个丢包=&gt;即当 $p(r<em>k+k)$ 大于  $r</em>k$  时会发生质量衰减。</p>
</li>
<li>
<p>过多的丢包会导致依赖链上所有帧的质量衰减，因此考虑帧之间的依赖关系之后，可以重新计算质量衰减：</p>
<p>$$
d^{*}<em>{i, j}(p, r) = \sum</em>{0&lt;c\le i}w_{c, i}d_{c, j}(p, r)
$$</p>
<p>$w_{c, i}$ 编码帧i对帧c的依赖作为单独的第c个帧的质量衰减的权重；</p>
<p>最终第i个帧的第j个tile的最终质量衰减就是所有依赖的质量衰减的和。</p>
</li>
</ol>
<h2 id="fec冗余的自适应逻辑">FEC冗余的自适应逻辑</h2>
<ol>
<li>
<p>关于$d_{i, j}(p, r)$ ：因为是分段函数，所以其值会因为r和p的大小关系而急剧改变。</p>
<p>利用背包问题的思想可以将其规约成NP完全问题：</p>
<p>将每个tile看作是一个物品，共有m*n个。</p>
<p><strong>如果$r_{i, j} &lt; \frac{1}{1-p}$ ，则表示不把第&lt;i,j&gt;和物品放入背包；否则就是将其放入背包。</strong></p>
<p>公式1可以转化为：最大化所有物品二元变量的线性组合；</p>
<p>公式2可以转化为：二元变量的另一个线性组合必须低于阈值约束。</p>
<p>因此整个问题就能被完全转化为<strong>0-1背包</strong>问题</p>
</li>
<li>
<p>算法</p>
<p></p>
<p>整体上是背包问题的标准解法，能以线性复杂度（因为变量只是B)解决问题。</p>
</li>
</ol>
<h2 id="原型设计">原型设计</h2>
<p></p>
<ul>
<li>使用基于TCP和UDP的两条连接来分别传输控制信息（双向：到客户端的播放会话的起至点和到服务端的网络信息反馈）和视频数据包</li>
<li>服务端根据反馈的网络信息，在每个GOP的边界时刻运行算法1来确定下一个GOP的帧和tile的FEC冗余。
确定之后服务端使用RS码来插入冗余包，和原始视频数据包一起重新编码，并使用基于TFRC的发送率发送数据。</li>
<li>Dante的实现是对应用程序级比特率适配策略的补充，并且可以通过对视频播放器进行最小更改来替换现有的底层传输协议来部署。</li>
</ul>
<h2 id="实验评估">实验评估</h2>
<ul>
<li>
<p>环境：使用Gilbert模型来模拟实现丢包事件（而非使用统一随机丢包）</p>
<p>创造了两种网络条件good（丢包率0.5%）和bad（丢包率2%）</p>
</li>
</ul>
<h2 id="局限性">局限性</h2>
<ul>
<li>效果主要依赖于Viewport预测的结果是否准确</li>
</ul>
]]></description>
</item>
<item>
    <title>沉浸式流媒体传输的实际度量</title>
    <link>https://ayamir.github.io/2021/11/note11/</link>
    <pubDate>Mon, 22 Nov 2021 15:21:59 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/11/note11/</guid>
    <description><![CDATA[<h2 id="度量指标">度量指标</h2>
<ol>
<li>viewport预测精度。
<ul>
<li>使用预测的viewport坐标和实际用户的viewport坐标的大圈距离来量化。</li>
</ul>
</li>
<li>视频质量。
<ul>
<li>viewport内部的tile质量（1～5）。</li>
<li>tile在最高质量层之上花费的时间。</li>
<li>根据用户视线的分布而提出的加权质量度量。</li>
</ul>
</li>
</ol>
<h2 id="度量参数">度量参数</h2>
<ol>
<li>分块策略</li>
<li>带宽</li>
<li>延迟</li>
<li>viewport预测</li>
<li>HTTP版本</li>
<li>持久化的连接数量</li>
</ol>
]]></description>
</item>
<item>
    <title>沉浸式推流中应用层的优化</title>
    <link>https://ayamir.github.io/2021/11/note10/</link>
    <pubDate>Mon, 15 Nov 2021 10:13:18 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/11/note10/</guid>
    <description><![CDATA[<h2 id="背景">背景</h2>
<p>大多数的HAS方案使用HTTP/1.1协议进行请求-回应的事务来取得需要的资源、缓冲取到的视频段并以线性的顺序播放。传统的HAS中，只需要1个GET请求来取得下一个视频的暂时的部分。只要视频段的持续时间比网络内的时延高，这种方法就可行。</p>
<p>在基于VR的HAS方案中，播放1条视频片段就需要取得多种资源：1次GET请求需要同时请求基础的tile层和每个空间视频tile。使用4x4的tile方案时，客户端需要发起不少于17次GET请求。使用 1 s 数量级的分段持续时间，即使是 20 ms 的微小网络延迟也会显着阻碍客户端和服务器之间的整体吞吐量，因此会导致较低的视频质量。</p>
<h2 id="解决方案">解决方案</h2>
<h3 id="使用多条持久的tcp连接">使用多条持久的TCP连接</h3>
<p>大多数的现代浏览器都支持同时建立并维持多达6条TCP连接来减少页面加载时间，并行地获取请求的资源。这允许增加整体吞吐量，并部分消除网络延迟引入的空闲 RTT 周期。</p>
<p>类似地，基于 VR 的 HAS 客户端可以使用多个 TCP 连接并行下载不同的tile。</p>
<h3 id="使用http2协议的服务端push特性">使用HTTP/2协议的服务端push特性</h3>
<p>HTTP/2协议引入了请求和相应的多路复用、头部压缩和请求优先级的特性，这可以减少页面加载时间。</p>
<p>服务端直接push短视频片段可以减少视频的启动时间和端到端延迟。</p>
<p>并且，服务端push特性可以应用在基于tile的VR视频推流中，客户端可以向服务器同时请求一条视频片段的所有tile。</p>
<p>服务端可以使用特制的请求处理器，允许客户端为每个tile定义一系列质量等级。</p>
<p>因此可以将应用的启发式自适应的速率的决定传达给服务器，这允许客户端以期望的质量级别取得所有图块。</p>
]]></description>
</item>
<item>
    <title>沉浸式流媒体面临的挑战和启示</title>
    <link>https://ayamir.github.io/2021/11/note9/</link>
    <pubDate>Sun, 14 Nov 2021 19:06:10 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/11/note9/</guid>
    <description><![CDATA[<h2 id="最终的目标">最终的目标</h2>
<p>主要的挑战是用户的临场感，这可以通过避免虚拟的线索来创造出接近真实的世界。</p>
<h2 id="具体的任务">具体的任务</h2>
<ol>
<li>
<p>从360度视频的采集到显示的过程中，引入了好几种失真。</p>
<p>应该重点增加新的拼接、投影和分包方式以减少噪音。</p>
</li>
<li>
<p>除了捕获和使用360度视频来表示真实世界和实际交互内容之外，环境中还包括3D对象。</p>
<p>3D对象的合并对于真实的视图而言是一个挑战。</p>
</li>
<li>
<p>因为在推流会话中，用户的头部移动高度可变，所以固定的tiling方案可能会导致非最优的viewport质量。</p>
<p>推流框架中的tile数量应该被动态选择，进而提高推流质量。</p>
</li>
<li>
<p>自适应的机制应该足够智能来根据环境因素精确地做出适应。</p>
<p>应该制定基于深度强化学习的策略，来给360度视频帧中不同区域的tile分配合适的比特率。</p>
</li>
<li>
<p>用户在360度视频中的自由导航很容易让其感觉忧虑自己错过了什么重要的东西。</p>
<p>在360度视频中导航的时候，需要支持自然的可见角度方向。</p>
<p>丰富的环境应配备新颖的定向机制，以支持360度视频，同时降低认知负荷，以克服此问题。</p>
</li>
<li>
<p>真实的导航依赖viewport预测机制。</p>
<p>现代的预测方式应该使用时空图像特性以及用户的位置信息，采用合适的编解码器卷积LSTM结构来减少长期预测误差。</p>
</li>
<li>
<p>沉浸式的场景随着用户的交互应该发生变化。</p>
<p>由于用户与场景的交互而产生的新挑战是通过编码和传输透视图创建的。</p>
<p>因此预测用户的行为来实现对交互内容的高效编码和推流非常关键。</p>
</li>
<li>
<p>对360度视频的质量获取方法和度量手段需要进一步研究。</p>
</li>
<li>
<p>360度视频中特殊的音效需要引起注意。</p>
</li>
</ol>
]]></description>
</item>
<item>
    <title>360度视频的音频处理</title>
    <link>https://ayamir.github.io/2021/11/note8/</link>
    <pubDate>Sun, 14 Nov 2021 16:52:20 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/2021/11/note8/</guid>
    <description><![CDATA[<h2 id="背景">背景</h2>
<p>空间音频是一种全球状空间环绕的声音方式，采用多个声音通道来模拟现实世界中听到的声音。</p>
<p>360度视频由于空间音频而变得更加可靠，因为声音的通道特性使其能够穿越时间和空间。</p>
<p>360度视频显示系统在制作空间音频音轨方面的重要性无论怎样强调都不为过</p>
<h2 id="空间音频的再现技术">空间音频的再现技术</h2>
<h3 id="物理重建">物理重建</h3>
<p>物理重建技术用于合成尽可能接近所需信号的整个声场。</p>
<p>立体声配置在最流行的声音再现方法中使用两个扬声器，以促进更多的空间信息（包括距离、方向感、环境和舞台合奏）。而多信道再现方法在声学环境中使用，并在消费类设备中流行。</p>
<h4 id="多信道再现技术">多信道再现技术</h4>
<p>同样的声压场也通过其他物理重建技术产生，如环境中存在的环境声学和波场合成（WFS）。</p>
<p>需要麦克风阵列来捕获更多的空间声场。</p>
<p>因为不能直接用于声场特性分析，麦克风记录的内容需要后期处理。</p>
<p>麦克风阵列用于语音增强、声源分离、回声消除和声音再现。</p>
<h3 id="感知重建">感知重建</h3>
<p>心理声学技术用于感知重建，以产生对空间声音特征的感知。</p>
<p>感知重建技术复制空间音频的自然听觉感受来表示物理音频。</p>
<h4 id="双耳录制技术">双耳录制技术</h4>
<p>双耳录制技术是立体声录制的一种扩展形式，提供3D的听觉体验。</p>
<p>双耳录制技术通过使用两个360度麦克风尽可能的复制人耳，这与使用定向麦克风捕捉声音的常规立体声录音相同。</p>
<p>假人头部的360度麦克风用作人耳的代理，因为它提供了耳朵的精确几何坐标。</p>
<p>假人头部还产生与人头轮廓相互作用的声波。借助360度麦克风，与任何其他记录方法相比，空间立体图像的捕获更精确。</p>
<h5 id="头部相关传递函数hrtf">头部相关传递函数（HRTF）</h5>
<p>用于双耳音频的实时技术中，以再现复杂的线索，帮助我们通过过滤音频信号来定位声音。</p>
<p>多个因素（如耳朵、头部和听力环境）会影响线索，因为在现实中，我们会重新定位自己以定位声音。</p>
<p>选择合适的录音/重放技术对于使听到的声音与真实场景中的体验相同至关重要。</p>
<h2 id="环境声学">环境声学</h2>
<h3 id="概述">概述</h3>
<p>环境声学也被称为3D音频，被用于记录、混成和播放一个中心点周围的360度音频。</p>
<h3 id="区别">区别</h3>
<p>环境音频和传统的环绕声技术不同。</p>
<ol>
<li>
<p>双声道和传统环绕声技术背后的原理是相同的，都是通过将声音信号送到特定的扬声器来创建音频。</p>
<p>环境音频不受任何特定扬声器的预先限制，因为它在即使音域旋转的情况下，也能创造出平滑的音频。</p>
</li>
<li>
<p>传统环绕声的格式只有在声音场景保持静态的情况下才能提供出色的成像效果。</p>
<p>环境音频提供一个完整的球体，将声音均匀地传播到整个球体。</p>
</li>
</ol>
<h3 id="格式">格式</h3>
<p>环境音频有6种格式，分别为：A、B、C、D、E、G。</p>
<h3 id="用途">用途</h3>
<h4 id="一阶环境音频的用途">一阶环境音频的用途</h4>
<p>第一阶的环境音频或B格式的环境音频，其麦克风用于使用四面体阵列表示线性VR。</p>
<p>此外，这些在四个通道中进行处理，例如提供非定向压力水平的“W”。同时，“X、Y和Z”分别促进了从前到后、从侧到侧以及从上到下的方向信息。</p>
<p>一阶环境音频仅适用于相对较小的场景，因为其有限的空间保真度会影响声音定位。</p>
<h4 id="高阶环境音频的用途">高阶环境音频的用途</h4>
<p>高阶环境音频通过增加更多的麦克风来增强一阶环境音频的性能效率。</p>
<h2 id="总结">总结</h2>
<p></p>
]]></description>
</item>
</channel>
</rss>
