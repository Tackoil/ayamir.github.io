<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Programming Language - 分类 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/categories/programming-language/</link>
        <description>Programming Language - 分类 - Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/categories/programming-language/" rel="self" type="application/rss+xml" /><item>
    <title>重学C&#43;&#43;：类型推导</title>
    <link>https://ayamir.github.io/posts/auto/</link>
    <pubDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/auto/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>auto</code>可以在一条语句中声明多个变量，但是所有变量的类型必须一致。</p>
</li>
<li>
<p><code>decltype</code>在分析表达式类型时并不执行表达式。</p>
</li>
<li>
<p><code>decltype</code>处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。</p>
</li>
<li>
<p><code>decltype((variable))</code>的结果永远是引用。</p>
<p><code>decltype(variable)</code>的结果只有当<code>variable</code>是引用时才是引用。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li><code>auto</code>用于变量初始化时的类型推导，<code>decltype</code>用于分析表达式的类型。</li>
<li><code>auto</code>对引用类型推导时实际上用的是引用对象的值。</li>
<li><code>auto</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
<li><code>decltype</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li><code>auto</code>尽量只在类型较长但比较清晰时使用。</li>
<li><code>decltype</code>尽量不要使用。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：Const二三事</title>
    <link>https://ayamir.github.io/posts/const/</link>
    <pubDate>Tue, 26 Oct 2021 15:53:11 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/const/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>仅用<code>const</code>修饰的对象只在单个文件中有效，如果想在多个文件之间共享<code>const</code>对象，必须在对象<strong>定义</strong>的前面加<code>extern</code>。</p>
</li>
<li>
<p>允许为一个常量引用绑定非常量的对象、字面量和表达式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>       <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>      <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 正确
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1">// 错误
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r5</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">r5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                  <span class="c1">// 正确
</span><span class="c1"></span><span class="n">r1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>                 <span class="c1">// 错误
</span></code></pre></div></li>
<li>
<p>指向常量的指针和常量指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">err_numb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">cur_err</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">err_numb</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">mut_pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="k">const</span> <span class="n">pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
</code></pre></div><p>从声明语句的变量符号开始，自右向左看：</p>
<p><code>cur_err</code>首先是一个不可变对象，其次是一个指向<code>int</code>类型可变对象的指针。</p>
<p><code>mut_pi_pointer</code>首先是一个可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
<p><code>pi_pointer</code>首先是一个不可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
</li>
<li>
<p>当<code>typedef</code>遇到<code>const</code>时容易出现错误理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p><code>pstring</code>是<code>char *</code>的别名，即指向<code>char</code>的指针。</p>
<p><code>const</code>修饰的是<code>pstring</code>，因此<code>cstr</code>是：初始化值为<code>nullptr</code>的<strong>不可变指针</strong>。</p>
<p>错误理解会用<code>char *</code>替换掉<code>pstring</code>，即：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>这样从<code>cstr</code>开始自右向左读的话，<code>cstr</code>就会被理解成：指向<strong>字符常量</strong>的<strong>可变指针</strong>。</p>
</li>
<li>
<p><code>constexpr</code>属于顶层<code>const</code>，因此<code>constexpr</code>修饰指针意味着指针本身不可变。</p>
</li>
<li>
<p><code>auto</code>默认会忽略顶层<code>const</code>，保留底层<code>const</code>，如果需要顶层<code>const</code>则需要显式加入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>       <span class="c1">// b是一个初始化值为0的可变int对象 
</span><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>       <span class="c1">// c同b
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>       <span class="c1">// d是一个初始化为指向可变int类对象i的可变指针对象
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>      <span class="c1">// e是一个初始化为指向不可变int类对象ci的可变指针对象
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// f是一个初始化值为0的不可变int对象
</span></code></pre></div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>const</code>对象在创建时必须进行初始化。</p>
</li>
<li>
<p>常量引用即对<code>const</code>对象的引用。</p>
</li>
<li>
<p>常量引用绑定<em>不可变对象</em>和<em>可变对象</em>时含义不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">可变对象</th>
<th style="text-align:center">不可变对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用常量引用绑定</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">必须</td>
</tr>
<tr>
<td style="text-align:center">常量引用的含义</td>
<td style="text-align:center">不能通过此引用改变对象的值</td>
<td style="text-align:center">不可以改变对象的值</td>
</tr>
</tbody>
</table>
<p>常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。</p>
<p>非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。</p>
</li>
<li>
<p>因为指针是对象，而引用不是对象，所以<code>const</code>和指针的组合有2种情况，<code>const</code>和引用的组合只有1种情况。</p>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）：不能通过此指针修改对应的量。</li>
<li>常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。</li>
</ul>
</li>
<li>引用
<ul>
<li>常量引用：不能通过此引用修改对应的量。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>顶层<code>const</code>表示指针本身是常量，推广之后可以指任意对象是常量；</p>
<p>底层<code>const</code>表示指针指向的对象是常量，推广之后主要于指针和引用等复合类型的基本类型部分有关。</p>
</li>
<li>
<p><strong>常量表达式</strong>指：值不会改变，在编译过程中就能得到计算结果的表达式。</p>
</li>
<li>
<p>为什么需要<code>constexpr</code>？</p>
<p>因为实际中很难判断一个初始值是否为常量表达式。</p>
<p>使用<code>constexpr</code>相当于把验证变量的值是否是一个常量表达式的工作交给了编译器。</p>
<p>用<code>constexpr</code>声明的变量一定是一个变量，并且必须用常量表达式来初始化。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>如果认定变量是一个常量表达式，那就将其声明成<code>constexpr</code>类型。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：引用和指针</title>
    <link>https://ayamir.github.io/posts/reference-and-pointer/</link>
    <pubDate>Tue, 26 Oct 2021 15:49:49 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/reference-and-pointer/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>&amp;</code>和<code>*</code>在不同的上下文里面其含义并不相同，因此<strong>完全可以当成不同的符号看待</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// &amp;在类型名后出现，是声明的一部分，表明r是一个引用
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>        <span class="c1">// *在类型名后出现，是声明的一部分，表明p是一个指针
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>        <span class="c1">// &amp;在表达式中出现，是取地址符
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>       <span class="c1">// *在表达式中出现，是解引用符
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// &amp;是声明的一部分，*是解引用符
</span></code></pre></div></li>
<li>
<p>指针可以用<code>0</code>进行初始化成空指针，但是不可以用<code>0</code>赋值。</p>
</li>
<li>
<p>指针之间使用<code>==</code>来比较时，如果结果是<code>true</code>，对应多种情况：</p>
<ul>
<li>都是空指针</li>
<li>都是同一个地址
<ul>
<li>都指向同一个对象</li>
<li>一个指针指向某一个对象，另一个指针指向另一对象的下一地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>引用和指针——都可以用于间接访问对象</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">引用</th>
<th style="text-align:center">指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复合类型</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">表示符号</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">含义</td>
<td style="text-align:center">变量的别名</td>
<td style="text-align:center">变量在内存中的地址</td>
</tr>
<tr>
<td style="text-align:center">初始化和赋值时是否需要类型匹配</td>
<td style="text-align:center">必须匹配（除常量引用）</td>
<td style="text-align:center">必须匹配（除void*和指向常量的指针）</td>
</tr>
<tr>
<td style="text-align:center">是否需要初始化</td>
<td style="text-align:center">必须初始化</td>
<td style="text-align:center">无需初始化</td>
</tr>
<tr>
<td style="text-align:center">可否重新绑定其他变量</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center">可否嵌套定义</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
</tbody>
</table>
<p>引用：</p>
<ul>
<li>引用只能<strong>绑定</strong>在对象上，不能绑定在字面量或者表达式上。</li>
<li>引用只是原有对象的<strong>别名</strong>，并非对象，因此不可以定义引用的引用。</li>
<li>定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。</li>
</ul>
<p>指针：</p>
<ul>
<li>
<p>指针本身就是一个对象，能执行的操作自由度远超过引用。</p>
<ul>
<li>
<p>可以实现嵌套定义，即指针的指针。</p>
</li>
<li>
<p>可以实现指针的引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>         <span class="c1">// p是int型指针
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// r是指针p的引用，从r开始自右向左读，&amp;表明r是一个引用，引用的是指针，指针指向的类型是int
</span><span class="c1"></span>
<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>         <span class="c1">// r是p的别名，即给p赋值为i的地址，即令p指向i
</span><span class="c1"></span><span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// r是p的别名，对r解引用即对p解引用，即将p所指向的地址处变量的值赋值为0
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>指针初始化和赋值时需要使用&amp;运算符取得对象的地址。</p>
</li>
<li>
<p>指针值的情况：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，没有指向任何对象。</li>
<li>无效指针，除上述情况之外。</li>
</ol>
<p>对第4种无效指针的操作是未定义的，后果无法预计。</p>
<p>2、3两种值虽然有效，但是因为没有指向任何对象，所以对其操作的后果同样无法预计。</p>
</li>
</ul>
</li>
<li>
<p><code>void*</code>眼中内存空间仅仅是内存空间，并不能访问内存空间中的对象。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>初始化所有的指针，并且<strong>在对象定义完成之后</strong>再定义指向它的指针。</p>
</li>
<li>
<p>避免使用<code>0</code>和<code>NULL</code>初始化空指针，应该使用<code>nullptr</code>。</p>
</li>
<li>
<p>在使用指针之前检查其是否为<code>nullptr</code>。</p>
</li>
<li>
<p><strong>记住赋值改变的永远是等号左侧的对象。</strong></p>
</li>
<li>
<p>面对复杂的指针或引用的声明语句时，从变量名开始自右向左阅读来弄清楚其真实含义。</p>
</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：类型系统基础</title>
    <link>https://ayamir.github.io/posts/cpp-types/</link>
    <pubDate>Mon, 18 Oct 2021 19:32:22 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/cpp-types/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code>都是带符号的，在前面添加<code>unsigned</code>就能得到无符号类型。</p>
</li>
<li>
<p>字符型被分为3种：<code>char</code>, <code>signed char</code>, <code>unsigned char</code>，前两种并不等价。
虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。</p>
</li>
<li>
<p>有符号类型在与无符号类型运算时会隐式转换为无符号类型。</p>
</li>
<li>
<p>虽然变量初始化时候使用了<code>=</code>号，但是初始化和变量赋值并不相同。</p>
</li>
<li>
<p>变量默认初始化：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量类型</th>
<th style="text-align:center">位置在函数内部</th>
<th style="text-align:center">位置在函数外部</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内置类型</td>
<td style="text-align:center">undefined</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">自定义类型</td>
<td style="text-align:center">由类决定</td>
<td style="text-align:center">由类决定</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">default_initialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 输出必定是0
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// 输出是随机值
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">default_initialize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>如果在函数体内部试图初始化一个<code>extern</code>标记的变量会引发错误。</p>
</li>
<li>
<p>在嵌套作用域中，内层作用域中的<strong>定义</strong>可以覆盖外层作用域中<strong>声明</strong>的变量。</p>
<p>可以显式使用<strong>域操作符</strong><code>::</code>来指明使用哪层的变量。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。</p>
</li>
<li>
<p>变量的组成部分：类型和值。说白了就是一个定性一个定量。</p>
<p>类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。</p>
<p>值在实际代码运行过程中则被各种函数使用参与运算。</p>
</li>
<li>
<p>变量声明和定义：</p>
<p>声明的意思就是：我要用这个变量。</p>
<p>定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">声明</th>
<th style="text-align:center">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">规定变量的类型和名字</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">申请空间</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">初始化</td>
<td style="text-align:center"></td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">执行多次</td>
<td style="text-align:center">✅</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>用<code>extern</code>标记<strong>未初始化</strong>的变量来表明只对变量作声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>      <span class="c1">//只声明不定义
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>             <span class="c1">//声明并且定义
</span><span class="c1"></span><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//声明并且定义
</span></code></pre></div><p>Q：为什么会有声明和定义这两个概念？</p>
<p>A：因为C++支持<em>分离式编译</em>机制，这允许程序被分割成若干个文件，每个文件可以被独立编译。如果要在多个文件中使用同一个变量，就必须要将声明和定义分离。变量的定义必须且只能出现在一个文件中，其他用到这个变量的文件必须对其进行声明，且绝对不能进行重复定义。</p>
</li>
<li>
<p>名字的作用域：</p>
<p>同一个名字在不同的作用域中可以指向不同的实体。</p>
<p>名字的有效区域始于<strong>声明</strong>语句，以<strong>声明</strong>语句所在的作用域末端结束。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>明确数值不可能为负时使用<code>unsigned</code>类型。</p>
</li>
<li>
<p>使用<code>int</code>执行整数运算，范围不够时使用<code>long long</code>。</p>
</li>
<li>
<p>使用<code>double</code>执行浮点数运算。</p>
</li>
<li>
<p>算术表达式中不要使用<code>bool</code>和<code>char</code>。</p>
</li>
<li>
<p>避免写出依赖实现环境的代码，否则代码不可移植。</p>
</li>
<li>
<p>避免有符号类型和无符号类型之间的隐式类型转换。</p>
</li>
<li>
<p>C++11中引入了<strong>列表初始化</strong>，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="c1">// 传统的初始化方式
</span><span class="c1"></span><span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">units_sold</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 现代的初始化方式
</span><span class="c1"></span><span class="kt">int</span> <span class="n">units_sold</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</code></pre></div><p>列表初始化在用于内置类型变量时，如果初始值存在<em>丢失信息</em>的风险，编译器会报错。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">long</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415926536</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="n">pi</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="n">pi</span><span class="p">};</span>   <span class="c1">// 错误：没有执行类型转换，因为可能丢失信息
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">a</span><span class="p">(</span><span class="n">pi</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span>     <span class="c1">// 正确：执行了隐式类型转化，丢失了信息
</span></code></pre></div></li>
<li>
<p>对每个内置类型的变量都执行<strong>显式默认初始化</strong>以防止undefined行为。</p>
</li>
<li>
<p>在变量第一次使用的地方进行<strong>定义</strong>操作。</p>
</li>
</ol>
]]></description>
</item><item>
    <title>Python selenium settings on microsoft-edge-dev</title>
    <link>https://ayamir.github.io/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/</link>
    <pubDate>Fri, 26 Mar 2021 21:43:35 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/python-selenium-settings-on-microsoft-edge-dev-on-linux/</guid>
    <description><![CDATA[<h2 id="get-correct-version">Get Correct Version</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">microsoft-edge-dev --version
</code></pre></div><p>The output is <code>Microsoft Edge 91.0.831.1 dev</code> in my case.</p>
<h2 id="get-corresponding-webdriver">Get Corresponding WebDriver</h2>
<p>Find the corresponding version at <a href="https://msedgewebdriverstorage.z22.web.core.windows.net/" target="_blank" rel="noopener noreffer">msedgewebdriverstorage</a> and download the zip.</p>
<p>Extract it to you path like <code>/usr/local/bin</code> or <code>$HOME/.local/bin</code>.</p>
<h2 id="write-code">Write Code</h2>
<p>Following is a example.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">msedge.selenium_tools</span> <span class="kn">import</span> <span class="n">EdgeOptions</span><span class="p">,</span> <span class="n">Edge</span>

<span class="n">options</span> <span class="o">=</span> <span class="n">EdgeOptions</span><span class="p">()</span>
<span class="n">options</span><span class="o">.</span><span class="n">use_chromium</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">options</span><span class="o">.</span><span class="n">binary_location</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&#34;/usr/bin/microsoft-edge-dev&#34;</span>
<span class="n">options</span><span class="o">.</span><span class="n">set_capability</span><span class="p">(</span><span class="s2">&#34;platform&#34;</span><span class="p">,</span> <span class="s2">&#34;LINUX&#34;</span><span class="p">)</span>

<span class="n">webdriver_path</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&#34;/home/ayamir/.local/bin/msedgewebdriver&#34;</span>

<span class="n">browser</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">executable_path</span><span class="o">=</span><span class="n">webdriver_path</span><span class="p">)</span>
<span class="n">browser</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;http://localhost:8000&#34;</span><span class="p">)</span>

<span class="k">assert</span> <span class="s2">&#34;Django&#34;</span> <span class="ow">in</span> <span class="n">browser</span><span class="o">.</span><span class="n">title</span>
</code></pre></div><h2 id="launch-it">Launch it</h2>
<p></p>
]]></description>
</item></channel>
</rss>
