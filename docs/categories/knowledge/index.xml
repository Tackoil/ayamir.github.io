<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Knowledge - 分类 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/categories/knowledge/</link>
        <description>Knowledge - 分类 - Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Thu, 18 Apr 2024 17:33:24 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/categories/knowledge/" rel="self" type="application/rss+xml" /><item>
    <title>Jitter Buffer学习理解（上）</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/</link>
    <pubDate>Thu, 18 Apr 2024 17:33:24 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/</guid>
    <description><![CDATA[<h2 id="jitter-buffer-是什么">Jitter Buffer 是什么</h2>
<p>在了解 Jitter Buffer 之前，我们应该先来看一下整个 webrtc 会话中数据传输的完整流程。</p>
<p></p>
<p>与传输相关的部分主要出现在 pacer 和 Jitter Buffer 这两个部分，从图中可以清晰的看到这两者处于编解码和网络传输之间，考虑到编解码可能会引入突变的帧大小（比如 I 帧），而在网络传输的过程又受到网络传输速率和排队延迟的影响，所以它们的作用其实就比较显而易见了。Pacer 在发送端负责平滑编码后的码流打包成 rtp 包之后，发送到网络上的速率；Jitter Buffer 在接收端负责平滑接收到的 rtp 包到组成解码所需的码流的过程。</p>
<p>当然，这个传输的过程中离开不了拥塞控制算法如 gcc 和各种抗丢包的技术如 nack，fec 等来保障实时通信质量。在这里我们主要关注传输的流程，相关算法和机制之后再研究。</p>
<p>Jitter Buffer 可以理解为有两部分的功能，一部分是 Buffer 的功能，也就是作为 rtp 包的缓冲区，并且将 rtp 包恢复成表示可解码帧的码流；另一部分是 Jitter 的功能，也就是通过引入延迟来平滑因帧大小和网络状况而造成的接收帧不均匀的情况。</p>
<h2 id="buffer-的工作流程">buffer 的工作流程</h2>
<p>正如前面所说，网络传输的是 rtp 包，而解码器的输入是可以解码的码流，所以需要一个将 rtp 包转换成可以解码的帧的过程。因为一个帧由多个 rtp 包组成，所以肯定需要缓冲区来存放前面收到但是还不足以组成一个帧的 rtp 包，这个缓冲区在 webrtc 中其实就是<code>PacketBuffer</code>。此外，考虑到编解码原理，接收到的 P 帧还需要等它所依赖的 I 帧/P 帧被解码，它才能被解码，所以在<code>PacketBuffer</code>之外还需要一个<code>FrameBuffer</code>来缓存可以解码的一个 GOP 中的各个帧。而负责寻找当前帧所依赖帧的是<code>RtpFrameReferenceFinder</code>，因为这个寻找依赖帧的过程实际上是递归依赖的，直到找到一个 GOP 的 IDR 帧才算结束，这样就能得到按照解码依赖顺序排列的一个 GOP。而最后，因为不同 GOP 的解码是独立的，所以 GOP 之间实际上就直接按照时间顺序排列就完成了 GOP 的排序。</p>
<p>总体上来看，buffer 负责的工作就是 3 个：rtp 包的排序并组成帧、帧的排序并组成 GOP、GOP 的排序并组成视频。</p>
<h2 id="代码实现">代码实现</h2>
<p>结合代码逻辑来看一下实际的工作流程，最核心的类是<code>RtpVideoStreamReceiver2</code>，这个类负责完成上面所说的工作内容的实现与逻辑的拆分，不过除了上面这些逻辑之外，这个类还需要向发送端发送 rtcp 反馈包的工作，比如 nack, pli, fir。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RtpVideoStreamReceiver2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LossNotificationSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RecoveredPacketReceiver</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RtpPacketSinkInterface</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">KeyFrameRequestSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">NackSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">OnDecryptedFrameCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">OnDecryptionStatusChangeCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RtpVideoFrameReceiver</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// A complete frame is a frame which has received all its packets and all its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// references are known.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">OnCompleteFrameCallback</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">OnCompleteFrameCallback</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpVideoStreamReceiver2</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">current_queue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clock</span><span class="o">*</span> <span class="n">clock</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">Transport</span><span class="o">*</span> <span class="n">transport</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpRttStats</span><span class="o">*</span> <span class="n">rtt_stats</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The packet router is optional; if provided, the RtpRtcp module for this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// stream is registered as a candidate for sending REMB and transport
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// feedback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">PacketRouter</span><span class="o">*</span> <span class="n">packet_router</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">VideoReceiveStreamInterface</span><span class="o">::</span><span class="n">Config</span><span class="o">*</span> <span class="n">config</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">ReceiveStatistics</span><span class="o">*</span> <span class="n">rtp_receive_statistics</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpPacketTypeCounterObserver</span><span class="o">*</span> <span class="n">rtcp_packet_type_counter_observer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpCnameCallback</span><span class="o">*</span> <span class="n">rtcp_cname_callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">NackPeriodicProcessor</span><span class="o">*</span> <span class="n">nack_periodic_processor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The KeyFrameRequestSender is optional; if not provided, key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// requests are sent via the internal RtpRtcp module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">OnCompleteFrameCallback</span><span class="o">*</span> <span class="n">complete_frame_callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameDecryptorInterface</span><span class="o">&gt;</span> <span class="n">frame_decryptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameTransformerInterface</span><span class="o">&gt;</span> <span class="n">frame_transformer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">FieldTrialsView</span><span class="o">&amp;</span> <span class="n">field_trials</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcEventLog</span><span class="o">*</span> <span class="n">event_log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">RtpVideoStreamReceiver2</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">AddReceiveCodec</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">payload_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">VideoCodecType</span> <span class="n">video_codec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CodecParameterMap</span><span class="o">&amp;</span> <span class="n">codec_params</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">bool</span> <span class="n">raw_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Clears state for all receive codecs added via `AddReceiveCodec`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">RemoveReceiveCodecs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">StartReceive</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">StopReceive</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Produces the transport-related timestamps; current_delay_ms is left unset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Syncable</span><span class="o">::</span><span class="n">Info</span><span class="o">&gt;</span> <span class="n">GetSyncInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">DeliverRtcp</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">rtcp_packet</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">rtcp_packet_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">FrameContinuous</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">FrameDecoded</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SignalNetworkState</span><span class="p">(</span><span class="n">NetworkState</span> <span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns number of different frames seen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">GetUniqueFramesSeen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">frame_counter_</span><span class="p">.</span><span class="n">GetUniqueSeen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RtpPacketSinkInterface.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnRtpPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Public only for tests.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Returns true if the packet should be stashed and retried at a later stage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">OnReceivedPayloadData</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span> <span class="n">codec_payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">int</span> <span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RecoveredPacketReceiver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnRecoveredPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Send an RTCP keyframe request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">RequestKeyFrame</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements NackSender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SendNack</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;&amp;</span> <span class="n">sequence_numbers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements LossNotificationSender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SendLossNotification</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns true if a decryptor is attached and frames can be decrypted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Updated by OnDecryptionStatusChangeCallback. Note this refers to Frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Decryption not SRTP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">IsDecryptable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements OnDecryptedFrameCallback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnDecryptedFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements OnDecryptionStatusChangeCallback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnDecryptionStatusChange</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrameDecryptorInterface</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Optionally set a frame decryptor after a stream has started. This will not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reset the decoder state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetFrameDecryptor</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameDecryptorInterface</span><span class="o">&gt;</span> <span class="n">frame_decryptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Sets a frame transformer after a stream has started, if no transformer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// has previously been set. Does not reset the decoder state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetDepacketizerToDecoderFrameTransformer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameTransformerInterface</span><span class="o">&gt;</span> <span class="n">frame_transformer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Called by VideoReceiveStreamInterface when stats are updated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">UpdateRtt</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">max_rtt_ms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Called when the local_ssrc is changed to match with a sender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnLocalSsrcChange</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">local_ssrc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Forwards the call to set rtcp_sender_ to the RTCP mode of the rtcp sender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetRtcpMode</span><span class="p">(</span><span class="n">RtcpMode</span> <span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetReferenceTimeReport</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Sets or clears the callback sink that gets called for RTP packets. Used for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// packet handlers such as FlexFec. Must be called on the packet delivery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread (same context as `OnRtpPacket` is called on).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TODO(bugs.webrtc.org/11993): Packet delivery thread today means `worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread` but will be `network thread`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetPacketSink</span><span class="p">(</span><span class="n">RtpPacketSinkInterface</span><span class="o">*</span> <span class="n">packet_sink</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Turns on/off loss notifications. Must be called on the packet delivery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetLossNotificationEnabled</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetNackHistory</span><span class="p">(</span><span class="n">TimeDelta</span> <span class="n">history</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">ulpfec_payload_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">red_payload_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetProtectionPayloadTypes</span><span class="p">(</span><span class="kt">int</span> <span class="n">red_payload_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ulpfec_payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">LastReceivedPacketMs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">LastReceivedFrameRtpTimestamp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">LastReceivedKeyframePacketMs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">RtpRtcpInterface</span><span class="o">::</span><span class="n">SenderReportStats</span><span class="o">&gt;</span> <span class="n">GetSenderReportStats</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RtpVideoFrameReceiver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnCompleteFrames</span><span class="p">(</span><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Used for buffering RTCP feedback messages and sending them all together.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Note:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 1. Key frame requests and NACKs are mutually exclusive, with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    former taking precedence over the latter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 2. Loss notifications are orthogonal to either. (That is, may be sent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    alongside either.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">RtcpFeedbackBuffer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">KeyFrameRequestSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">public</span> <span class="n">NackSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">public</span> <span class="n">LossNotificationSender</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtcpFeedbackBuffer</span><span class="p">(</span><span class="n">KeyFrameRequestSender</span><span class="o">*</span> <span class="n">key_frame_request_sender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">NackSender</span><span class="o">*</span> <span class="n">nack_sender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">LossNotificationSender</span><span class="o">*</span> <span class="n">loss_notification_sender</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">RtcpFeedbackBuffer</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// KeyFrameRequestSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">RequestKeyFrame</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NackSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendNack</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;&amp;</span> <span class="n">sequence_numbers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// LossNotificationSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendLossNotification</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Send all RTCP feedback messages buffered thus far.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">ClearLossNotificationState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// LNTF-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">LossNotificationState</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LossNotificationState</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">:</span> <span class="n">last_decoded_seq_num</span><span class="p">(</span><span class="n">last_decoded_seq_num</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_received_seq_num</span><span class="p">(</span><span class="n">last_received_seq_num</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">decodability_flag</span><span class="p">(</span><span class="n">decodability_flag</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">packet_sequence_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyFrameRequestSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">key_frame_request_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">NackSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">nack_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LossNotificationSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">loss_notification_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Key-frame-request-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">request_key_frame_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NACK-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">nack_sequence_numbers_</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">LossNotificationState</span><span class="o">&gt;</span> <span class="n">lntf_state_</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="nc">ParseGenericDependenciesResult</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">kStashPacket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kDropPacket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kHasGenericDescriptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kNoGenericDescriptor</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Entry point doing non-stats work for a received packet. Called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for the same packet both before and after RED decapsulation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">ReceivePacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Parses and handles RED headers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This function assumes that it&#39;s being called from only one thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">ParseAndHandleEncapsulatingHeader</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">IsRedEnabled</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">InsertSpsPpsIntoTracker</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">payload_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnInsertedPacket</span><span class="p">(</span><span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ParseGenericDependenciesResult</span> <span class="nf">ParseGenericDependenciesExtension</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTPVideoHeader</span><span class="o">*</span> <span class="n">video_header</span><span class="p">)</span> <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnAssembledFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">UpdatePacketReceiveTimestamps</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="kt">bool</span> <span class="n">is_keyframe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">FieldTrialsView</span><span class="o">&amp;</span> <span class="n">field_trials_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">worker_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Clock</span><span class="o">*</span> <span class="k">const</span> <span class="n">clock_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Ownership of this object lies with VideoReceiveStreamInterface, which owns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `this`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">VideoReceiveStreamInterface</span><span class="o">::</span><span class="n">Config</span><span class="o">&amp;</span> <span class="n">config_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">PacketRouter</span><span class="o">*</span> <span class="k">const</span> <span class="n">packet_router_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RemoteNtpTimeEstimator</span> <span class="n">ntp_estimator_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Set by the field trial WebRTC-ForcePlayoutDelay to override any playout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// delay that is specified in the received packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FieldTrialOptional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forced_playout_delay_max_ms_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FieldTrialOptional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forced_playout_delay_min_ms_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ReceiveStatistics</span><span class="o">*</span> <span class="k">const</span> <span class="n">rtp_receive_statistics_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">UlpfecReceiver</span><span class="o">&gt;</span> <span class="n">ulpfec_receiver_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">red_payload_type_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">worker_task_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(bugs.webrtc.org/11993): This checker conceptually represents
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// operations that belong to the network thread. The Call class is currently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// moving towards handling network packets on the network thread and while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that work is ongoing, this checker may in practice represent the worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread, but still serves as a mechanism of grouping together concepts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that belong to the network thread. Once the packets are fully delivered
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the network thread, this comment will be deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">packet_sequence_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketSinkInterface</span><span class="o">*</span> <span class="n">packet_sink_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">receiving_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">last_packet_log_ms_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ModuleRtpRtcpImpl2</span><span class="o">&gt;</span> <span class="n">rtp_rtcp_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">NackPeriodicProcessor</span><span class="o">*</span> <span class="k">const</span> <span class="n">nack_periodic_processor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">OnCompleteFrameCallback</span><span class="o">*</span> <span class="n">complete_frame_callback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">KeyFrameReqMethod</span> <span class="n">keyframe_request_method_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtcpFeedbackBuffer</span> <span class="n">rtcp_feedback_buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(tommi): Consider absl::optional&lt;NackRequester&gt; instead of unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// since nack is usually configured.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">NackRequester</span><span class="o">&gt;</span> <span class="n">nack_module_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LossNotificationController</span><span class="o">&gt;</span> <span class="n">loss_notification_controller_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span> <span class="n">packet_buffer_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// h26x_packet_buffer_ is nullptr if codec list doens&#39;t contain H.264 or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// H.265, or field trial WebRTC-Video-H26xPacketBuffer is not enabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">H26xPacketBuffer</span><span class="o">&gt;</span> <span class="n">h26x_packet_buffer_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">UniqueTimestampCounter</span> <span class="n">frame_counter_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">SeqNumUnwrapper</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">frame_id_unwrapper_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Video structure provided in the dependency descriptor in a first packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// of a key frame. It is required to parse dependency descriptor in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// following delta packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FrameDependencyStructure</span><span class="o">&gt;</span> <span class="n">video_structure_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Frame id of the last frame with the attached video structure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// absl::nullopt when `video_structure_ == nullptr`;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">video_structure_frame_id_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">last_logged_failed_to_parse_dd_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">)</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">MinusInfinity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameReferenceFinder</span><span class="o">&gt;</span> <span class="n">reference_finder_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoCodecType</span><span class="o">&gt;</span> <span class="n">current_codec_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">last_assembled_frame_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">last_seq_num_for_pic_id_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span> <span class="n">tracker_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Maps payload id to the depacketizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VideoRtpDepacketizer</span><span class="o">&gt;&gt;</span> <span class="n">payload_type_map_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(johan): Remove pt_codec_params_ once
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// https://bugs.chromium.org/p/webrtc/issues/detail?id=6883 is resolved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Maps a payload type to a map of out-of-band supplied codec parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CodecParameterMap</span><span class="o">&gt;</span> <span class="n">pt_codec_params_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int16_t</span> <span class="n">last_payload_type_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">has_received_frame_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">last_received_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">last_received_keyframe_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;</span> <span class="n">last_received_rtp_system_time_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;</span> <span class="n">last_received_keyframe_rtp_system_time_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Handles incoming encrypted frames and forwards them to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// rtp_reference_finder if they are decryptable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BufferedFrameDecryptor</span><span class="o">&gt;</span> <span class="n">buffered_frame_decryptor_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_PT_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">frames_decryptable_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">worker_task_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ColorSpace</span><span class="o">&gt;</span> <span class="n">last_color_space_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">AbsoluteCaptureTimeInterpolator</span> <span class="n">absolute_capture_time_interpolator_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CaptureClockOffsetUpdater</span> <span class="n">capture_clock_offset_updater_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">last_completed_picture_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">RtpVideoStreamReceiverFrameTransformerDelegate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame_transformer_delegate_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SeqNumUnwrapper</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">rtp_seq_num_unwrapper_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">RtpPacketInfo</span><span class="o">&gt;</span> <span class="n">packet_infos_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RtpPacketReceived</span><span class="o">&gt;</span> <span class="n">stashed_packets_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">Timestamp</span><span class="o">::</span><span class="n">MinusInfinity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的<code>OnRtpPacket</code>方法实现了<code>RtpPacketSinkInterface</code>这一接口，负责完成前面提到的 buffer 的第一个工作内容：接收 rtp 包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// This method handles both regular RTP packets and packets recovered
</span></span></span><span class="line"><span class="cl"><span class="c1">// via FlexFEC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">receiving_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ReceivePacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Update receive statistics after ReceivePacket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Receive statistics will be reset if the payload type changes (make sure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that the first packet is included in the stats).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtp_receive_statistics_</span><span class="o">-&gt;</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet_sink_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_sink_</span><span class="o">-&gt;</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，用于接收普通 rtp 包的方法为<code>ReceivePacket</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">ReceivePacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">payload_size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Padding or keep-alive packet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO(nisse): Could drop empty packets earlier, but need to figure out how
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// they should be counted in stats.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadType</span><span class="p">()</span> <span class="o">==</span> <span class="n">red_payload_type_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ParseAndHandleEncapsulatingHeader</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span> <span class="n">type_it</span> <span class="o">=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">type_it</span> <span class="o">==</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">parse_and_insert</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoRtpDepacketizer</span><span class="o">::</span><span class="n">ParsedRtpPayload</span><span class="o">&gt;</span> <span class="n">parsed_payload</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">type_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Parse</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadBuffer</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">parsed_payload</span> <span class="o">==</span> <span class="n">absl</span><span class="o">::</span><span class="n">nullopt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed parsing payload.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times_nacked</span> <span class="o">=</span> <span class="n">nack_module_</span>
</span></span><span class="line"><span class="cl">                           <span class="o">?</span> <span class="n">nack_module_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="n">packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                           <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">OnReceivedPayloadData</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">parsed_payload</span><span class="o">-&gt;</span><span class="n">video_payload</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">packet</span><span class="p">,</span> <span class="n">parsed_payload</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// When the dependency descriptor is used and the descriptor fail to parse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// then `OnReceivedPayloadData` may return true to signal the the packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// should be retried at a later stage, which is why they are stashed here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TODO(bugs.webrtc.org/15782):
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is an ugly solution. The way things should work is for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `RtpFrameReferenceFinder` to stash assembled frames until the keyframe with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the relevant template structure has been received, but unfortunately the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `frame_transformer_delegate_` is called before the frames are inserted into
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the `RtpFrameReferenceFinder`, and it expects the dependency descriptor to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// be parsed at that stage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">parse_and_insert</span><span class="p">(</span><span class="n">packet</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stashed_packets_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">parse_and_insert</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">it</span><span class="p">;</span>  <span class="c1">// keep in the stash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">it</span> <span class="o">=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>parse_and_insert()</code>中，首先将 packet 的<code>PayloadBuffer</code>移动到<code>parsed_payload</code>中，并且计算发送的 nack 的数量，然后将<code>parsed_payload</code>和<code>times_nacked</code>传入<code>OnReceivedPayloadData</code>来完成真正的 packet 解析和 frame 组装的工作。在下面<code>parse_and_insert</code>的使用过程，其实就是利用一个大小为 100 的 vector 来完成递归解析和组装属于同一个 frame 的 packet 的过程。这里的<code>OnReceivedPayloadData</code>的返回值表示的就是当前 packet 所属的帧有没有被解析完。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnReceivedPayloadData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span> <span class="n">codec_payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times_nacked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">packet</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">,</span> <span class="n">video</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">unwrapped_rtp_seq_num</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketInfo</span><span class="o">&amp;</span> <span class="n">packet_info</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">packet_infos_</span>
</span></span><span class="line"><span class="cl">          <span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">RtpPacketInfo</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">Ssrc</span><span class="p">(),</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Csrcs</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                 <span class="cm">/*receive_time_ms=*/</span><span class="n">clock_</span><span class="o">-&gt;</span><span class="n">CurrentTime</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">          <span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to extrapolate absolute capture time if it is missing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">packet_info</span><span class="p">.</span><span class="n">set_absolute_capture_time</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">absolute_capture_time_interpolator_</span><span class="p">.</span><span class="n">OnReceivePacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">AbsoluteCaptureTimeInterpolator</span><span class="o">::</span><span class="n">GetSource</span><span class="p">(</span><span class="n">packet_info</span><span class="p">.</span><span class="n">ssrc</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                                     <span class="n">packet_info</span><span class="p">.</span><span class="n">csrcs</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">          <span class="n">packet_info</span><span class="p">.</span><span class="n">rtp_timestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Assume frequency is the same one for all video frames.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">kVideoPayloadTypeFrequency</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">AbsoluteCaptureTimeExtension</span><span class="o">&gt;</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet_info</span><span class="p">.</span><span class="n">absolute_capture_time</span><span class="p">().</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_info</span><span class="p">.</span><span class="n">set_local_capture_clock_offset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">capture_clock_offset_updater_</span><span class="p">.</span><span class="n">ConvertsToTimeDela</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">capture_clock_offset_updater_</span><span class="p">.</span><span class="n">AdjustEstimatedCaptureClockOffset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">packet_info</span><span class="p">.</span><span class="n">absolute_capture_time</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="o">-&gt;</span><span class="n">estimated_capture_clock_offset</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video_header</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">kVideoRotation_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span> <span class="o">=</span> <span class="n">VideoContentType</span><span class="o">::</span><span class="n">UNSPECIFIED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VideoSendTiming</span><span class="o">::</span><span class="n">kInvalid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span> <span class="o">|=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Marker</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoOrientation</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoContentTypeExtension</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoTimingExtension</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">forced_playout_delay_max_ms_</span> <span class="o">&amp;&amp;</span> <span class="n">forced_playout_delay_min_ms_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span><span class="p">.</span><span class="n">emplace</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Millis</span><span class="p">(</span><span class="o">*</span><span class="n">forced_playout_delay_min_ms_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Millis</span><span class="p">(</span><span class="o">*</span><span class="n">forced_playout_delay_max_ms_</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span> <span class="o">=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">PlayoutDelayLimits</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UpdatePacketReceiveTimestamps</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtp_packet</span><span class="p">,</span> <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ParseGenericDependenciesResult</span> <span class="n">generic_descriptor_state</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">ParseGenericDependenciesExtension</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">video_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kStashPacket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kDropPacket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Timestamp</span> <span class="n">now</span> <span class="o">=</span> <span class="n">clock_</span><span class="o">-&gt;</span><span class="n">CurrentTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">last_logged_failed_to_parse_dd_</span> <span class="o">&gt;</span> <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_logged_failed_to_parse_dd_</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ssrc: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Ssrc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                          <span class="o">&lt;&lt;</span> <span class="s">&#34; Failed to parse dependency descriptor.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">video_structure_</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// No video structure received yet, most likely part of the initial
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// keyframe was lost.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">now</span> <span class="o">+</span> <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Color space should only be transmitted in the last packet of a frame,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// therefore, neglect it otherwise so that last_color_space_ is not reset by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// mistake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">ColorSpaceExtension</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Store color space since it&#39;s only transmitted when changed or for key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// frames. Color space will be cleared if a key frame is transmitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// without color space information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">last_color_space_</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">last_color_space_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">=</span> <span class="n">last_color_space_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">video_frame_tracking_id</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoFrameTrackingIdExtension</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">loss_notification_controller_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// TODO(bugs.webrtc.org/10336): Implement support for reordering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_INFO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34;LossNotificationController does not support reordering.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kNoGenericDescriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;LossNotificationController requires generic &#34;</span>
</span></span><span class="line"><span class="cl">                             <span class="s">&#34;frame descriptor, but it is missing.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_first_packet_in_frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">LossNotificationController</span><span class="o">::</span><span class="n">FrameDetails</span> <span class="n">frame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">is_keyframe</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">frame_id</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="o">-&gt;</span><span class="n">frame_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">frame_dependencies</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span> <span class="o">=</span> <span class="n">times_nacked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">codec_payload</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Only when we start to receive packets will we know what payload type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// that will be used. When we know the payload type insert the correct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sps/pps into the tracker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span> <span class="o">!=</span> <span class="n">last_payload_type_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_payload_type_</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">InsertSpsPpsIntoTracker</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">h26x_packet_buffer_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="n">FixedBitstream</span> <span class="n">fixed</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">tracker_</span><span class="p">.</span><span class="n">CopyAndFixBitstream</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtc</span><span class="o">::</span><span class="n">MakeArrayView</span><span class="p">(</span><span class="n">codec_payload</span><span class="p">.</span><span class="n">cdata</span><span class="p">(),</span> <span class="n">codec_payload</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">fixed</span><span class="p">.</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kRequestKeyframe</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="na">[[fallthrough]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kInsert</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fixed</span><span class="p">.</span><span class="n">bitstream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">codec_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">frame_counter_</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">       <span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH265</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h26x_packet_buffer_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnInsertedPacket</span><span class="p">(</span><span class="n">h26x_packet_buffer_</span><span class="o">-&gt;</span><span class="n">InsertPacket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnInsertedPacket</span><span class="p">(</span><span class="n">packet_buffer_</span><span class="p">.</span><span class="n">InsertPacket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个方法的核心判断的逻辑在于利用<code>ParseGenericDependenciesExtension</code>来判断当前 packet 的依赖类型，对于正常的依赖类型<code>kHasGenericDescriptor</code>，调用<code>InsertPacket</code>将 packet 插入到<code>PacketBuffer</code>中，并将<code>InsertPacket</code>的返回值作为<code>OnInsertedPacket</code>的参数来组帧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint16_t</span> <span class="n">seq_num</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_packet_received_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_packet_received_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">first_seq_num_</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If we have explicitly cleared past this packet then it&#39;s old,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// don&#39;t insert it, just silently ignore it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">is_cleared_to_first_seq_num_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ForwardDiff</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first_seq_num_</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Large negative jump in rtp sequence number: clear the buffer and treat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// latest packet as the new first packet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">first_packet_received_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">first_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Duplicate packet, just delete the payload.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">seq_num</span> <span class="o">==</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The packet buffer is full, try to expand the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">ExpandBufferSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Packet buffer is still full since we were unable to expand the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Clear the buffer, delete payload, and return false to signal that a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// new keyframe is needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Clear PacketBuffer and request key frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ClearInternal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">result</span><span class="p">.</span><span class="n">buffer_cleared</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">continuous</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">UpdateMissingPackets</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">received_padding_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">received_padding_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="n">received_padding_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">seq_num</span> <span class="o">-</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">result</span><span class="p">.</span><span class="n">packets</span> <span class="o">=</span> <span class="n">FindFrames</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>InsertPacket</code>的过程其实就是：首先判断是不是当前 packet 首包，是的话就记录一下，接下来的包开始往后排序，不是的话就调用包序列号比较函数 AheadOf。在利用索引计算的包在缓存中的位置如果被占用并且序列号一样，就是重复包，丢掉。如果被占用但是序列号不相同，就说明缓存满了，需要扩容，重新计算包的索引值，扩容后还是满的就要情况缓存了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">UpdateMissingPackets</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newest_inserted_seq_num_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">newest_inserted_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">kMaxPaddingAge</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">old_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">-</span> <span class="n">kMaxPaddingAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">erase_to</span> <span class="o">=</span> <span class="n">missing_packets_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">old_seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">erase_to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Guard against inserting a large amount of missing packets if there is a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// jump in the sequence number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">old_seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">newest_inserted_seq_num_</span> <span class="o">=</span> <span class="n">old_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">++*</span><span class="n">newest_inserted_seq_num_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">missing_packets_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">++*</span><span class="n">newest_inserted_seq_num_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>UpdateMissingPackets</code>主要是利用<code>missing_packets_</code>来维护丢包缓存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;&gt;</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">FindFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;&gt;</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">received_padding_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">seq_num</span><span class="p">)</span> <span class="o">!=</span> <span class="n">received_padding_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">seq_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PotentialNewFrame</span><span class="p">(</span><span class="n">seq_num</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">continuous</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If all packets of the frame is continuous, find the first packet of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// frame and add all packets of the frame to the returned packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">start_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Find the start index by searching backward until the packet with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `frame_begin` flag is set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">int</span> <span class="n">start_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">size_t</span> <span class="n">tested_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int64_t</span> <span class="n">frame_timestamp</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Identify H.264 keyframes by means of SPS, PPS, and IDR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">bool</span> <span class="n">is_generic</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">.</span><span class="n">has_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">is_h264_descriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_sps</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_pps</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_idr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">is_h264_keyframe</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">idr_width</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">idr_height</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">full_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">tested_packets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果是VPX，并且找到了frame_begin标识的第一个包，一帧完整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">              <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">full_frame_found</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">h264_header</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderH264</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h264_header</span> <span class="o">||</span> <span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus_length</span> <span class="o">&gt;=</span> <span class="n">kMaxNalusPerPacket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus_length</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kSps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_sps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kPps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_pps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kIdr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_idr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">((</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_idr</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_sps</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">               <span class="n">has_h264_pps</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="o">!</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_idr</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is_h264_keyframe</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Store the resolution of key frame which is the packet with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// smallest index and valid resolution; typically its IDR or SPS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// packet; there may be packet preceeding this packet, IDR&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// resolution will be applied to them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">idr_width</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">              <span class="n">idr_height</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tested_packets</span> <span class="o">==</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">start_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">start_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// In the case of H264 we don&#39;t have a frame_begin bit (yes,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// `frame_begin` might be set to true but that is a lie). So instead
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// we traverese backwards as long as we have a previous packet and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the timestamp of that packet is the same as this one. This may cause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the PacketBuffer to hand out incomplete frames.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// See: https://bugs.chromium.org/p/webrtc/issues/detail?id=7106
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">             <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">!=</span> <span class="n">frame_timestamp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">start_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Warn if this is an unsafe frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">has_h264_idr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">has_h264_sps</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_h264_pps</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34;Received H.264-IDR frame &#34;</span>
</span></span><span class="line"><span class="cl">                 <span class="s">&#34;(SPS: &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="n">has_h264_sps</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, PPS: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">has_h264_pps</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;). Treating as &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">?</span> <span class="s">&#34;delta&#34;</span> <span class="o">:</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; frame since WebRTC-SpsPpsIdrIsH264Keyframe is &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">?</span> <span class="s">&#34;enabled.&#34;</span> <span class="o">:</span> <span class="s">&#34;disabled&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Now that we have decided whether to treat this frame as a key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// or delta frame in the frame buffer, we update the field that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// determines if the RtpFrameObject is a key frame or delta frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_t</span> <span class="n">first_packet_index</span> <span class="o">=</span> <span class="n">start_seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_keyframe</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">idr_width</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idr_height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// IDR frame was finalized and we have the correct resolution for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// IDR; update first packet to have same resolution as IDR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">idr_width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">idr_height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If this is not a keyframe, make sure there are no gaps in the packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sequence numbers up until this point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_h264_keyframe</span> <span class="o">&amp;&amp;</span> <span class="n">missing_packets_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">start_seq_num</span><span class="p">)</span> <span class="o">!=</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span> <span class="o">||</span> <span class="n">full_frame_found</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">end_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Use uint16_t type to handle sequence number wrap around case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">uint16_t</span> <span class="n">num_packets</span> <span class="o">=</span> <span class="n">end_seq_num</span> <span class="o">-</span> <span class="n">start_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">found_frames</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">found_frames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">num_packets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start_seq_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">end_seq_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;&amp;</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_DCHECK_EQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Ensure frame boundary flags are properly set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_first_packet_in_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">start_seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">found_frames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="n">missing_packets_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">seq_num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">received_padding_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">received_padding_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                <span class="n">received_padding_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">seq_num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>FindFrames</code>的主要工作是检测帧的完整性，具体的实现方式是遍历排序缓存中连续的包，来检查一帧的边界，并且对于 VPX 和 H264 的处理做了区分。对于 VPX，通过检测 frame_begin 和 frame_end 这两个包来确定收到了一个完整的帧，而对于 H264 则通过从 frame_end 标识的一帧最后一个包向前追溯，直到找到一个时间戳不一样的断层，认为找到了完整的一个 H264 的帧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnInsertedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_task_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">*</span> <span class="n">first_packet</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">max_nack_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">min_recv_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">max_recv_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;&gt;</span> <span class="n">payloads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketInfos</span><span class="o">::</span><span class="n">vector_type</span> <span class="n">packet_infos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">frame_boundary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">packet</span> <span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">packets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// PacketBuffer promisses frame boundaries are correctly set on each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// packet. Document that assumption with the DCHECKs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">RTC_DCHECK_EQ</span><span class="p">(</span><span class="n">frame_boundary</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">unwrapped_rtp_seq_num</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_GT</span><span class="p">(</span><span class="n">packet_infos_</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpPacketInfo</span><span class="o">&amp;</span> <span class="n">packet_info</span> <span class="o">=</span> <span class="n">packet_infos_</span><span class="p">[</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">first_packet</span> <span class="o">=</span> <span class="n">packet</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_nack_count</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">min_recv_time</span> <span class="o">=</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_recv_time</span> <span class="o">=</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_nack_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_nack_count</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">min_recv_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">min_recv_time</span><span class="p">,</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_recv_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_recv_time</span><span class="p">,</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">payloads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_infos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">packet_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">frame_boundary</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">depacketizer_it</span> <span class="o">=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_CHECK</span><span class="p">(</span><span class="n">depacketizer_it</span> <span class="o">!=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_CHECK</span><span class="p">(</span><span class="n">depacketizer_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">EncodedImageBuffer</span><span class="o">&gt;</span> <span class="n">bitstream</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">depacketizer_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">AssembleFrame</span><span class="p">(</span><span class="n">payloads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitstream</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Failed to assemble a frame. Discard and continue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&amp;</span> <span class="n">last_packet</span> <span class="o">=</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">OnAssembledFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">,</span>                             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">seq_num</span><span class="p">,</span>                               <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">marker_bit</span><span class="p">,</span>                            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">max_nack_count</span><span class="p">,</span>                                    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">min_recv_time</span><span class="p">,</span>                                     <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">max_recv_time</span><span class="p">,</span>                                     <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">,</span>                           <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">ntp_estimator_</span><span class="p">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">),</span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">,</span>             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">,</span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">(),</span>                             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span>                 <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span><span class="p">,</span>             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">,</span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span><span class="p">,</span>              <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">RtpPacketInfos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet_infos</span><span class="p">)),</span>           <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">      <span class="n">payloads</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">packet_infos</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">frame_boundary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">buffer_cleared</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_rtp_system_time_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_keyframe_rtp_system_time_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_keyframe_rtp_timestamp_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_infos_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>OnInsertedPacket</code>中的主要逻辑就是缓存解析好的 packet，在遍历到当前帧的最后一个包之后调用<code>OnAssembledFrame</code>进行组帧。至此，rtp 包的排序和组帧的工作结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnAssembledFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">RTPVideoHeader</span><span class="o">::</span><span class="n">GenericDescriptorInfo</span><span class="o">&gt;&amp;</span> <span class="n">descriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame</span><span class="o">-&gt;</span><span class="n">GetRtpVideoHeader</span><span class="p">().</span><span class="n">generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">loss_notification_controller_</span> <span class="o">&amp;&amp;</span> <span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnAssembledFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">(),</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">frame_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">absl</span><span class="o">::</span><span class="n">c_linear_search</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">decode_target_indications</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="n">DecodeTargetIndication</span><span class="o">::</span><span class="n">kDiscardable</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If frames arrive before a key frame, they would not be decodable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// In that case, request a key frame ASAP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_received_frame_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">FrameType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// `loss_notification_controller_`, if present, would have already
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// requested a key frame when the first packet for the non-key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// had arrived, so no need to replicate the request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loss_notification_controller_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">has_received_frame_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Reset `reference_finder_` if `frame` is new and the codec have changed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">current_codec_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">frame_is_newer</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">AheadOf</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">(),</span> <span class="n">last_assembled_frame_rtp_timestamp_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">current_codec_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">frame_is_newer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// When we reset the `reference_finder_` we don&#39;t want new picture ids
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to overlap with old picture ids. To ensure that doesn&#39;t happen we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// start from the `last_completed_picture_id_` and add an offset in case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// of reordering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">reference_finder_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RtpFrameReferenceFinder</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_completed_picture_id_</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_codec_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Old frame from before the codec switch, discard it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame_is_newer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_assembled_frame_rtp_timestamp_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_codec_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_assembled_frame_rtp_timestamp_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffered_frame_decryptor_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffered_frame_decryptor_</span><span class="o">-&gt;</span><span class="n">ManageEncryptedFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">frame_transformer_delegate_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_transformer_delegate_</span><span class="o">-&gt;</span><span class="n">TransformFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnCompleteFrames</span><span class="p">(</span><span class="n">reference_finder_</span><span class="o">-&gt;</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>OnAssembledFrame</code>中则通过调用<code>RtpFrameReferenceFinder</code>的<code>ManageFrame</code>来寻找一个帧解码时所依赖的帧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If we have cleared past this frame, drop it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">cleared_to_seq_num_</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">AheadOf</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cleared_to_seq_num_</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">frames</span> <span class="o">=</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">AddPictureIdOffset</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>impl_</code>是<code>RtpFrameReferenceFinder</code>代码逻辑的实现类的实例，其<code>ManageFrame</code>函数是寻找依赖帧的核心逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpFrameReferenceFinderImpl</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video_header</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">GetRtpVideoHeader</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpGenericFrameRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="o">*</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecVP8</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RTPVideoHeaderVP8</span><span class="o">&amp;</span> <span class="n">vp8_header</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">absl</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderVP8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vp8_header</span><span class="p">.</span><span class="n">temporalIdx</span> <span class="o">==</span> <span class="n">kNoTemporalIdx</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="n">vp8_header</span><span class="p">.</span><span class="n">tl0PicIdx</span> <span class="o">==</span> <span class="n">kNoTl0PicIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">vp8_header</span><span class="p">.</span><span class="n">pictureId</span> <span class="o">==</span> <span class="n">kNoPictureId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">vp8_header</span><span class="p">.</span><span class="n">pictureId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpVp8RefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecVP9</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RTPVideoHeaderVP9</span><span class="o">&amp;</span> <span class="n">vp9_header</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">absl</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderVP9</span><span class="o">&gt;</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vp9_header</span><span class="p">.</span><span class="n">temporal_idx</span> <span class="o">==</span> <span class="n">kNoTemporalIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">vp9_header</span><span class="p">.</span><span class="n">picture_id</span> <span class="o">==</span> <span class="n">kNoPictureId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">vp9_header</span><span class="p">.</span><span class="n">picture_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpVp9RefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecGeneric</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">generic_header</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderLegacyGeneric</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">generic_header</span><span class="o">-&gt;</span><span class="n">picture_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个方法中主要是针对不同的编码类型做了分类处理，实际上完成寻找依赖帧工作的函数则交给了<code>RtpSeqNumOnlyRefFinder</code>的<code>ManageFrame</code>和<code>ManageFrameInternal</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">FrameDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">decision</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kStash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">stashed_frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">kMaxStashedFrames</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kHandOff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">RetryStashedFrames</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">FrameDecision</span>
</span></span><span class="line"><span class="cl"><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">RtpFrameObject</span><span class="o">*</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果是关键帧，插入GOP表，key是last_seq_num，初始value是{last_seq_num,last_seq_num}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_seq_num_GOP_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">())));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// We have received a frame but not yet a keyframe, stash this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果GOP表空，那么就不可能找到参考帧，先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">last_seq_num_GOP_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">kStash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Clean up info for old keyframes but make sure to keep info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for the last keyframe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 删除较老的关键帧(PID小于last_seq_num - 100), 但是至少保留一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">clean_to</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">clean_to</span> <span class="o">&amp;&amp;</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Find the last sequence number of the last frame for the keyframe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that this frame indirectly references.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 在GOP表中搜索第一个比当前帧新的关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">seq_num_it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果搜索到的关键帧是最老的，说明当前帧比最老的关键帧还老，无法设置参考帧，丢弃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">seq_num_it</span> <span class="o">==</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Generic frame with packet range [&#34;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="s">&#34;] has no GoP, dropping frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">kDrop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果搜索到的关键帧不是最老的，那么搜索到的关键帧的上一个关键帧所在的GOP里应该可以找到参考帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果找不到关键帧，seq_num_it为end(), seq_num_it--则为最后一个关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">seq_num_it</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Make sure the packet sequence numbers are continuous, otherwise stash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 保证帧的连续，不连续则先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前GOP的最新一个帧的最后一个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">last_picture_id_gop</span> <span class="o">=</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当前GOP的最新包的序列号，可能是last_picture_id_gop, 也可能是填充包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">last_picture_id_with_padding_gop</span> <span class="o">=</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// P帧的连续性检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获得P帧第一个包的上个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">prev_seq_num</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果P帧第一个包的上个包的序列号与当前GOP的最新包的序列号不等，说明不连续，先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">prev_seq_num</span> <span class="o">!=</span> <span class="n">last_picture_id_with_padding_gop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">kStash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 现在这个帧是连续的了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">AheadOrAt</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Since keyframes can cause reordering we can&#39;t simply assign the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// picture id according to some incrementing counter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 获得当前帧的最后一个包的序列号，设置为初始PID，后面还会设置一次Unwrap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetId</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置帧的参考帧数，P帧才需要1个参考帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">num_references</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置参考帧为当前GOP的最新一个帧的最后一个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 既然该帧是连续的，那么其参考帧自然也就是上个帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">last_picture_id_gop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果当前帧比当前GOP的最新一个帧的最后一个包还新，则更新GOP的最新一个帧的最后一个包(first)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 以及GOP的最新包(second)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">(),</span> <span class="n">last_picture_id_gop</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新填充包状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UpdateLastPictureIdWithPadding</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetSpatialIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置当前帧的PID为Unwrap形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetId</span><span class="p">(</span><span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">kHandOff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">RetryStashedFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">frame_it</span> <span class="o">=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="n">frame_it</span> <span class="o">!=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrameDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">frame_it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="n">decision</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kStash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="o">++</span><span class="n">frame_it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kHandOff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">frame_it</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">          <span class="na">[[fallthrough]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">frame_it</span> <span class="o">=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">frame_it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">complete_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>ManageFrameInternal</code>的核心逻辑实际上就是前面所说的，处理 GOP 内帧的连续性以及设置参考帧。至此就完成了 GOP 内的帧排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnCompleteFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">frame</span> <span class="p">:</span> <span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_seq_num_for_pic_id_</span><span class="p">[</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">last_completed_picture_id_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">last_completed_picture_id_</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">complete_frame_callback_</span><span class="o">-&gt;</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而<code>OnCompleteFrames</code>则接受<code>MangeFrame</code>的返回值作为参数，遍历 GOP 中已经排好序的 Frame 调用<code>complete_frame_callback_</code>的<code>OnCompleteFrame</code>函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">VideoReceiveStream2</span><span class="o">::</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoPlayoutDelay</span><span class="o">&gt;</span> <span class="n">playout_delay</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">frame</span><span class="o">-&gt;</span><span class="n">EncodedImage</span><span class="p">().</span><span class="n">PlayoutDelay</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_minimum_playout_delay_</span> <span class="o">=</span> <span class="n">playout_delay</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_maximum_playout_delay_</span> <span class="o">=</span> <span class="n">playout_delay</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">UpdatePlayoutDelays</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">last_continuous_pid</span> <span class="o">=</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">last_continuous_pid</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// TODO(bugs.webrtc.org/11993): Call on the network thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_video_stream_receiver_</span><span class="p">.</span><span class="n">FrameContinuous</span><span class="p">(</span><span class="o">*</span><span class="n">last_continuous_pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里先更新<code>playout_delay</code>用于之后 Jitter 的计算，然后将 frame 插入到<code>VideoStreamBufferController</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">VideoStreamBufferController</span><span class="o">::</span><span class="n">InsertFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">FrameMetadata</span> <span class="nf">metadata</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">complete_units</span> <span class="o">=</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">GetTotalNumberOfContinuousTemporalUnits</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame receive time must be set!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">metadata</span><span class="p">.</span><span class="n">delayed_by_retransmission</span> <span class="o">&amp;&amp;</span> <span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">field_trials_</span><span class="p">.</span><span class="n">IsDisabled</span><span class="p">(</span><span class="s">&#34;WebRTC-IncomingTimestampOnMarkerBitOnly&#34;</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">         <span class="n">metadata</span><span class="p">.</span><span class="n">is_last_spatial_layer</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">timing_</span><span class="o">-&gt;</span><span class="n">IncomingTimestamp</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">rtp_timestamp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">*</span><span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">complete_units</span> <span class="o">&lt;</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">GetTotalNumberOfContinuousTemporalUnits</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stats_proxy_</span><span class="o">-&gt;</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">is_keyframe</span><span class="p">,</span> <span class="n">metadata</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">metadata</span><span class="p">.</span><span class="n">contentType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">MaybeScheduleFrameForRelease</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">LastContinuousFrameId</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的核心逻辑就是将 frame 插入到<code>FrameBuffer</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">FrameBuffer</span><span class="o">::</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ValidReferences</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; has invalid references, dropping frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 根据frame的id判断是否解码过，解码过就不插入直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">decoded_frame_history_</span><span class="p">.</span><span class="n">GetLastDecodedFrameId</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">legacy_frame_id_jump_behavior_</span> <span class="o">&amp;&amp;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">is_keyframe</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">AheadOf</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="n">decoded_frame_history_</span><span class="p">.</span><span class="n">GetLastDecodedFrameTimestamp</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34;Keyframe &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34; has newer timestamp but older picture id, clearing buffer.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Already decoded past this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 判断填满buffer的frame是不是I帧，是就清空buffer，否则不插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">is_keyframe</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Keyframe &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                           <span class="o">&lt;&lt;</span> <span class="s">&#34; inserted into full buffer, clearing buffer.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// No space for this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 插入当前帧到FrameBuffer中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">frame_id</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">insert_res</span> <span class="o">=</span> <span class="n">frames_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">frame_id</span><span class="p">,</span> <span class="n">FrameInfo</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insert_res</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Frame has already been inserted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame_id</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; inserted, buffer is now full.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 前向传播当前FrameBuffer中的解码连续性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PropagateContinuity</span><span class="p">(</span><span class="n">insert_res</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新下一个可解码的时域单元的timestamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FindNextAndLastDecodableTemporalUnit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>视频帧的<code>FrameBuffer</code>按照可解码的顺序建立完毕，之后就可以根据 Jitter Delay 来交付给解码器解码了。至此，Buffer 的功能分析完毕，下篇学习分析 Jitter Buffer 的核心算法，也就是 Jitter 的计算过程。</p>
]]></description>
</item>
<item>
    <title>同步、异步、阻塞、非阻塞</title>
    <link>https://ayamir.github.io/posts/knowledge/os/sync-async-block-nonblock/</link>
    <pubDate>Sat, 13 Apr 2024 23:39:22 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/os/sync-async-block-nonblock/</guid>
    <description><![CDATA[<h2 id="概念">概念</h2>
<p>同步和异步、阻塞和非阻塞这两组概念经常出现，并且人们往往会有如下认知：</p>
<ul>
<li>
<p>同步就是程序发出同步调用之后就需要等待调用返回一个结果，然后才能继续指令的执行流。</p>
</li>
<li>
<p>异步就是程序发出异步调用之后能直接得到返回，程序可以继续执行，至于调用发起者想要得到的结果会在未来的某个时刻获取。</p>
</li>
<li>
<p>阻塞就是在调用结果返回之前，当前线程会被挂起。</p>
</li>
<li>
<p>非阻塞就是再不能立刻得到结果之前，当前线程并不会被挂起。</p>
</li>
</ul>
<p>那么这样来看的话，同步调用就是阻塞调用，异步调用就是非阻塞调用，这个认知是有些狭隘的。</p>
<h2 id="同步和异步">同步和异步</h2>
<p>同步和异步主要 focus 的是调用者和被调用者双方消息通信的机制。</p>
<p>同步是调用者等待被调用者返回结果，异步则是调用被直接返回，调用者不会等待被调用者。</p>
<p>以例子来说明的话就是：假如你打开了崩铁想玩，但是却发现需要下载更新客户端：</p>
<ul>
<li>
<p>如果采用同步的方式就是你一直等着下载安装完成，期间什么都不做。</p>
</li>
<li>
<p>不过我相信正常人都不会在这个过程中干等着什么都不做，而是会在点击下载按钮之后玩会儿手机或者干点别的事，这就是异步的方式。</p>
</li>
</ul>
<p>在这个例子中我们可以发现：</p>
<ul>
<li>
<p>如果采用同步的方式，我们一定能在更新完成之后的第一时间立刻玩到游戏，但是在苦苦等待的过程中我们的时间被浪费掉了。</p>
</li>
<li>
<p>如果采用异步的方式，我们在等游戏更新完成的过程中做了其他事情，时间没有被浪费掉，但是我们需要一种机制来知道什么时候游戏就更新好了。假如在下载过程中我们去做了别的事情，那么就可能不会第一时间知道它什么时候更新完成。</p>
</li>
</ul>
<p>如果把我们自己比作 CPU 的话，并且假设目前 OS 上面只有这一个任务，同步的方式会浪费 CPU 时间，而采用异步的方式可以让我们多做一些别的事情，不过异步需要一些消息通知的方式来告诉我们等待的任务什么时候会有结果。假如崩铁下载器在下载完成之后没法通知我们，那么我们可能需要隔一段时间检查一下有没有更新完成。</p>
<p>这么看来，其实同步就是 OS/函数调用 默认支持的通信方式（无非就是等呗），而异步虽然可以解决同步会浪费时间的问题，但是需要引入 消息通知（下载器窗口变成启动游戏的窗口，并且置于最前）/注册回调函数（假如可以派个人替我玩的话）/轮询（隔几分钟看看有没有更新完）这些机制才能保证完成任务。</p>
<p>从线程/协程的角度来看同步和异步的话，其实同步就是完完全全的单线程模式，而异步可以利用协程的特性在单线程中完成异步任务，从而避免大量使用回调函数带来的“回调地狱”。</p>
<p>以实际的例子来说明，在使用 neovim 写代码的时候会使用代码格式化的功能，默认的代码格式化的同步完成的，也就是说我们需要等格式化完成才能执行别的任务（从阻塞的角度看就是，neovim 被格式化的过程阻塞了，这种方式就是同步且阻塞的方式）。在文件很小的时候，因为格式化很快所以以同步的方式进行格式化并不会有太多的影响。但是如果需要进行大文件的格式化，同步的方式会阻塞很久，严重影响体验。从更高的角度来看，格式化器影响的主要是代码的位置（可能也会影响代码的内容例如 <code>goimports</code> ），那么理论上我们不进行与代码内容和代码位置相关的写入操作就不会造成写冲突。但是这种同步的方式就是一种一刀切，使我们只能等格式化完成，这其实不太合理。</p>
<p>为什么说这个例子可以用协程的方式实现异步呢？其实原理就是局部性 + 协程特性。因为我们在写代码的时候通常只是会编辑一处的内容，如果我们下达了对整个大文件的格式化操作，那么理论上是可以按照不同的小部分（比如一个函数）来完成格式化过程的，而在完成格式化一个函数的过程中，CPU 的执行权可以交给格式化器，而在用户需要进行一些别的操作的时候，格式化协程可以挂起(yield)并将 CPU 让给用户操作的协程，而当用户的操作完成之后，格式化协程可以恢复(resume)并获取 CPU 继续执行。这样来看，通过对任务的分割和对协程的交替切换，就实现了异步的机制。</p>
<h2 id="阻塞和非阻塞">阻塞和非阻塞</h2>
<p>阻塞和非阻塞主要 focus 的是调用者在等待调用结果时候的状态。</p>
<p>还是以上面的例子来说：</p>
<ul>
<li>
<p>阻塞描述的是我们在等待游戏更新完毕的过程中，处于什么都干不了的状态（我只想玩崩铁，我啥都不想干！），</p>
</li>
<li>
<p>非阻塞描述的是在游戏更新的时候，我们可以干点别的，比如看一集《葬送的芙莉莲》（这个时间正好能多看一集番，美滋滋~）。</p>
</li>
</ul>
<p>对于实际的编程场景而言，阻塞和非阻塞这组概念常常在 Socket 编程中出现，我们可以利用 <code>fcntl</code> 把 socket 置为阻塞或者非阻塞的状态（默认是非阻塞）</p>
<p>对于 TCP 而言，其对应的发送和接收的 API 是 <code>send</code>/<code>recv</code>，而 <code>send</code>/<code>recv</code> 其实并不是真的直接向网络上发数据/直接从网络上接收数据，而是将数据写入到内核发送缓冲区/从内核接收缓冲区读取数据。</p>
<p>如果发送端一直往发送缓冲区写数据而接收端不读数据的话（其实就是流量的滑动窗口不滑动了），当缓冲区满了之后：</p>
<ul>
<li>
<p>如果 socket 是阻塞模式，继续调用 <code>send</code> 会将程序阻塞在 <code>send</code> 处，不会执行之后的逻辑。</p>
</li>
<li>
<p>如果 socket 是非阻塞模式，继续调用 <code>send</code> 会直接返回错误，然后执行之后的逻辑（通常使用非阻塞模式我们会获取 <code>send</code> 调用的返回值并在循环中判断）。</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>其实总的来看，在实际的编码过程中我们没必要严格区分这两种概念，因为它们之间的区别并不是左与右，正与负这种关系。概念还是需要与实际的例子相结合才有相辅相成的意义。</p>
]]></description>
</item>
<item>
    <title>进程、线程和协程</title>
    <link>https://ayamir.github.io/posts/knowledge/os/prcess-thread-coroutine/</link>
    <pubDate>Sat, 06 Apr 2024 19:23:04 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/os/prcess-thread-coroutine/</guid>
    <description><![CDATA[<h2 id="进程">进程</h2>
<h3 id="是什么">是什么</h3>
<p>学操作系统课的时候学过一句话叫做：进程是操作系统资源分配的最小单位，进程的资源直接由 OS 分配，并存储在进程控制块 PCB 中：</p>
<ul>
<li>进程标识符 PID</li>
<li>进程状态：就绪、运行、阻塞</li>
<li>内存资源：
<ul>
<li>代码段、数据段、堆和栈</li>
</ul>
</li>
<li>文件描述符 fd ：
<ul>
<li>stdin、stdout、stderr、以及进程打开的文件描述符列表比如本地文件以及网络连接等的 fd</li>
</ul>
</li>
<li>寄存器：
<ul>
<li>PC、SP、还有其他的通用寄存器</li>
</ul>
</li>
<li>进程控制信息：
<ul>
<li>父进程 ID ，子进程 ID ，以及信号处理器这些</li>
</ul>
</li>
</ul>
<h3 id="有什么用">有什么用</h3>
<p>在拿进程和程序做对比的时候我们知道，进程就是运行着的程序（这里的运行指的是程序被加载到内存空间中然后开始按照程序指令执行，而不是指进程状态中的运行状态），受 OS 的调度，可以说我们写程序的目的就是要让 CPU 可以按照磁盘上的代码指令来执行操作，进程就是实现这一目的的过程。</p>
<p>因为 OS 使用了虚拟内存这一概念，使得每个进程都认为自己是独占 OS 的，所以一个进程是不知道其他进程的存在的。因而如果面对需要多个进程协作完成一项任务的时候（其实这种情况的描述从逻辑上应该是自上到下的，先有的是一项任务，我们通过分析发现这两个任务需要写多个程序来完成），就会不可避免地引入进程间通信 IPC 。</p>
<p>常用的进程间通信手段大概有 6 种：消息队列、共享内存、匿名管道、命名管道、信号量、Socket，这几种方式根据需求的不同都有自己的用武之地，不过我个人最习惯用的还是 Socket ，因为它具有最优的可扩展性（跨主机、跨语言），可记录性（可以使用 tcpdump/wireshark 抓包），也完美符合我对于通信这一名词想象（明确的通信双方、全双工的信道）。</p>
<p>从我的实际项目经历中来看，我的 Unity 客户端实例需要把游戏运行过程中产生的 2D 轨迹数据输入给 Python 端的 AI 模型，并获取模型输出。对于这一场景，我的首选就是 Socket 通信，首先是因为 Socket 具备全双工的特性可以满足需求，其次是使用 Socket 可以在 AI 模型部署到其他主机上的时候也能正常运行。</p>
<h2 id="线程">线程</h2>
<h3 id="是什么-1">是什么</h3>
<p>上面说到进程是 OS 资源分配的最小单位，这句话的下半句是：线程是操作系统调度的最小单位，这句话其实暗示了，线程和进程的概念对于单线程的进程而言是相同的。</p>
<p>OS 在调度 CPU 的时候是以线程为单位的，也就说明线程其实也是一种 OS 级别的概念。对于 Linux 而言，线程和进程使用的是相同的数据结构 <code>task_struct</code> 来表示的，不过进程的创建使用的是 <code>fork()</code> 这一系统调用，而线程的创建用的是 <code>clone()</code> 这一系统调用。</p>
<p>结合前半句话，说明 OS 在分配资源的时候分配不到线程这个层面上（单线程进程是特例），对于同一个进程的多个线程，他们之间共享进程的代码段、数据段和 fd 这些，不过每个线程都拥有自己独立的堆、栈空间。</p>
<h3 id="有什么用-1">有什么用</h3>
<p>因为每个进程都会拥有上面列出的这些资源，直接受到 OS 的控制，所以进程的创建和销毁不可避免地会涉及到相对比较大的时间开销。</p>
<p>相比之下，线程因为可以直接继承并共享进程的部分资源，所以线程的创建和销毁要更加轻量。</p>
<p>也正因如此，同一进程之间的多个线程之间只需要使用一些编程上的技法就可以完成通信，常用的就是各种锁、条件变量以及阻塞队列。</p>
<h3 id="什么时候用多线程">什么时候用多线程</h3>
<p>首先需要考虑的是能不能使用多线程。多线程的执行过程是 OS 调度 CPU 的多个核心来分别执行多个线程的过程，因而最适合使用多线程的任务一定具备：划分给各个线程之间的任务没有重叠、也无需通信（或者说没有依赖关系）的特性，每个任务都是 Compute-Intensive 的。</p>
<p>从我的实际项目经历中来看，在把 GPU 显存中的 yuv 图像数据回读到内存中的时候，图像的不同部分之间是相互独立的，因而这个过程天然适合使用多线程来完成，主线程只需要等待多个线程读完数据之后执行下一步操作即可。</p>
<p>其次需要考虑的是多线程能带来多大的收益。单线程和多线程的区别其实就是可以占有并利用的 CPU 核心数的区别，因此当任务的瓶颈不在于 CPU 的时候就需要考虑是否有使用多线程的必要。根据 Amdahl&rsquo;s law ，$S(n)=\frac{1}{(1-P)+\frac{P}{n}}$，当处理单元数趋向于无穷的时候，并行化所带来的加速比 $S(n)$ 将趋近于 $\frac{1}{1-P}$​ 。如果任务中可并行的部分比较小的情况下，可能就没有并行化的必要了。</p>
<p></p>
<p>实际任务中使用的线程数量应该结合<strong>可以利用的系统资源（CPU 和内存）<strong>和</strong>相应任务的性能瓶颈</strong>两方面考虑，这里之所以要强调是可以利用的资源是因为我们需要从 OS 的角度来考虑，如果当前进程使用了 CPU 的全部核心，那么 OS 上的其他任务就不能得到及时响应，当然因为线程本身需要独立的堆栈空间，所以线程的理论上限需要考虑内存大小。另一方面，多线程本质上只是在提高当前任务对于 CPU 的使用率，但是一个任务的执行不可能只用到 CPU ，还会用到内存以及可能涉及 IO 操作。就算是不涉及锁的并行读操作，也需要考虑 IO 可以利用的总线带宽大小，所以对于这样的任务使用多线程并行化带来的性能提升曲线应该会随着线程数的增多而呈现先升后降的趋势。还是以我上面遇到的问题为例，从 GPU 显存回读数据到内存中的操作就会受到 PCIe 总线带宽的限制，如果线程数过多就会造成多个线程对于总线的争用，这样就会导致性能下降。</p>
<h3 id="怎么用多线程">怎么用多线程</h3>
<p>默认的多线程使用方式就是在需要多线程执行任务的时候创建线程，在任务执行完毕之后销毁线程（就是直接交给 OS 来进行线程的创建和销毁）。</p>
<p>而实际上，我们常用的是线程池的方式，也就是在任务开始的时候我们就创建多个线程并且保存在一个线程池中，通过任务队列的形式确定将那个任务分配给哪个线程。这样做的方式其实就是把对线程的控制权从 OS 转移到程序员，避免了重复的线程创建和销毁带来的开销。</p>
<p>下面是使用 C++ 实现的一个简单的线程池：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">func</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ThreadPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span><span class="p">(</span><span class="n">size_t</span> <span class="n">numThreads</span><span class="p">)</span> <span class="o">:</span> <span class="n">stop</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numThreads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">workers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">queueMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">condition</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">stop</span> <span class="o">||</span> <span class="o">!</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="o">&amp;&amp;</span> <span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">              <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">tasks</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">queueMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tasks</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">condition</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">ThreadPool</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">queueMutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">stop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">condition</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="o">&amp;</span><span class="nl">worker</span> <span class="p">:</span> <span class="n">workers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">worker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">workers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">queueMutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">condition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">stop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 示例任务函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">printHello</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello from thread &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ThreadPool</span> <span class="n">pool</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 创建线程池，包含4个线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 向线程池添加任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span> <span class="n">printHello</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="协程">协程</h2>
<h3 id="是什么-2">是什么</h3>
<p>协程这一概念可以理解为“函数plus”，普通的函数只有两种行为：调用(Invoke)和返回(Return)。协程比函数多了一种行为：挂起(Suspend/Yield)。</p>
<p>在只使用函数的情况下，程序的执行流可以只用一个栈就能模拟（调用函数时 push ，函数返回时 pop ），而引入协程之后，因为其具有挂起这一行为，所以需要额外的空间（比如堆）来暂存协程的上下文。</p>
<h3 id="有什么用-2">有什么用</h3>
<p>协程的作用可以用一句话来描述，即：协程就是用单线程的方式完成并发的任务逻辑。</p>
<p>协程其实与进程和线程没有太近的“亲缘关系”，只是在作用上有着相近的效果，即宏观上看是并发执行的。以经典的生产者-消费者任务为例：</p>
<ul>
<li>多进程/多线程：至少需要一个生产者进程/线程，消费者进程/线程，两者之间可能需要使用一个单向管道作为数据缓冲区来提高性能（或者说控制管道大小来实现不同的任务逻辑）。</li>
<li>协程：只需要一个线程，通过两个分别负责生产和消费的协程来完成，即：生产者协程生产一定数量之后挂起，并调用消费者协程。消费者协程消费完之后挂起，并调用生产者协程，如此交替往复进行。</li>
</ul>
<p>协程相比于上面提到的进程和线程，区别在于协程是运行在用户态的，或者说协程的控制权是掌握在程序员手中的，由程序员负责控制在什么时候把 CPU 的使用权交给哪个协程。</p>
<h3 id="什么时候用协程">什么时候用协程</h3>
<p>协程的使用情形其实很简单，即：你需要在只利用一个 CPU 核心的情况下完成并发任务的时候就是使用协程的时候。所以其实协程这个概念诞生的很早（1960年 Melvin Conway 解决COBOL 编译器的问题，使用协程技术只需要遍历一遍源代码）</p>
<h3 id="怎么用">怎么用</h3>
<p>目前 C++ 的协程只是在 C++20 中提供了机制，标准库的实现可能会在下一个版本 C++23 中提供。</p>
<p>Go 中的 Goroutine 其实并不受程序员调度，其挂起行为由 Go runtime 调度。</p>
<h2 id="总结">总结</h2>
<p>从进程到线程再到协程的概念，其使用层级是逐级向上的。</p>
<ul>
<li>如果希望程序可以充分利用多核资源来实现 CPU 密集型操作的并行加速，那可以使用多线程，通过使用锁/条件变量等方式来完成线程之间的协作。</li>
<li>如果不满 OS 的任务/线程调度策略，那可以在程序中使用并调度协程，用单线程+异步的逻辑来完成宏观上的并发操作。</li>
</ul>
]]></description>
</item>
<item>
    <title>什么是 RPC ？</title>
    <link>https://ayamir.github.io/posts/knowledge/backend/what-is-rpc/</link>
    <pubDate>Fri, 29 Mar 2024 23:55:25 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/backend/what-is-rpc/</guid>
    <description><![CDATA[<h2 id="是什么">是什么</h2>
<p>RPC 全名即 Remote Procedure Call：远程过程调用，本质上是一种设计/概念，它允许在一台机器上的 Client 调用运行在另一台机器上的 Server 上的程序接口。</p>
<h2 id="为什么">为什么</h2>
<p>RPC 的出现主要是为了满足现实世界中多机集群的业务分离， Client 端的业务和 Server 端的业务相互分离，目的是更强的性能、可扩展性和可维护性。</p>
<p>RPC 在我看来就是传统的前后端 http RESTful 框架的更加 general 的版本，两者在思想上是一致的，只不过 RESTful 框架是把现实业务中的 <strong>前端的显示</strong> 和 <strong>后端的数据处理</strong> 进行分离，而 RPC 则是更为通用的一种考虑，只要项目的设计者认为某个功能使用 RPC 进行分离会带来如性能、可靠性、可维护性等非功能特性上的收益，那其实就可以引入 RPC 。RPC 能完成的功能性需求不使用 RPC 一般来说也能实现，RPC 的收益主要体现在非功能性需求上。</p>
<h2 id="怎么做">怎么做</h2>
<p>RPC 的核心是面向接口编程的思想，Server 端和 Client 端可以通过定义好语言无关的接口（函数签名），双方的过程调用就可以像调用同一文件中的不同函数一样进行。</p>
<p>既然涉及到了不同主机，那么不可避免地会引入网络通信，而网络通信的本质其实就是需要规定好：消息如何编解码（或者说如何序列化和反序列化）、消息如何通过网络传输。</p>
<p>因而 RPC 在实现上主要需要考虑两部分，第一个部分是<strong>通信协议</strong>，第二部分是<strong>编码协议</strong>，</p>
<ul>
<li>通信协议：HTTP/TCP/UDP</li>
<li>编码协议：xml/json/protobuf</li>
</ul>
<p>目前主流的 RPC 框架在编码协议上基本上都使用 protobuf ，因为 protobuf 作为一种二进制数据可以带来比 xml/json 这种文本数据更高的压缩效率（当然，更加重要的前提条件是 RPC 传输的消息其实不太需要跟人打交道，也就无需可读性）。</p>
<p>对于通信协议，不同的 RPC 框架可能根据自己的用途有着不同的选择，比如 gRPC 使用的是 HTTP/2，而 tRPC 则根据不同的传输形式（unary和stream）设计了不同的自定义的协议格式。</p>
<h2 id="实际操作">实际操作</h2>
<p>以 tRPC 的 helloworld 为例，首先需要做的是写 IDL(Interface Defined Language) ，也就是前面提到的 <code>proto</code> 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">service</span> <span class="n">Greeter</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="k">rpc</span> <span class="n">Hello</span> <span class="p">(</span><span class="n">HelloRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">HelloReply</span><span class="p">)</span> <span class="p">{}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">HelloRequest</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="kd">message</span> <span class="nc">HelloReply</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="kt">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里首先定义了一个名为 <code>Greeter</code> 的服务，服务包含一个名为 <code>Hello</code> 的函数，其入参为 <code>HelloRequest</code> ，出参为 <code>HelloReply</code>。</p>
<p>后面则定义了 <code>HelloRequest</code> 和 <code>HelloReply</code> 这两种消息的格式，需要注意的是这里的 <code>string msg = 1</code> 并不是将 <code>msg</code> 初始化为 1 的意思（当然，<code>string</code> 类型的数据就算要初始化也应该是 <code>&quot;1&quot;</code> 而不是 <code>1</code>），而是说 <code>msg</code> 这个成员是 <code>HelloReply</code> 和 <code>HelloRequest</code> 的第 <code>1</code> 个成员。</p>
<p>之后可以使用 tRPC 的命令行工具或者是 <code>Makefile</code> 来生成相应的桩代码，供实现实现逻辑的客户端和服务端代码进行调用。</p>
<p>这里体现的其实就是前面所说的，RPC 只是一种对原本功能的一种分离，通过 IDL 确定好 C-S 之间的接口之后，C-S 都只需要调用协商好的接口，而原来的业务逻辑该怎么实现就怎么实现。</p>
]]></description>
</item>
<item>
    <title>虚拟地址空间</title>
    <link>https://ayamir.github.io/posts/knowledge/os/virtual-memory-space/</link>
    <pubDate>Wed, 07 Feb 2024 15:56:52 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/os/virtual-memory-space/</guid>
    <description><![CDATA[<h2 id="什么是虚拟地址空间">什么是虚拟地址空间？</h2>
<p>虚拟地址空间就是每个程序在运行起来之后所独占的内存空间，也就是进程自己的地址空间。</p>
<p>虚拟地址空间的大小由地址总线的宽度也就是计算机的字长决定：</p>
<ul>
<li>
<p>对于 32 位系统，进程的虚拟地址空间大小为：</p>
<p>$$
2^{32} bit = 4^{30} Byte = 4 GiB
$$</p>
</li>
<li>
<p>对于 64 位系统，进程的虚拟地址空间大小为：
$$
2^{64}bit = 16^{30} GiB = 16 ^{20} TiB = 16^{10} PiB= 16 EiB
$$</p>
</li>
</ul>
<p>不过理论是理论，实际是实际。</p>
<ul>
<li>对于 32 位的<code>linux</code>系统而言，操作系统占用了空间中上面的 1GiB（从<code>0xC0000000</code>到<code>0xFFFFFFFF</code>），程序可以使用的虚拟空间原则上只有 3GiB（从<code>0x00000000</code>到<code>0xBFFFFFFF</code>），对于 64 位的 OS 跟进程各自占用 128T 的空间，分别在最高处和最低处。</li>
<li>对于 32 位的<code>windows</code>系统而言，操作系统 2GiB，程序 2GiB（不过<code>windows</code>系统可以设置启动参数来将 OS 占用的虚拟地址空间大小缩小到 1GiB）.</li>
</ul>
<p>进程的虚拟地址空间用于存放进程运行所必不可少的数据，内存地址从低到高生长，各个区域分别为：</p>
<ul>
<li>代码段(.text)：程序代码段</li>
<li>数据段(.data)：已初始化的静态常量、全局变量</li>
<li>BSS 段(.bss)：未初始化的静态变量、全局变量</li>
<li>堆：动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段：动态库、共享内存等，从高地址开始向下增长；</li>
<li>栈：局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>，从高地址开始向下增长。</li>
</ul>
<h2 id="为什么需要虚拟地址空间">为什么需要虚拟地址空间？</h2>
<p>虚拟地址空间其实是一种应对多进程环境下的策略，这种对程序员透明的抽象方式可以使每个进程都无法感知到其他进程的存在，让各个进程之间的内存空间相互隔离，程序员也无需关心进程运行的物理地址的事情，极大地降低了程序员的心智负担。</p>
<h2 id="32-位的机器程序使用的空间大小能超过-4gib-吗">32 位的机器，程序使用的空间大小能超过 4GiB 吗？</h2>
<p>如果指的是虚拟地址空间，那么答案是“否”。因为 32 位的 CPU 只能使用 32 位的指针，最大的寻址范围就到 4GiB。</p>
<p>如果指的是计算机的内存空间，答案为“是”。Intel 从 95 年推出的 Pentium Pro CPU 开始采用 36 位的物理地址，可以访问达 64GiB 的物理内存。同时，Intel 修改了页映射的方式，使得新的映射方式<strong>Physical Address Extension, PAE</strong>可以访问到更多的物理内存。</p>
<ul>
<li>
<p>在<code>windows</code>下，进程可以拿一段连续的内存地址作为窗口，然后从高于 4GiB 的物理空间中申请多个大小等于窗口大小的物理空间并进行编号 A, B, C 等，用到哪部分就把窗口映射到哪部分。这一操作也叫做<strong>AWE</strong>(Address Windowing Extensions)。</p>
</li>
<li>
<p>在<code>linux</code>下则使用<code>mmap</code>系统调用来实现。<code>mmap</code>系统调用的主要作用是使进程之间通过映射同一个普通文件来实现共享内存(IPC)。普通文件被映射到地址空间之后，进程可以像访问普通内存一样对文件进行访问，而不需要调用<code>write</code>, <code>read</code>函数。<code>mmap</code>本质上并不分配空间，只是将文件映射到进程地址空间（当然，会占掉虚拟内存空间），映射成功后就可以直接用<code>memcpy</code>等操作来写文件，因而用户对这段内存区域的修改就可以直接反映到内核空间（当然反过来也一样）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="n">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对映射空间所写的内容并不会立刻更新到文件中，而是有一段时间的延迟，内核会挑个时间进行写入操作。如果需要即使写入可以调用<code>msync</code>来强制同步。</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>ABI是什么？</title>
    <link>https://ayamir.github.io/posts/knowledge/cpp/abi/</link>
    <pubDate>Wed, 07 Feb 2024 12:51:01 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/cpp/abi/</guid>
    <description><![CDATA[<h2 id="abi-是什么">ABI 是什么？</h2>
<p>ABI: Application Binary Interface（应用<strong>二进制</strong>接口）。</p>
<p>其实就是针对 <strong>编译器</strong> 和 <strong>链接器</strong> 的<strong>二进制级别</strong>的一些规范和约束，主要规范的内容有：</p>
<ul>
<li>规定函数的调用顺序，也称为“调用约定”，规定了如何将“函数”转换成汇编代码。</li>
<li>规定库函数如何表示，主要对链接过程有指导作用。</li>
<li>规定可以使用什么类型的数据，这些数据如何对齐以及其他低级细节。</li>
<li>ABI 还涉及到 OS 的内容，包括可执行文件的格式、虚拟地址空间布局等细节。</li>
</ul>
<h2 id="为什么会有-abi-">为什么会有 ABI ？</h2>
<p>原因其实很简单，硬件架构、OS、编译工具链以及编程语言的发展和逐层抽象让大部分程序员可以不太在意底层程序的执行过程，而只需要负责编写表明业务逻辑的源代码。大部分程序员不需要在意并不意味着这部分不存在，实际上，这部分内容是通向二进制文件执行的必经之路。</p>
<p>通过上面的分析可以知道， ABI 这个概念基本上是由<code>(硬件架构, OS, 编译工具链, 编程语言)</code>这个四元组决定的。</p>
<ul>
<li>架构兼容性：<code>amd64</code>架构和<code>arm64</code>架构对应的指令集不同，因而一个可执行文件要想在这两个架构上成功运行，就需要编译这两个架构的二进制文件（也就是交叉编译）。</li>
<li>OS 兼容性：<code>windows(PE-COFF)</code>, <code>linux(ELF)</code>和<code>macos(MACH-O)</code>上规定的程序二进制文件格式不同，因而也需要为不同的 OS 编译不同的二进制文件。</li>
<li>编译工具链兼容性：这个我们平时遇到的比较多，常见原因是不同的编译器或不同的编译器版本的<strong>名字修饰</strong>规则不同，导致链接器在链接时找不到对应名字的库函数。</li>
<li>编程语言兼容性：C 语言中的一些基本内容如不同类型数据在内存中存放的形式，寄存器的使用形式等，以及 C++的众多特性：虚函数如何调用、虚表的内容和分布形式、template 如何实例化等等，都是 ABI 所需要规定的内容。</li>
</ul>
<h2 id="abi-compatible-">ABI-Compatible ?</h2>
<p>ABI-compatible 允许编译好的目标代码可以无需修改或重新编译链接就能直接运行，而从上面举的例子就可以发现，ABI 兼容是一件很难做到的事情，光是架构和 OS 的不同就需要不同的目标文件了。</p>
<p>而编译工具链的兼容性容易做到吗？其实也不容易。目前主流的 C++编译工具链有<code>gcc</code>, <code>llvm(clang)</code>和<code>msvc</code>，这三者之间对于名字修饰的规定都不同，因而一个用<code>clang</code>编译的库函数是无法被一个用<code>msvc</code>编译的<code>main</code>文件调用的。当然，这里指的是默认进行名字修饰的情况，如果使用<code>extern &quot;C&quot;</code>对函数进行修饰，从而要求编译器使用 C 语言的编译和链接规范进行处理就可以解决这个问题。</p>
<p>C++一直被诟病的原因之一就是二进制兼容性不好，对于小型项目而言使用同一种编译器进行编译可能可行，但是对于大型项目而言不太现实，库代码的提供者通常只是提供编译链接好的库，并不提供源代码，所以要想做到对于所有的编译器（的所有版本）都进行支持是一件困难且不太现实的事情。</p>
]]></description>
</item>
<item>
    <title>H264 Encode</title>
    <link>https://ayamir.github.io/posts/knowledge/h264-encode/</link>
    <pubDate>Tue, 23 Jan 2024 01:05:20 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/h264-encode/</guid>
    <description><![CDATA[<h2 id="编码框架">编码框架</h2>
<p>编码器包含两个方向的码流分支：</p>
<p></p>
<p>从左到右的前向码流分支为编码过程；</p>
<p>从右到左的反向码流分支为重建过程。</p>
<h3 id="前向编码分支">前向编码分支</h3>
<p>以 16x16 像素的 MB 为单位进行处理，首先从当前输入的视频图像(Frame or Field)中取一个待编码宏块$F_n$，该宏块以帧内或者帧间的模式进行编码，生成一个预测宏块$P$。</p>
<p>如果是帧内编码，$P$由当前 Slice 里面已经编码、解码、重构并且还没进行去块滤波的宏块 $μF_n&rsquo;$ 使用帧内预测得到。当前宏块 $μF_n&rsquo;$ 减去预测宏块 $P$，得到残差块$D_n$，对残差块 $D_n$ 进行整数变换（一般是 4x4，或者 8x8）、量化后得到一组系数 $X$ ，再对 $X$ 进行重排序和熵编码，就完成了一个宏块的编码过程。对于 P 帧和 B 帧，如果 ME 时候找不到最佳匹配块那也会使用帧内预测编码。</p>
<p>经过熵编码的码流加上宏块解码所需的一些信息，如预测模式、量化步长、描述宏块运动预测补偿的运动矢量信息等，就组成了该宏块压缩后的码流，Slice 中所有 MB 的码流加上 Slice 头信息就组成了 Slice 的编码码流，再通过 NAL 层进行传输或存储。图像参数集 PPS 和序列参数集 SPS 则由 NAL 单独进行传输。</p>
<h3 id="后向重建分支">后向重建分支</h3>
<p>在后向重建分支中，对量化后的宏块系数 $X$ 进行解码从而得到重建宏块，后续宏块进行编码需要从已重建的宏块中寻找参考块。宏块重建过程如下：
宏块系数 $X$ 经过反量化和反变换之后，得到残差宏块 $D_n$ 的近似值 $D_n&rsquo;$ ，预测块 $P$ 加上 $D_n&rsquo;$ 得到未滤波的重构宏块 $μF_n&rsquo;$ ，再做环路滤波来减少块效应，即得到了最终的重构宏块 $F_n&rsquo;$ ，当图像中所有宏块都重建完成后，就形成了重建图像。</p>
<p>后向重建分支其实就是包含在编码中的完整解码流程，与真正解码器的唯一区别是： 其预测块 P 直接从前向编码分支中得到，而真正的解码器需要利用码流中解出的预测块信息获得预测块 P。当前图像的已重建宏块会被用做帧内预测的参考，而完整的重建图像会被加入参考帧列表，作为未来编码图像帧预测的参考图像。</p>
<h2 id="预测编码">预测编码</h2>
<p>预测编码（Prediction Coding）利用相邻像素之间的空间和时间相关性，用已传输的像素对当前正在编码的像素进行预测，然后对预测值和真实值的差值——预测误差进行编码和传输。</p>
<p>消除空间冗余：利用一帧图像已经编码的部分来预测还没有被编码的部分</p>
<p>消除时间冗余：利用之前编码过的图像来预测当前图像需要编码的部分</p>
<p>通过预测可以得到预测值，预测值通常不等于实际值，所以用实际值减去预测值可以得到预测残差。预测方法越好，残差越小，因而对残差进行编码得到的码流要比对实际值直接进行编码的码流要小</p>
<p>在解码端可以解码出残差，使用与编码端相同的预测过程来获取预测值，加上残差便可以得到相应的实际值。</p>
<p>目前使用较广的预测方法是线性预测。用已传像素的线性组合对正在编码的像素进行预测。</p>
<p>编码器输出预测值和实际值之间的差值，选择最优的预测系数，使预测误差的分布在 0 附近。经过非均匀量化之后，最终传输的是量化之后的预测误差。</p>
<p>重建的图像与编码前的图像之间的区别是量化带来的。</p>
<p>如果取消量化操作，那么预测编码和解码就是一个无失真的编解码系统，但是这样的压缩率要远远低于使用量化的压缩率。</p>
<p>量化的事实依据是图像中存在人眼感知并不明显的区域，通过非均匀量化可以过滤掉这部分数据（也被称为量化噪声），能达到提高压缩率但不降低主观质量的效果。</p>
<h2 id="帧间预测">帧间预测</h2>
<p>帧间预测消除的是时间冗余，主要利用的是运动估计和运动补偿。</p>
<p>运动估计 ME 的过程其实就是计算运动向量 MV 的过程：</p>
<p>寻找当前编码的块在已编码图像中的最佳对应快，并且计算出对应块的偏移量：运动向量</p>
<p>假设当前编码块是 $B$ ，在参考帧 $P_r$ 中寻找与 $B$ 块相减残差最小的块 $B_r$ ， $B_r$ 就是 $B$ 块的最佳匹配块。</p>
<p>$$
MV=B_r-B=(x_r  - x,y_r  - y)
$$</p>
<p>$B_r$ 块就是 $B$ 块的参考块， $B_r$ 的像素值就作为 $B$ 块像素值的预测值。
运动向量 MV 也需要用合适的方式编码到码流中。</p>
<p>运动补偿 MC：根据 MV 和帧间预测方法，求出当前帧的估计值的过程。</p>
<p>当前帧的估计值是对当前图像的描述，用来说明当前图像的每一个像素怎么由它的参考图像的像素块得到。</p>
<p>ME 是动态的过程，MC 是静态的描述。</p>
<ul>
<li>
<p>ME 设计很多算法和技巧。</p>
</li>
<li>
<p>MC 可以看作是索引表，一个描述像素块的最佳匹配块分布情况的索引表。</p>
</li>
</ul>
<p>实际计算过程中会对树状结构分块的 8 种模式都尝试一遍。
H264 支持亮度 1/4 像素、色度 1/8 像素的运动估计，在亚像素 ME 之前需要先用插值法得到亚像素值。</p>
<ul>
<li>
<p>在噪声大的视频中，提高搜索精度没法提高预测精确度。</p>
</li>
<li>
<p>在噪声小的视频中，1/4 像素精度可以达到比较好的预测效果。</p>
</li>
<li>
<p>视频会议里 1/2 像素精度基本可以满足需求。</p>
</li>
</ul>
<h3 id="运动估计算法">运动估计算法</h3>
<p>假设匹配误差随着离全局误差最小点的距离增加而单调增加，从原点开始，采用固定的搜索模板和搜索策略得到最佳匹配块。</p>
<p>理论最优的算法是全搜索法，但是计算量巨大，效率低, 一般作为其他搜索算法的一种效率参考。</p>
<p>还有其他的快速法：X264 里面主要使用的是钻石搜索法 DIA、六边形搜索法 HEX 和 UMH。</p>
<p>钻石搜索法以搜索起点为中心，先用 LDSP 进行搜索，直到最佳匹配点位于大菱形的中心位置，然后再用小菱形搜索，直至最佳匹配点位于小菱形的中心位置。</p>
<p>六边形搜索法采用 1 个大模板（六边形模板）和 2 个小模板（小菱形模板和小正方形模板）。</p>
<ul>
<li>步骤 1：以搜索起点为中心，采用图中左边的六边形模板进行搜索。计算区域中心及周围 6 个点处的匹配误差并比较，如最小 MBD 点位于模板中心点，则转至步骤 2；否则以上一次的 MBD 点作为中心点，以六边形模板为模板进行反复搜索。</li>
<li>步骤 2：以上一次的 MBD 点为中心点，采用小菱形模板搜索，计算各点的匹配误差，找到 MBD 点。然后以 MBD 点为中心点，采用小正方形模板搜索，得到的 MBD 点就是最优匹配点。</li>
</ul>
<p>UMH 是基于 MV 具有时空相关性，所以可以结合上一帧和上一步中 MV 的方向和角度，来修改多层六边形的形状，UMH 算法包含四中搜索模式:不均匀交叉搜索、多六边形网格搜索、迭代六边形搜索、菱形搜索。</p>
<ul>
<li>步骤 1：进行一次小菱形搜索，根据匹配误差值和两个门限值（对于一种尺寸的宏块来说是固定大小的 threshold1 和 threshold2）之间的关系作相应的处理，可能用到中菱形模板或者正八边形模板，也有可能直接跳到步骤 1。</li>
<li>步骤 2：使用非对称十字模板搜索。“非对称”的原因是一般水平方向运动要比垂直方向运动剧烈，所以将水平方向搜索范围定为 W，垂直方向搜索范围定为 W/2。</li>
<li>步骤 3：使用 5x5 逐步搜索模板搜索。</li>
<li>步骤 4：使用大六边形模板搜索。</li>
<li>步骤 5：使用六边形搜索算法找到最优匹配点。</li>
</ul>
<p>码率不变的前提下，“Dia”、“HEX”、“UMH”编码获得的质量依次提高，速度依次降低。快速算法（“Dia”、“HEX”、“UMH”）的编码质量比全搜索算法低不了太多，但是速度却高了很多倍。</p>
<h3 id="多参考帧预测">多参考帧预测</h3>
<p>编码端存储参考帧的缓冲区就是 DPB，主要有三种参考帧：短期参考帧、长期参考帧和非参考帧。</p>
<ul>
<li>短期参考帧就是和当前帧相邻的帧，按照从近到远的顺序排序。</li>
<li>长期参考帧是较早之前的帧，按照从远到近的方式排列。</li>
<li>不使用的参考帧是因为某些原因废弃了的参考帧，并且没有被新的参考帧替换掉。比如遇到 IDR 帧的时候 DPB 里面的所有参考帧都会标记成非参考状态。所以 I 帧之后的 P 帧也可以参考这个 I 帧之前的图像。</li>
</ul>
<h3 id="mv-预测和-skip-模式">MV 预测和 Skip 模式</h3>
<p>需要对 MV 进行压缩，方式是使用临近分块 MV 之前的相关性对当前块的 MV 进行预测，只对预测残差 MVD 进行编码。</p>
<p>Skip 模式：Skip 模式只针对宏块编码，也就是完全不用编码只需要在码流里面标明是 SKIP 宏块就行。P_Skip 宏块就是 COPY 宏块，既没有 MVD，也不编码量化残差，解码时候直接用 MVp 作为运动向量得到像素的预测值作为像素重建值。B_Skip 宏块也是既没有 MVD 也没有量化残差，解码时候通过 Direct 预测模式计算出前向和后向 MV，然后得到像素预测值作为重建值。</p>
<ul>
<li>
<p>P_Skip：最佳模式是 Inter16x16、参考帧是 List0 里面的第一个参考帧、MVD=0、变换系数被量化成 0，或者在 RDO 模型中被抛弃。</p>
</li>
<li>
<p>B_Skip：最佳模式是 B_direct_16x16，变换系数要么全是 0 要么被算法抛弃。</p>
</li>
</ul>
<h3 id="加权预测">加权预测</h3>
<p>用来应对明暗/亮度变化的场景，使用两种预测模式：显式模式(P 帧、B 帧)和隐式模式(B 帧)。</p>
<ul>
<li>显式模式：加权系数由编码器决定并且在 Slice Header 里面传输。</li>
<li>隐式模式：加权系数由参考图像的时间位置推算，越接近当前图像，加权系数越大。</li>
</ul>
<p>步骤：</p>
<ol>
<li>
<p>亮度变化检测：</p>
<p>使用直方图计算前后两幅图像在各个灰度级别 SAD，然后采用阈值法判断有没有发生亮度变化。</p>
</li>
<li>
<p>计算加权系数：
第一种方法：计算参考帧和当前帧的亮度均值比值，利用比值作为加权系数（全局加权补偿的效果有限）</p>
<p>第二种方法：全局补偿，但是使用使前后图像 MSE 和偏移量最小的加权系数：使 MSE 的表达式（加权系数$W_1$和偏移量$W_2$）分别基于$W_1$和$W_2$的偏微分等于 0。</p>
</li>
<li>
<p>亮度补偿：</p>
<p>原则上需要做到宏块级别的亮度补偿，但是为了降低复杂度只做帧级亮度补偿。</p>
<p>根据求出的加权系数和偏移量进行全局亮度补偿得到新图像。</p>
<p>把新图像存到一个列表中作为带亮度补偿运动估计的参考帧。</p>
</li>
</ol>
<h2 id="帧内预测">帧内预测</h2>
<p>帧内预测实质是消除空间冗余，利用已编码的块的像素的来预测未编码的像素值。</p>
<p>未编码的块像素的实际值-预测值=残差，传输只需要传输残差。</p>
<p>H264 引入了基于空域的帧内预测技术，在空域中利用当前块的相邻像素直接对每个像素做预测，并对预测残差进行变换、量化。</p>
<p>H264 帧内预测中，色度和亮度信息是被分开预测的。</p>
<ul>
<li>对于亮度待编码块，可以按照 4x4 块方式预测(I4MB)或 16x16 宏块方式预测(I16MB)。
<ul>
<li>4x4 预测时有 9 种模式（水平、垂直、DC、6 个方向），用于图像细节部分的预测。</li>
<li>16x16 预测时有 4 种模式（水平、垂直、DC、平面），用于图像平坦区域的预测。</li>
</ul>
</li>
<li>对于色度待编码块，基于 8x8 块进行预测。
<ul>
<li>8x8 预测有 4 种模式（水平、垂直、DC、平面）。</li>
</ul>
</li>
</ul>
<p>亮度和色度的最佳帧内预测模式相互独立：</p>
<ul>
<li>
<p>色度的只需要比较 4 种模式的代价，选择最小的。</p>
</li>
<li>
<p>亮度的需要：算出代价最小的 Intra4x4 模式、算出代价最小的 Intra16x16 模式、取两者最小的。</p>
<ul>
<li>Intra4x4：用 RDO 模型也就是拉格朗日模型计算代价。</li>
<li>Intra16x16：用 SATD，变换使用哈达马变换（看作是简单的时频变换，可以反映生成码流的大小）</li>
</ul>
</li>
</ul>
<h2 id="变换编码">变换编码</h2>
<p>变换编码（Transform Coding）将空间域描述的图像，经过某种变换形成变换域中的数据，达到改变数据分布，减少有效数据量的目的。</p>
<p>变换编码中主要使用方式是正交变换。正交变换不会改变信源的熵值，变换之后图像的信息量并没有损失，完全可以通过反变换得到原来的图像值。</p>
<p>正交变换可以改变数据的分布，将数据集中分布之后就可以使用进一步的量化操作来去除大部分的 0 值和接近 0 的值。</p>
<p>正交变换中的理论最优变换是 K-L 变换。</p>
<p>实际中常用的正交变换有 DCT 变换，DFT 变换(离散傅里叶变换)，Hadamard 变换。</p>
<p>因为 DCT 系数主要集中在低频区域，越是高频区域系数值越小，通过设置不同的视觉阈值的量化电平，将许多能量较小的高频系数量化为 0，可以增加变换系数中 0 的个数，同时保留能量较大的系数分量，对量化之后的系数进行熵编码可以获得进一步的压缩。</p>
<p>H264 使用的是整数变换，变换核只用加减法和左移操作实现，不需要乘法器。</p>
<p>各种变换的比较：</p>
<ul>
<li>压缩比和重建质量：
<ul>
<li>较小分块时，DCT 的 MSE 接近 K-L 变换。</li>
<li>块大小超过 16x16 时，除傅里叶变换之外，其他几种变换的 MSE 下降很慢。</li>
<li>大方块尺寸时，傅里叶变换趋向于 K-L 变换。</li>
</ul>
</li>
<li>计算复杂度：
<ul>
<li>Hadamard 计算复杂度最小。</li>
<li>其次是 DFT 和 DCT，具有固定的核函数。</li>
<li>K-L 变换的核函数与输入相关，计算量很大，不实用。</li>
</ul>
</li>
</ul>
<p>变换编码中的失真还是由量化器引起，正反变换和变长编解码都是无损处理。</p>
<h3 id="dct-变换">DCT 变换</h3>
<p>离散余弦变换与 DFT 变换相似，但是 DCT 变换只使用实数。</p>
<p>DCT 变换具有能量集中性，大多数的声音和图像信号的能量都集中在 DCT 变换之后的低频部分。</p>
<p>当信号具有接近马尔可夫过程的统计特性时，DCT 变换的去相关性接近于 K-L 变换。</p>
<p>图像处理领域中，DCT 变换的效果要强于 DFT 变换，因而图像处理中更多应用的是 DCT 变换。</p>
<p>DCT 产生的系数很容易被量化，因而可以获得较好的块压缩。</p>
<p>DCT 算法的性能好，有快速算法，采用快速傅里叶变换可以进行高效的运算。</p>
<h2 id="量化">量化</h2>
<p>量化的思想就是映射一个输入间隔到一个整数，减少信源编码的 bit 数。</p>
<p>量化器的设计就是率失真优化问题，在允许一定失真的条件下，获得尽可能高的压缩比。</p>
<p>量化步长决定量化器的编码压缩率和图像精度。</p>
<p>量化最简单的方法就是均匀（线性）量化，但均匀量化的效果往往并不好，因为它没有考虑到量化对象的概率分布。</p>
<p>对 DCT 系数这样的数据而言，其分布大部分集中在直流和低频附近，如果采用非均匀量化，对低频区域进行细量化，对高频区域进行粗量化，在相同的量化步长的条件下，非均匀量化比均匀量化所造成的量化误差要小得多。</p>
<p>量化之后，熵编码之前，可以根据从高到低的统计特性，对系数进行 Zigzag 锯齿扫描和游程长度编码。这样做的原因在于：量化之后的 DCT 系数更为稀疏，只有少数的 AC 系数不为 0，Zigzag 扫描能增加连 0 的长度，减少统计事件的个数，从而进一步增加对 DCT 系数熵编码的压缩率。</p>
<p>量化区间上的最优量化值应该是区间的期望值，所以需要知道残差变换系数的统计分布。</p>
<p>引入量化偏移量 f 来进行非均匀量化，在帧内预测时 f=Qstep/3，帧间预测时 f=Qstep/6.</p>
<p>f 可以控制量化死区大小，f 变大，量化死区减少，f 变小，量化死区增加。死区大小直接影响图像的主观质量。</p>
<h2 id="去块滤波不是很了解细节">去块滤波（不是很了解细节）</h2>
<p>环路滤波器是被放置在编解码的图像重建环路当中。</p>
<p>在启用了环路滤波的编解码环境中，无论是编码器还是解码器，都是在图像被重建后才进行滤波。</p>
<p>在编码器中，滤波后的图像会作为后续编码运动补偿的参考图像；</p>
<p>在解码器中，滤波后的图像会被输出显示并且作为后续图像解码重建的参考图像。</p>
<h3 id="块效应出现的原因">块效应出现的原因</h3>
<ol>
<li>基于块的量化会破坏相邻块之间的相关性，并且在低码率情况下会放大这种误差。</li>
<li>运动补偿加剧了由变换量化导致的块效应。因为运动补偿块的匹配不可能绝对准确，各个块的残差大小程度存在差异，尤其是当相邻两个块用的参考帧不同、运动矢量或参考块的差距过大时，块边界上产生的数据不连续就更加明显。</li>
</ol>
<h3 id="过程">过程</h3>
<p>估算边界强度、区分真假边界、滤波运算</p>
<h2 id="熵编码">熵编码</h2>
<p>主要利用信源的统计特性进行码率压缩，是无损压缩编码方法。</p>
<p>H264 支持 CAVLC（变长编码）和 CABAC（二进制算术编码）。</p>
<p>CAVLC 本质是哈夫曼编码，所以必须为所有可能的长度为 N 的序列设计和存储编码表，复杂度随 N 指数增长。</p>
<p>CABAC 的思想是用 0 到 1 区间上的一个数来表示整个字符输入流，而不是为输入流中的每个字符分别指定码字。</p>
<ul>
<li>算术编码用区间递进的方法为输入流寻找码字，从第一个符号确定的初始区间开始，逐个读入输入流，在每个新的字符出现后递归地划分当前区间，划分的依据是各个字符的概率，将当前区间按照各个字符的概率划分成若干子区间，将当前字符对应的子 2 区间取出，作为处理下一个字符时的当前区间。到处理完最后一个字符后，得到了最终区间，在最终区间中任意挑选一个数作为输出。在解码时候也采用相同的方法和步骤，但是解码器每划分一个子区间就能得到输入流中的一个字符。</li>
<li>在实际过程中，输入流中字符的概率分布是动态改变的，这需要维护一个概率表去记录概率变化的信息。在作递进计算时，通过对概率表中的值估计当前字符的概率，当前字符处理后，需要重新刷新概率表。这个过程表现为对输入流字符的自适应。编码器和解码器按照同样的方法估计和刷新概率表，从而保证编码后的码流能够顺利解码。</li>
</ul>
<p>一般来讲，只要计算量允许，就应该选择使用算术编码。</p>
<p>H264 对不同的数据采用不同的熵编码模式，对于宏块和子块的残差数据经过变换之后的系数采用 CAVLC，对于其他相对重要的语法元素使用指数哥伦布编码。在 CABAC 方案里，对不同的语法元素也使用了不同的编码树结构。</p>
<h2 id="gopframesliceibp">GOP/Frame/Slice/I/B/P</h2>
<p>帧 Frame 包含切片 Slice，Slice 包含宏块 Macroblock(MB)。</p>
<p>一个 Frame 至少包含一个 Slice，一个 Slice 至少包含一个 MB。</p>
<p>Slice 是 MB 的载体，出现的原因是为了防止误码的扩散和传播。</p>
<p>每个 Slice 都是互相独立被传输的，某个 Slice 不能以其他 Slice 中的 MB 为参考。</p>
<p>Slice 存储在 NAL 单元 NALU 中，是 NALU 的有效载荷 Payload。</p>
<p>Slice 中包含 Slice Header 和 Slice Payload。</p>
<p>Slice Header 中存放的是 Slice 类型、Slice 中的宏块类型、Slice 属于哪个 Frame、对应的帧的设置和参数等信息，Slice Payload 中存放的是 MB</p>
<p>MB 中包含了 MB 类型、预测类型、Coded Block Pattern(CBP)、量化参数 QP、像素的亮度和色度数据等信息</p>
<p>GOP 由 IDR 帧开始，中间存在多个 P 帧或 B 帧（基本档次 Baseline Profile 不存在）</p>
<p>I 帧只进行帧内编码，IDR 帧是每个 GOP 的第一个帧，IDR 帧是 I 帧，I 帧不一定是 IDR 帧</p>
<p>P 帧参考前面的 I 帧或者 P 帧进行编码；</p>
<p>B 帧参考前向、后向的 I 帧或 P 帧进行编码；</p>
<p>P/B 帧进行编码时候只能参考当前 GOP 的 I/P 帧，不能越过当前 GOP 开始时的 IDR 帧，但是 I 帧之后的 P 帧也可以参考这个 I 帧之前的图像。</p>
<h2 id="spsppsdtspts">SPS/PPS/DTS/PTS</h2>
<p>SPS：序列参数集，描述的是整个视频序列的参数信息，如图像的宽度、高度、帧率、色度空间等，一个视频序列只有一个 SPS，用于描述整个视频序列的基本特性。SPS 一般在视频码流的开头发送，是一种全局静态的描述方式。当然，如果编码器在编码过程中改变了 SPS 中描述的参数如分辨率时也需要发送新的 SPS。</p>
<p>PPS：图像参数集，描述的是一个序列中一个或多个图像的参数，例如编码图像的配置、QP 这些，可以在视频序列的任何时刻发送，PPS 相对与 SPS 来说比较灵活动态。</p>
<p>发 I 帧之前至少要发一次 SPS 和 PPS</p>
<p>DTS：解码时间序列，编码帧时的顺序</p>
<p>PTS：展示时间序列，展示帧时的顺序，当有 B 帧时 PTS 不等于 DTS</p>
<p>编码之后的 VCL 数据被封装进 NALU 中，构成了 h264 原始码流</p>
<p></p>
<h2 id="nalu">NALU</h2>
<p>NALU 是视频编码的基本单位，同时也是后续进行视频传输的基本单位。</p>
<p>不同应用需求采用不同的传输方式，NALU 根据传输方式可以以两种方式应用于传输业务。</p>
<ul>
<li>
<p>一类是字节流，即把 NALU 按照解码顺序生成连续的比特流进行传输和处理。</p>
</li>
<li>
<p>一类是分组流应用，也是本文使用的实时视频通信的应用场景，网络可以根据不同网络分组的重要性优化视频流的服务质量，分组流通过将编码后得到的 NALU 作为网络传输的载荷。</p>
</li>
</ul>
<p>NALU 由 NAL Header 和 RBSP 组成，Header 占一个字节，分为 3 个部分。</p>
<p>第 1 个部分是第 0 位，禁止位，值为 0，值为 1 表示语法错误。</p>
<p>第 2 个部分是第 1~2 位，表示当前 NAL 的优先级。值越高表示当前 NAL 越重要，越需要优先保护。SPS/PPS/IDR 帧非常重要，I/P 帧重要，B 帧/SEI 不重要</p>
<p>第 3 个部分是第 3~7 位，表示当前 NALU 的类型：</p>
<p></p>
<p>RBSP：原始字节序列载荷，是 NALU 数据部分的封装格式，封装的数据来自于 SODB（原始数据比特流）。</p>
<p>SODB 是编码后的原始数据。SODB 到 RBSP 的过程：
如果 SODB 是空的，生成的 RBSP 也是空的。
否则：
RBSP 的第一个字节直接取自 SODB 的第 1~8 个 bit，（RBSP 字节内的 bit 按照从左到右对应位从高到低的顺序排列），RBSP 其余的每个字节都直接取自 SODB 的相应 bit。RBSP 的最后一个字节包含 SODB 的最后几个 Bit 和 rbsp_trailing_bits()
rbsp_trailing_bits 的第一个 bit 是 1，接下来填充 0 直到字节对齐。
最后添加几个 cabac_zero_word，值为 0x0000.</p>
<p>NALU 主要涉及到 SPS/PPS/SEI 和 Slice 这几种类型。</p>
<p>SEI 是补充增强信息，提供了向视频码流中加入额外信息的方法，不是解码过程中的必须选项，可能对解码过程有帮助，集成在视频码流中。</p>
<p>RBSP 字节流加上 0x0300 就得到 NALU 载荷字节流：</p>
<p></p>
<h2 id="profilelevel">Profile/Level</h2>
<p>Profile 主要对视频编码的特性做了差异化支持。</p>
<p></p>
<p>H264 中的常用 Profile 有 Baseline，Extended，Main 和 High</p>
<p>Baseline Profile：基本画质，只支持 I/P 帧和 CAVLC 和无交错</p>
<p>Extended Profile：进阶画质，支持 I/P/B/SP/SI，只支持 CAVLC 和无交错</p>
<p>Main Profile：主流画质，支持 I/P/B 帧和，交错和无交错、CAVLC 和 CABAC</p>
<p>High Profile：高级画质：在 Main 的基础上增加了 8x8 内部预测、自定义量化和更多的 yuv 格式。</p>
<p>Baseline Profile 主要用于实时视频通信，Main Profile 和 High Profile 主要用于流媒体领域。</p>
<p>Level 主要根据设备能力来确定编解码时的码率/分辨率上限支持</p>
<h2 id="cbrvbrabrcrf">CBR/VBR/ABR/CRF</h2>
<p>CBR：恒定码率，每秒传输的 bit 数固定，每个视频帧都被分配相同数量的 bit，和复杂度无关，适用于要求网络或者存储带宽具有固定容量的场景，但可能导致复杂场景下的帧质量下降。WebRTC 中使用的就是 CBR。</p>
<p>VBR：可变码率，允许每个帧使用不同的比特数，根据图像复杂度和需要进行动态分配。适合于在不同场景下需要保持一致质量的情况，但是消耗的带宽会有较大波动。适合用于视频存储，不适合网络传输。</p>
<p>ABR：平均码率，允许在整个视频序列中有一定的变化，但是在一个时间窗口内保持一定的平均码率。在此时间内，对简单、静态的图像分配低于平均码率的码率，对于复杂的、大量运动的图像分配高于平均码率的码流。码率分配比较均衡，比较适合网络传输。</p>
<p>CRF：恒定质量因子，追求的是恒定的视觉质量，编码器根据图像内容自动调整码率，以保持相对恒定的质量。适合于追求质量而不在乎码率的场景如视频剪辑和存档。</p>
<h2 id="openh264-码控">OpenH264 码控</h2>
<p>编码第一个 IDR 帧时使用固定的 QP，具体的值使用视频分辨率作为判断依据并查表得出并将其初始化为 initialQP：</p>
<p></p>
<p>将 QP 查表转换为 QStep 完成初始化：</p>
<p></p>
<p>之后进行 IDR 帧的量化及后续编码操作，并得到 frameDqBits（已编码的比特数），由此可以计算 intraCmplx：</p>
<p></p>
<p>对于第一个 PFrame，linearCmplx 也使用下面的公式计算，其中 QStep 使用 initialQP 查表。</p>
<p></p>
<p>之后计算 QStep&amp;QP 时就使用一阶 RQ 模型计算，frameComplexity 在预处理阶段得出。</p>
<p></p>
<h2 id="rtp">RTP</h2>
<p>RTP（Real-time Transport Protocol，实时传输协议）是一种应用层协议，通常基于 UDP 协议，但也支持 TCP 协议。</p>
<p>它提供了端到端的实时传输数据的功能，但不包含资源预留存 1（resource reservation）、不保证实时传输质量，这些功能都需要 WebRTC 自己实现。</p>
<p>RTP 协议分为两种子协议，分别是 RTP Data Transfer Protocol 和 RTP Control Protocol。</p>
<p>前者顾名思义，是用来传输实时数据的；后者则是我们常说的 RTCP 协议，可以提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包。</p>
<p>RT(D)P 包分为两部分，分别是 header 和 payload，header 包含了实时音视频的同步信息（和一些额外参数），payload 则承载了具体的音视频数据。这里我们只需要关注 header 结构就好，payload 是编解码器关心的。</p>
<p></p>
<p>如图所示，RT(D)P header 最小为 12 bytes；红色部分为可选字段。字段的含义分别如下：</p>
<ul>
<li>Version 表示 RTP 协议的版本，目前版本为 2。</li>
<li>P (Padding) 表示 RT(D)P 包末尾是否有 padding bytes，且 padding bytes 的最后一个 byte 表示 bytes 的数量。Padding 可以被用来填充数据块，比如加密算法可能会用到。</li>
<li>X (Extension) 表示是否有头部扩展，头部扩展可以用于存储信息，比如视频旋转角度。</li>
<li>CC (CSRC count) 表示红色部分的 CSRC（参见下文）数量，显然最多只能有 15 个 CSRC。</li>
<li>M (Marker) 表示当前数据是否与应用程序有某种特殊的相关性。比如传输的是一些私有数据，或者数据中的某些标志位具有特殊的作用。</li>
<li>PT (Payload type) 表示 payload 的数据类型，音视频的默认映射格式可参见 RFC 3551。</li>
<li>Sequence number 是递增的序列号，用于标记每一个被发送的 RT(D)P 包。接收方可以根据序列号按顺序重新组包，以及识别是否有丢包。序列号的初始值应当是随机的（不可预测的），从而增加明文攻击的难度。</li>
<li>Timestamp 即时间戳，接收方根据其来回放音视频。时间戳的间隔由传输的数据类型（或具体的应用场景）确定，比如音频通常以 125µs（8kHz）的时钟频率进行采样，而视频则以 90kHz 的时钟频率采样。这里时间戳的初始值也是随机选取的，是一种相对时间戳。</li>
<li>SSRC (Synchronization source) 即同步源标识符。相同 RTP 会话中的 SSRC 是唯一的，且生成的 SSRC 也需要保持随机。尽管多个源选中同一个标识符的概率很低，但具体实现时仍然需要这种情况发生，即避免碰撞。</li>
<li>CSRC (Contributing source) 在 MCU 混流时使用，表示混流出的新的音视频流的 SSRC 是由哪些源 SSRC 贡献的。根据上述 CC 得知，我们最多可以同时混 15 路音视频流。</li>
<li>Extension header 即头部扩展，包含了音视频的一些额外信息，比如视频旋转角度。</li>
</ul>
<h3 id="rtp-与-nalu-分组">RTP 与 NALU 分组</h3>
<p>RFC3984 给出了 3 中不同的 RTP 打包方案：</p>
<ol>
<li>Single NALU Packet：在一个 RTP 包中只封装一个 NALU，对于小于 1400 字节的 NALU 便采用这种打包方案。</li>
<li>Aggregation Packet：在一个 RTP 包中封装多个 NALU，对于较小的 NALU 可以采用这种打包方案，从而提高传输效率。</li>
<li>Fragmentation Unit：一个 NALU 封装在多个 RTP 包中，在本文中，对于大于 1400 字节的 NALU 便采用这种方案进行拆包处理。</li>
</ol>
<h2 id="rtcp">RTCP</h2>
<p>RTCP 协议提供实时传输过程中的统计信息，如网络延迟、丢包率等。</p>
<p>在传统的实时通讯过程中，RT(D)P 协议占用偶数位的端口，而 RTCP 协议占用随后的奇数位端口。</p>
<p>不过如果接收方的 SDP 中包含 rtcp-mux 字段 6，即表明接收方支持 RT(D)P 协议和 RTCP 协议共用同一个端口，即多路复用。在 Chrome 57 版本已经强制开启了 rtcp-mux 。</p>
<p>对于 RTCP 包而言，我们不只要关注 header 的结构，还要关注具体的 report block 内容。不过我们先来看一个典型的 RTCP header 结构，如下图所示：</p>
<p></p>
<p>RTCP header 的固定大小为 8 bytes，其中 Version、P、SSRC 的含义同上述 RTP header 相同，在此不与赘述。其他几个字段的含义分别如下：
RC (Reception report count) 表示当前 RTCP 包有几个 block，显然最多只能有 32 个。</p>
<ul>
<li>PT (Packet type) 表示 RTCP 包的类型，比如 SR=200、RR=201（SR、RR 参见下文）。</li>
<li>Length 等于整个 RTCP 包的长度减一（使得 Length = 0 是合法的），其值包含 header 的长度和所有 padding 占用的空间长度。值的单位是以 32 位字长（32-bit words）描述的。</li>
</ul>
<h2 id="psnrssimvmafbd-rate">PSNR/SSIM/VMAF/BD-Rate</h2>
<h3 id="psnr">PSNR</h3>
<p>峰值信噪比，基于均方误差（MSE）计算。</p>
<p>公式：</p>
<p>$$
PSNR = 10 \cdot log_{10}(\frac{MAX_I^2}{MSE})
$$</p>
<p>$$
MSE = \frac{1}{MN}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1}[I(i,j) - K(i,j)]^2
$$</p>
<p>对于用 8bit 表示的视频图像而言，MAX 就是 255</p>
<p>PSNR 的物理含义就是信号的峰值与平均误差的比值，如果误差越小，那么 PSNR 值越高。如果完全没有误差，那么 PSNR 值就是无穷大。</p>
<p>对于图像数据来说，通常有 Y、U、V 三个分量，可以对三个分量各自计算 PSNR。</p>
<p>也可以把三个分量的 PSNR 值以一定的权重加起来作为总的 PSNR 值。</p>
<p>对于整个视频来说，可以计算单帧的 PSNR 值，然后平均，也可以计算整个视频的 Overall PSNR。</p>
<ul>
<li>
<p>一般，psnr 值高于 40dB，表示画面质量极好，（非常接近于原始图像）；</p>
</li>
<li>
<p>psnr 值在 30dB-40dB 之间，表示画面质量较好（有失真但可接受）；</p>
</li>
<li>
<p>psnr 值在 20dB-30dB 之间，表示画面质量差；</p>
</li>
</ul>
<h3 id="ssim">SSIM</h3>
<p>PSNR 指标比较常用，但是不能体现编码前后图像之间的相关性，SSIM 可以从亮度，对比度和结构三个方面来描述编码前后图像之间的相似性。</p>
<ul>
<li>
<p>亮度维度的相似性用均值计算，𝝁𝒙为均值：</p>
<p></p>
</li>
<li>
<p>对比度维度的相似性用方差计算，𝝈𝒙 为方差：</p>
<p></p>
</li>
<li>
<p>结构维度的相似性用协方差计算， 𝝈𝒙𝒚 表示协方差：</p>
<p></p>
</li>
</ul>
<p>SSIM 指标和 SSIM 计算公式：</p>
<p></p>
<p>SSIM 性质：</p>
<p></p>
<h3 id="vmaf">VMAF</h3>
<p>VMAF 是一种 Full reference 的视频质量评估方法，适用于视频流媒体质量评估。</p>
<p>主要包括三种指标：视觉信息保真度 (VIF: visualquality fidelity) 、细节损失指标 (DLM: detail loss measure) 、时域运动指标/平均相关位置像素差 (Tl: temporal information) 。</p>
<ul>
<li>其中 VIF 和 DLM 是空间域的一个画面之内的特征。</li>
<li>TI 是时间域的，多个画面之间相关性的特征。</li>
</ul>
<p>这些特性之间融合计算总分的过程使用了训练好的 SVM 来预测。</p>
<p>VMAF 基于 SVM 的 nuSvr 算法，在运行的过程中，根据事先训练好的 model，赋予每种视频特征以不同的权重。对每一帧画面都生成一个评分。最终以均值算法进行汇总，算出该视频的最终评分</p>
<p>使用方式：</p>
<p>计算时需要保证编码后图像的分辨率与原始图像分辨率一致，如果不一致需要向上或者向下缩放编码图像，而不能缩放原始图像。</p>
<h3 id="bd-rate">BD-Rate</h3>
<p>比较两个编码器的 RD 曲线（Rate-Distortion）的差异：</p>
<ul>
<li>一种是相同质量下的码率差异，指标为 BD-Rate。</li>
<li>一种是相同码率下的质量差异，指标为 BD-PSNR。</li>
</ul>
<p>BD-Rate 是选取一个范围的的多个采样点（通常是 4 个），然后进行曲线拟合插值，最后计算出平均的指标差异。目前大部分测试数据的对比，都是基于 BDRate 指标的。</p>
<h2 id="视频封装">视频封装</h2>
<p>视频的封装格式定义的是多媒体数据的存储结构，包括如何组织和存储音频、视频、字幕、元数据等信息，以及怎么进行同步和时间标记。</p>
<p>感觉封装其实可以理解为是一个柜子，并且对柜子里的不同抽屉里面能存放哪些数据以及怎么存放数据做了规定。\</p>
<p>常见的封装格式有 Mp4、Mkv，微软的 AVI、苹果的 MOV、Adobe 的 FLV、Google 的 Webm。</p>
<p>不同的封装格式提供了一种统一的方式来存储和传输各种编码格式的多媒体数据。</p>
<p>H264 支持 AnnexB 和 AVCC 两种封装模式。</p>
<ul>
<li>
<p>AnnexB 模式是传统模式，有 startcode，SPS 和 PPS 在码流中分别作为一个 NALU。</p>
</li>
<li>
<p>AVCC 模式没有 startcode，SPS 和 PPS 以及其它信息被封装在 container 中，每个 frame 前面 4 个字节是这个 frame 的长度。一般在 mp4 和 mkv 中使用 AVCC。</p>
</li>
</ul>
<h2 id="硬件编码和软件编码">硬件编码和软件编码</h2>
<p>硬编码是通过专用的硬件编码器，比如 GPU 或者专用的视频编码芯片来进行的，硬件编码可以利用专为编码设计的电路从而提供更高的编码速度和更低的功耗，适用于实时性要求较高的应用比如云游戏、视频会议这些场景。硬编码也通常会在移动设备比如手机或者其他的专业视频设备中使用</p>
<p>软编码是通过通用的计算设备，一般来讲就是用 CPU 编码。软编码的性能和功耗一般来讲要比硬件编码差，但是可以跨平台运行，容易升级和更新，编码的画质也会更好。一般用于需要更大灵活性和可定制性的应用，比如短视频录制、非实时的转码等。</p>
<h2 id="码率和分辨率">码率和分辨率</h2>
<p>码率提高和分辨率提高都会增大视频的体积，两者之间需要平衡。</p>
<ul>
<li>
<p>在码率一定的情况下，提高分辨率可能会导致每个像素获得的比特数减少，从而降低整体感知质量。</p>
</li>
<li>
<p>在分辨率一定的情况下，提高码率可以分配更多的比特给每个像素，从而提高每个像素的清晰度。</p>
</li>
</ul>
<p>高分辨率主要是为了适应更大的屏幕尺寸，或者需要更多图像细节的任务。</p>
<p>其实屏幕尺寸和分辨率之间的关系有点类似于分辨率和码率之间的关系。</p>
<h2 id="一个视频文件能否倒放">一个视频文件能否倒放</h2>
<p>一个文件不行，至少需要两个文件才可以。</p>
<p>理论上方式有两种：</p>
<ul>
<li>
<p>第一种是先顺序解码视频到一个 yuv 文件中，然后倒序读入内存进行编码。</p>
</li>
<li>
<p>第二种是先遍历视频，获取一共有多少个 GOP，跳到最后一个 GOP 的 IDR 帧，对这个 GOP 进行解码输出到 yuv 文件中，再逆序读出这个解码之后的 yuv 文件然后编码，这样最后一个 GOP 就变成了第一个 GOP，按照从后往前的顺序依次类推就可以。</p>
</li>
</ul>
<p>第一种方式简单粗暴好实现，但是对于磁盘存储空间的要求比较高。</p>
<h2 id="h265hevc比-h264avc做了哪些改进">H265(HEVC)比 H264(AVC)做了哪些改进</h2>
<ul>
<li>
<p>H265 针对编码的各个环节都引入各自对应的单元。</p>
<ul>
<li>
<p>与 H264 中宏块类似的是，在 H.265 里面用的是一系列互不重叠的编码树单元 CTU 处理信息，CTU 内部可以以四叉树结构递归向下划分成更小的正方形编码单元 CU。CU 可以支持最大 64x64 的尺寸，因而可以对高分辨率视频中的平坦和复杂区域做有针对性的 CTU 划分。</p>
</li>
<li>
<p>预测单元 PU 是定义在 CU 上的一个矩形区域，用来存储和预测相关的所有信息如帧内预测方向、帧间预测的参考帧、和 MV 等。</p>
</li>
<li>
<p>变换单元 TU 是变换和量化的基本单位，支持 4 种正方形的尺寸大小(4/8/16/32)。变换时采用 RQT 技术，基于四叉树结构进行自适应变换。大块的 TU 模式能够将能量更好地集中，小块的 TU 模式能够保存更多的图像细节。根据当前 CU 内残差特性，自适应选择变换块大小，可以在能量集中和细节保留两者做最优的折中。与传统的固定块大小变换相比，RQT 对编码效率贡献更大。</p>
</li>
<li>
<p>CU 划分成 PU 和 TU，PU 和 TU 之间存在交叉重叠关系，Inter 预测时允许 CU 内的 TU 跨越 PU 边界，Intra 预测时，TU 不能跨越 PU 边界。</p>
</li>
</ul>
</li>
<li>
<p>在帧内预测模块，H265 支持更多的帧内预测模式。H265 的亮度分量支持 35 种帧内预测模式包括平面模式、DC 模式和 33 种角度模式，色度分量有 5 种帧内预测模式包括平面模式、DC 模式、水平、垂直方向模式和对应于亮度分量的帧内预测模式。</p>
</li>
<li>
<p>在帧间预测模块，H265 引入了更加复杂的 ME 方式，主要包括 Merge 和 AMPV 以及基于 Merge 的 Skip 模式。</p>
<ul>
<li>Merge：取相邻 PU 的运动参数作为当前 PU 的运动参数（利用空域相关性和时域相关性）</li>
<li>AMVP 得到的 MV 一方面为 ME 提供了搜索起点，另一方面也用于预测 MV。AMVP 根据周围块预测 MV，MV=MVP+MVD(矢量差值)</li>
</ul>
</li>
<li>
<p>H265 把变换和量化模块结合了起来，降低了计算复杂度，支持加权量化矩阵。</p>
</li>
<li>
<p>在环路滤波模块，H265 新增了采样点自适应偏移滤波 SAO，通过解析去方块滤波后的像素的统计特性，为像素添加相应的偏移值，削弱振铃效应。</p>
</li>
<li>
<p>因为 H265 的解码要比 h264 的解码复杂很多，所以提供了很多可以并行优化的思路。</p>
</li>
</ul>
<h2 id="simd">SIMD</h2>
<p>SIMD 是一种并行计算技术，允许单一指令处理多个数据元素。SIMD 指令集通常由处理器提供，用于加速向量化计算。视频编码中，SIMD 可以用于加速压缩和解压算法。</p>
<h2 id="h264-中的差错控制">H264 中的差错控制</h2>
<p>Slice 分割、Data Partition (DPA &gt; DPB &gt; DPC)、对 SPS 和 PPS 提供使用高传输优先级、差异化的熵编码（对重要的 SPS 和 PPS 采用指数哥伦布编码）</p>
<p>FMO 通过宏块分配映射把同一帧里的不同宏块划分到不同的 Slice Group 里，在同一个 Slice Group 里的 MB 按照普通的光栅扫描顺序编码。</p>
<p>因为不管是 Intra Coding 还是 Inter Coding 都必须使用同一个 Slice group 的宏块数据，这样当一个 Slice group 里的某一个或者某几个宏块发生错误时候，因为相邻的宏块可能分布在不同的 Slice group，就可以从其他正确接收的 Slice group 里拿到和丢失宏块相邻的宏块信息来进行错误掩盖。</p>
<h2 id="svc">SVC</h2>
<p>SVC：(Scalable Video Coding)可伸缩视频编码，编码器产生的码流包含一个或者多个子码流或者层，子码流可以有不同的码流、帧率和分辨率。基本层编码最低层的时域、空域和质量流；增强层以基本层作为起始点，对附加信息进行，从而在解码过程中重构更高层的质量、分辨率和时域层。通过解码基本层和相邻增强层，解码器能生成特定层的视频流。</p>
<ul>
<li>
<p>时域分层：从码流中提取出有不同帧频的码流。</p>
</li>
<li>
<p>空域分层：从码流中提取出有不同分辨率的码流。</p>
</li>
<li>
<p>质量分层：从码流中提取出有不同质量的码流。</p>
</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<p>监控：监控视频流产生两路，一路质量好的用于存储，一路低码率的用于预览。</p>
<p>视频会议：会议终端利用 SVC 编出多种分辨率、分层质量的码流，会议中心替代传统的 MCU 二次编解码方法改成视频路由分解转发。也可以在丢包环境下利用时域分级，抛弃一些时域级别实现网络适应性。</p>
<p>流媒体 IPTV：服务器可以根据不同的网络情况丢弃质量层，保证视频的流畅。兼容不同网络环境和终端。</p>
<h3 id="优缺点">优缺点</h3>
<p>优点：分级码流优点是应用非常灵活，因为能根据需要产生不同的码流或者提取出不同的码流。使用 SVC 实现一次分层编码比用 AVC 编多次更高效。
SFU 从发布客户端复制音视频流的信息，然后分发到多个订阅客户端。典型的应用场景是 1 对多的直播服务。SFU 是解决服务端性能问题的好方法，因为它不涉及视频解码和编码的计算费用，用最低的开销来转发各路媒体流，能实现海量的客户端接入。重终端，轻平台。</p>
<p>缺点：因为 SVC 解码控制复杂不利于流式处理，硬件编解码器支持差，协议协商细节复杂，业界标准不统一。</p>
<h2 id="rtc-应用中提高实时性">RTC 应用中提高实时性</h2>
<p>因为编码主要的时间开销在运动预测过程中，如果在云游戏的场景下，可以得到游戏画面中物体的运动信息然后考虑用来辅助运动预测，或者说对搜索过程进行剪枝。</p>
]]></description>
</item>
<item>
    <title>远程桌面与WebRTC</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/remote-desktop-with-webrtc/</link>
    <pubDate>Thu, 15 Jun 2023 18:21:02 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/remote-desktop-with-webrtc/</guid>
    <description><![CDATA[<h1 id="关于远程桌面">关于远程桌面</h1>
<p>远程桌面是一种将一台计算机的桌面控制权限交给网络上另一台计算机的技术，两台计算机之间建立连接之后，可以进行音视频以及控制信令的相互传输，从而实现远程控制的功能。</p>
<h1 id="远程桌面技术的实现">远程桌面技术的实现</h1>
<p>基于远程桌面要完成的任务目标，其需要实现以下两个核心功能：</p>
<ol>
<li>音视频的传输，即需要让控制机收到受控机的音频跟视频。</li>
<li>控制信令的传输，即鼠标键盘的控制信号等</li>
</ol>
<p>目前主流的远程桌面技术主要有 2 种：</p>
<ol>
<li>基于<a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing" target="_blank" rel="noopener noreffer">VNC(Virtual Network Computing)</a>的远程桌面技术</li>
<li>基于<a href="https://en.wikipedia.org/wiki/Remote_Desktop_Protocol" target="_blank" rel="noopener noreffer">RDP(Remote Desktop Protocol)</a>的远程桌面技术</li>
</ol>
<h2 id="vnc">VNC</h2>
<p>VNC 使用远程帧缓冲协议即(RFB, Remote FrameBuffer)来远程控制另一台计算机，将控制机的键盘和鼠标事件传输到被控制机，同时将被控制机的屏幕图像传输到控制机。</p>
<p>基于其技术原理，VNC 有以下优点：</p>
<ol>
<li>跨平台，可以在不同的操作系统上运行，VNC 技术本身也有多个客户端和服务端的实现版本，如 RealVNC、TightVNC、UltraVNC 等</li>
<li>开源，VNC 的源代码及其很多现代衍生品都是在 GNU 许可证之下发布的</li>
<li>轻量级，VNC 的客户端和服务端都是非常轻量级的程序，可以在低配置的计算机上运行</li>
</ol>
<p>但因为 VNC 本身的设计时间很早，因此在 2023 年的今天暴露出了很多的时代局限性：</p>
<ol>
<li>因为其基于像素方块的传输原理，就算是采用部分更新传输的方式，在大量像素变化的情况下会消耗大量的带宽。特别是对于现在的高分屏，其传输的数据量会更大。</li>
<li>VNC 在设计之初被用于局域网内使用，因此没有考虑太多的安全性，虽然密码并不以明文发送，但是如果从网络中嗅探出加密密钥和编码之后的密码，也可能成功破解出密码。</li>
</ol>
<h2 id="rdp">RDP</h2>
<p>RDP 是<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/remote/understanding-remote-desktop-protocol" target="_blank" rel="noopener noreffer">微软提出的一种专有协议</a>，扩展了 T-120 系列协议标准，最早专用于 Windows 系统的终端和服务器之间的远程桌面连接，之后微软也实现了<a href="https://learn.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-mac" target="_blank" rel="noopener noreffer">RDP 的 MacOS 客户端</a>，现在也有很多第三方的实现版本实现了其功能的子集，为 GNU/Linux 做了适配如<a href="https://github.com/neutrinolabs/xrdp" target="_blank" rel="noopener noreffer">xrdp</a>。因此，可以说 RDP 也一定程度上具有跨平台的性质。</p>
<p>相比于 VNC，RDP 的实现原理还是比较复杂的：</p>
<p></p>
<p>首先，RDP 的最底层是 TCP，TCP 之上是各层的协议和服务。</p>
<ul>
<li>TPKT：是 TCP 之上的 ISO 传输服务，允许两个组交换 TPDU（传输协议数据单元）或 PDU（协议数据单元）的信息单元。</li>
<li>X.224：连接传输协议，主要用于 RDP 初始连接请求和响应。</li>
<li>T.125 MCS：多点通信服务，允许 RDP 通过多个通道进行通信和管理。</li>
</ul>
<p>RDP 的工作原理是通过 TPKT 实现信息单元的交换，通过 X.224 建立连接，使用 T.125 MCS 打开两个通道来完成两个设备之间的来回数据传输。</p>
<p>RDP 的特点功能比较丰富，比如：</p>
<ul>
<li>支持共享剪切板。</li>
<li>支持多个显示器。</li>
<li>支持虚拟化 GPU。</li>
<li>支持 32 位彩色和 64000 个独立的数据传输通道。</li>
<li>通过 RC4 对称加密算法使用 128 位密钥对数据进行加密。</li>
<li>可以在使用远程计算机时参考本地计算机上的文件系统。</li>
<li>远程计算机的应用程序可以在本地计算机上运行。</li>
</ul>
<p>当然，事物都有两面性，RDP 拥有这么多强大功能，也有一些难以避免的缺点：</p>
<ul>
<li>网络速度较慢时，远程连接容易出现延迟。</li>
<li>两台计算机在不同的网络上时，其配置过程相当复杂。</li>
<li>固定使用 3389 端口监听，可能成为攻击的目标。</li>
<li>RDP 整体上还是受到微软控制，定制性比较差。</li>
</ul>
<h1 id="webrtc-和远程桌面">WebRTC 和远程桌面</h1>
<p>远程桌面的核心需求和 WebRTC 的核心功能完美契合。</p>
<ul>
<li>WebRTC 基于 ICE/STUN/TURN 的 NAT 穿透方案可以很方便地解决不同网络情况下主机连接的问题，</li>
<li>WebRTC 基于 SRTP 的传输方式天然提供了实时特征、端到端的加密的数据传输服务。</li>
<li>WebRTC 针对各种网络情况做了音视频传输的大量优化，可以保证各种网络条件下的可用性。</li>
<li>WebRTC 本身其实是 Chromium 浏览器的一部分，天然具备跨平台的性质。</li>
<li>WebRTC 完全开源，定制性极强，不少公司都基于 WebRTC 来做自家的直播、云游戏业务。</li>
</ul>
<p>整体上来讲，WebRTC 的优势使其很适合用于远程桌面业务，当然，目前市面上已经有 App 基于 WebRTC 实现了远程桌面的功能，比如<a href="https://en.wikipedia.org/wiki/Chrome_Remote_Desktop" target="_blank" rel="noopener noreffer">Chrome Remote Desktop</a>和<a href="https://www.todesk.com/" target="_blank" rel="noopener noreffer">ToDesk</a>。前者可以理解为是 Google 用自己 WebRTC 推出的远程桌面服务，体验了一下，整体上功能比较少，但是连接比较稳定，不过受 GFW 影响，这玩意在国内应该是处于没法用的状态；后者则是国产远程桌面软件，目前已经比较成熟，提供了企业版、个人版、专业版和游戏版四个版本，从其官网上提供的信息来看，应该是做出了一定成绩。</p>
<p>从技术上讲，基于 WebRTC 开发远程桌面应用相当合理，开源可控，还有谷歌背书，WebRTC 本身在不停地与时俱进，作为上层应用开发的远程桌面也可以及时享受到 WebRTC 带来的改进。</p>
<p>从业务上讲，WebRTC 本身具有的功能可以解决上面所说的 VNC 和 RDP 的诸多问题，不过就功能的丰富性而言，可能跟微软的 RDP 还差一些，但是 WebRTC 基于音视频的解决方案本身可以优化的上限还是挺高的，毕竟随着人们需求的上升，高分辨率、高帧率也会成为未来远程桌面应用必不可少的功能需求。</p>
<p>本篇博客从非技术层面探讨了远程桌面技术的当下两大主流技术，以及 WebRTC 应用于远程桌面业务下的可行性。下篇博客将从技术层面详细分析 WebRTC 与远程桌面业务的契合程度及可能的解决方案，就先从核心功能开始吧！</p>
]]></description>
</item>
<item>
    <title>WebRTC 中关于视频自适应的相关设置</title>
    <link>https://ayamir.github.io/posts/knowledge/webrtc/note-for-webrtc-1/</link>
    <pubDate>Thu, 15 Sep 2022 20:48:51 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webrtc/note-for-webrtc-1/</guid>
    <description><![CDATA[<h1 id="概况">概况</h1>
<p><code>WebRTC</code>提供了视频自适应机制，其目的主要是通过降低编码的视频的质量来减少带宽和 CPU 消耗。</p>
<p>视频自适应发生的情形：带宽或 CPU 资源发出信号表明自己未被充分使用或被过度使用时，进行视频自适应。过度使用则降低质量，否则提高质量。</p>
<p>视频自适应调整的对象：帧率与分辨率。</p>
<h1 id="资源">资源</h1>
<p><code>Resources</code>监测指标来自于系统或视频流。例如，一个资源可以监测系统温度或者视频流的带宽使用率。</p>
<p>资源实现了<code>Resource</code>接口：</p>
<ul>
<li>当资源检测到被过度使用则调用<code>SetUsageState(kOveruse)</code>；</li>
<li>当资源不再被过度使用则调用<code>SetUsageState(kUnderuse)</code>。</li>
</ul>
<p>对所有的视频而言，默认有两种类型的资源：</p>
<ul>
<li>质量标量资源</li>
<li>编码过度使用资源</li>
</ul>
<h2 id="qp-标量资源">QP 标量资源</h2>
<p>质量标量资源监测发送视频流中编码之后的帧的量化参数（QP），确保视频流的对于当前的分辨率而言可以接受。</p>
<p>每一帧被编码之后，<code>QualityScaler</code>就能获得相应的 QP。</p>
<p>过度使用或者未被充分使用的信号在平均 QP 脱离 QP 阈值之后发出。</p>
<p>QP 阈值在<code>EncoderInfo</code>中的<code>scaling_settings</code>属性中设置。</p>
<p>需要注意的是 QP 标量只在降级偏好设置为<code>MAINTAIN_FRAMERATE</code>或<code>BALANCED</code>时启用。</p>
<h2 id="编码使用资源">编码使用资源</h2>
<p>编码使用资源监测编码器需要花多长时间来编码一个视频帧，实际上这是 CPU 使用率的代理度量指标。</p>
<p>当平均编码使用超过了设定的阈值，就会触发过度使用的信号。</p>
<h2 id="插入其他资源">插入其他资源</h2>
<p>自定义的资源可以通过<code>Call::AddAdaptationResource</code>方法插入。</p>
<h1 id="自适应">自适应</h1>
<p>资源发出过度使用或未充分使用的信号之后，会发送给<code>ResourceAdaptationProcessor</code>，其从<code>VideoStreamAdapter</code>中请求<code>Adaptation</code>提案。这个提案基于视频的降级偏好设置。</p>
<p><code>ResourceAdaptationProcessor</code>基于获得的提案来确定是否需要执行当前的<code>Adaptation</code>。</p>
<h2 id="降级偏好设置">降级偏好设置</h2>
<p>有 3 种设置，在<code>RtpParameters</code>的头文件中定义：</p>
<ul>
<li><code>MAINTAIN_FRAMERATE</code>: 自适应分辨率</li>
<li><code>MAINTAIN_RESOLUTION</code>: 自适应帧率</li>
<li><code>BALANCED</code>: 自适应帧率或分辨率</li>
</ul>
<p>降级偏好设置在<code>RtpParameters</code>中的<code>degradation_perference</code>属性中设置。</p>
<h1 id="videosinkwants和视频流自适应"><code>VideoSinkWants</code>和视频流自适应</h1>
<p>自适应完成之后就会通知视频流，视频流就会转换自适应为<code>VideoSinkWants</code>。</p>
<p>这些接收器需求向视频流表明：在其被送去编码之前需要施加一些限制。</p>
<p>对于自适应而言需要被设置的属性为：</p>
<ul>
<li><code>target_pixel_count</code>: 对于每个视频帧要求的像素点总数，为了保持原始的长宽比，实际的像素数应该接近这个值，而不一定要精确相等，</li>
<li><code>max_pixel_count</code>: 每个视频帧中像素点的最大数量，不能被超过。</li>
<li><code>max_framerate_fps</code>: 视频的最大帧率，超过这个阈值的帧将会被丢弃。</li>
</ul>
<p><code>VideoSinkWants</code>可以被任何视频源应用，或者根据需要可以直接使用其基类<code>AdaptationVideoTraceSource</code>来执行自适应。</p>
]]></description>
</item>
<item>
    <title>WebGL 样例的解释</title>
    <link>https://ayamir.github.io/posts/knowledge/webgl/webgl-samples-explanation/</link>
    <pubDate>Thu, 03 Mar 2022 10:31:38 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webgl/webgl-samples-explanation/</guid>
    <description><![CDATA[<h1 id="context">Context</h1>
<ol>
<li>Create an <code>HTML5</code> canvas</li>
<li>Get the canvas id</li>
<li>Obtain <code>WebGL</code> Context</li>
</ol>
<p>The parameter <code>WebGLContextAttributes</code> is not mandatory.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Attributes</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>alpha</code></td>
<td style="text-align:center">true: provide an alpha buffer to the canvas;</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><code>depth</code></td>
<td style="text-align:center">true: drawing buffer contains a depth buffer of at least 16 bits;</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><code>stencil</code></td>
<td style="text-align:center">true: drawing buffer contains a stencil buffer of at least 8 bits;</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center"><code>antialias</code></td>
<td style="text-align:center">true: drawing buffer performs anti-aliasing</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><code>premultipliedAlpha</code></td>
<td style="text-align:center">true: drawing buffer contains colors with pre-multiplied alpha</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center"><code>preserveDrawingBuffer</code></td>
<td style="text-align:center">true: buffers will not be cleared and will preserve their values until cleared or overwritten by the author</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;my_canvas&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&#34;webgl&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">antialias</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">stencil</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="geometry">Geometry</h1>
<h2 id="definition">Definition</h2>
<p>A 2D or 3D model drawn using vertices is call a <code>mesh</code>.</p>
<p>Each facet in a mesh is called a polygon and a polygon is made of 3 or more vertices.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// create a 2D triangle which lies on the coordinates {(-5, -5), (5, -5), (5, 5)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span>   <span class="c1">// Vertex 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>   <span class="c1">// Vertex 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>    <span class="c1">// Vertex 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>Similarly, we can create an array for the indices follow the sequence.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>drawArrays()</code>: pass the vertices of the primitive using JavaScript arrays.</li>
<li><code>drawElements()</code>: pass both vertices and indices of the primitive using JavaScript arrays.</li>
</ul>
<h2 id="buffer-objects">Buffer Objects</h2>
<p>A buffer object indicates a memory area allocated in GPU.</p>
<p>We can store data of the models corresponding to vertices, indices, color and etc.</p>
<p>There are 2 types of buffer objects:</p>
<ul>
<li>Vertex Buffer Object(VBO): It holds the per-vertex data of the graphical model that is going to be rendered.</li>
<li>Index Buffer Object(IBO): It holds the indices of the graphical model that is going to be rendered.</li>
</ul>
<p>After defining the required geometry and storing them in JavaScript arrays, we need to pass these arrays to the buffer objects, from where the data will be passed to the shader programs.</p>
<ol>
<li>
<p>Create an empty buffer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertex_buffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">index_buffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Bind an appropriate array object to the empty buffer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">void</span> <span class="nx">bindBuffer</span><span class="p">(</span><span class="kr">enum</span> <span class="nx">target</span><span class="p">,</span> <span class="nb">Object</span> <span class="nx">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ARRAY_BUFFER represents vertex data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertex_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ELEMENT_ARRAY_BUFFER represent index data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">index_buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Pass the data (vertices/indices) to the buffer using one of the typed arrays.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="k">void</span> <span class="nx">bufferData</span><span class="p">(</span><span class="kr">enum</span> <span class="nx">target</span><span class="p">,</span> <span class="nb">Object</span> <span class="nx">data</span><span class="p">,</span> <span class="kr">enum</span> <span class="nx">usage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Usage specifies how to use the buffer object data to draw shapes
</span></span></span><span class="line"><span class="cl"><span class="c1">// gl.STATIC_DRAW -- Data will be specified once and used many times.
</span></span></span><span class="line"><span class="cl"><span class="c1">// gl.STREAM_DRAW -- Data will be specified once and used a few times.
</span></span></span><span class="line"><span class="cl"><span class="c1">// gl.DYNAMIC_DRAW -- Data will be specified repeatedly and used many times.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// vertex buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">(</span><span class="nx">vertices</span><span class="p">),</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// index buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Uint16Array</span><span class="p">(</span><span class="nx">indices</span><span class="p">),</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Unbind the buffer (Optional/Recommended).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h1 id="shader">Shader</h1>
<p>Shaders are written in ES SL which has variables of its own data types, qualifiers, built-in inputs and outputs.</p>
<h2 id="data-types">Data Types</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void</code></td>
<td style="text-align:center">empty value</td>
</tr>
<tr>
<td style="text-align:center"><code>bool</code></td>
<td style="text-align:center">true or false</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">signed integer</td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">floating scalar</td>
</tr>
<tr>
<td style="text-align:center"><code>vec2</code>, <code>vec3</code>, <code>vec4</code></td>
<td style="text-align:center">n-component floating point vector</td>
</tr>
<tr>
<td style="text-align:center"><code>bvec2</code>, <code>bvec3</code>, <code>bvec4</code></td>
<td style="text-align:center">boolean vector</td>
</tr>
<tr>
<td style="text-align:center"><code>ivec2</code>, <code>ivec3</code>, <code>ivec4</code></td>
<td style="text-align:center">signed integer vector</td>
</tr>
<tr>
<td style="text-align:center"><code>mat2</code>, <code>mat3</code>, <code>mat4</code></td>
<td style="text-align:center">2x2, 3x3, 4x4 float matrix</td>
</tr>
<tr>
<td style="text-align:center"><code>sampler2D</code></td>
<td style="text-align:center">access a 2D texture</td>
</tr>
<tr>
<td style="text-align:center"><code>samplerCube</code></td>
<td style="text-align:center">access cube mapped texture</td>
</tr>
</tbody>
</table>
<h2 id="qualifiers">Qualifiers</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Qualifier</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>attribute</code></td>
<td style="text-align:center">acts as a link between a vertex shader and OpenGL ES for per-vertex data. Its value changes for every execution of the vertex shader.</td>
</tr>
<tr>
<td style="text-align:center"><code>uniform</code></td>
<td style="text-align:center">links shader programs and the WebGL application. Its value is <code>read-only</code>. It can be used for to declare a variable with any basic data types: <code>uniform vec4 lightPosition;</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>varying</code></td>
<td style="text-align:center">forms a link between a vertex shader and fragment shader for interpolated data. It can be used with the following data types: <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>vec4</code>, <code>mat2</code>, <code>mat3</code>, <code>mat4</code>, <code>arrays</code> like: <code>varying vec3 normal;</code></td>
</tr>
</tbody>
</table>
<h2 id="vertex-shader">Vertex Shader</h2>
<p>Vertex shader is a program code, which is called on every vertex. Programmer have to define <code>attribute</code> in code of vertex shader to handle data. The <code>attribute</code> point to a VBO written in JavaScript.</p>
<h3 id="predefined-variables">Predefined Variables</h3>
<p>OpenGL ES SL provides the following predefined variables for every vertex shader</p>
<table>
<thead>
<tr>
<th style="text-align:center">Variables</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>highp vec4 gl_Position</code></td>
<td style="text-align:center">Holds the position of the vertex</td>
</tr>
<tr>
<td style="text-align:center"><code>mediump float gl_PointSize</code></td>
<td style="text-align:center">Holds the transformed point size</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">attribute</span> <span class="k">vec2</span> <span class="n">coordinates</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>gl_Position</code> is the predefined variable which is available only in the vertex shader. It contains the vertex position. As vertex shader is a per-vertex operation, the <code>gl_Position</code> value is calculated for each vertex.</p>
<h2 id="fragment-shader">Fragment Shader</h2>
<p>A mesh is formed by multiple triangles, and the surface of each triangle is known as a fragment.</p>
<p>Fragment shader is the code that runs on every pixel on each fragment. This is written to calculate and fill the color on individual pixels.</p>
<h3 id="predefined-variables-1">Predefined Variables</h3>
<table>
<thead>
<tr>
<th style="text-align:center">Variables</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>mediump vec4 gl_FragCoord;</code></td>
<td style="text-align:center">Holds the fragment position within the frame buffer</td>
</tr>
<tr>
<td style="text-align:center"><code>bool gl_FrontFacing;</code></td>
<td style="text-align:center">Holds the fragment that belongs to a front-facing primitive</td>
</tr>
<tr>
<td style="text-align:center"><code>mediump vec2 gl_PointCoord;</code></td>
<td style="text-align:center">Holds the fragment position within a point</td>
</tr>
<tr>
<td style="text-align:center"><code>mediump vec4 gp_FragColor;</code></td>
<td style="text-align:center">Holds the output fragment color value of the shader</td>
</tr>
<tr>
<td style="text-align:center"><code>mediump vec4 gl_FragData[n];</code></td>
<td style="text-align:center">Holds the fragment color for color attachment n</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mo">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="store-and-compiling">Store and Compiling</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertCode</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;attribute vec2 coordinates;&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;void main(void) {&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;gl_Postion = vec4(coordinates, 0.0, 1.0);&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fragCode</span> <span class="o">=</span> <span class="s2">&#34;void main(void) {&#34;</span> <span class="o">+</span> <span class="s2">&#34;gl_FragColor = vec4(0, 0.8, 0, 1);&#34;</span> <span class="o">+</span> <span class="s2">&#34;}&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Compilation involves following 3 steps</p>
<ul>
<li>Creating the shader object</li>
<li>Attaching the source code to the created shader object</li>
<li>Compiling the program</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertShader</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">VERTEX_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="nx">vertShader</span><span class="p">,</span> <span class="nx">vertCode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="nx">vertShader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Same process for fragment shader</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">fragShader</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAGMENT_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="nx">fragShader</span><span class="p">,</span> <span class="nx">fragCode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="nx">fragShader</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="combined-program">Combined Program</h2>
<ul>
<li>Create a program object</li>
<li>Attach both the shaders</li>
<li>Link both the shaders</li>
<li>Use the program</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">shaderProgram</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createProgram</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="nx">vertShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="nx">fragShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">linkProgram</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="associating-attributes--buffer-objects">Associating Attributes &amp; Buffer Objects</h1>
<ul>
<li>Get the attribute location</li>
<li>Point the attributes to a vertex buffer object</li>
<li>Enable the attribute</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// ulong getAttribLocation(Object program, string name)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">coordinatesVar</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="s2">&#34;coordinates&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// void vertexAttribPointer(location, int size, enum type, bool normalized, long stride, long offset)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">coordinatesVar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">coordinatesVar</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="drawing-a-model">Drawing a Model</h1>
<h2 id="drawarrays">drawArrays()</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">void</span> <span class="n">drawArrays</span><span class="p">(</span><span class="k">enum</span> <span class="n">mode</span><span class="p">,</span> <span class="k">int</span> <span class="n">first</span><span class="p">,</span> <span class="k">long</span> <span class="n">count</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>mode: <code>gl.POINTS</code>, <code>gl.LINE_STRIP</code>, <code>gl.LINE_LOOP</code>, <code>gl.LINES</code>, <code>gl.TRIANGLE_STRIP</code>, <code>gl.TRANGLE_FAN</code>, <code>gl.TRIANGLES</code>.</li>
<li>first: specified the starting element in the enabled arrays. (Non-negative)</li>
<li>count: specifies the number of elements to be rendered.</li>
</ul>
<p><code>WebGL</code> will create the geometry in the order in which the vertex coordinates while rendering the shapes.</p>
<p>draw a triangle:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>draw two contiguous triangles:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<h2 id="drawelements">drawElements()</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="k">void</span> <span class="n">drawElements</span><span class="p">(</span><span class="k">enum</span> <span class="n">mode</span><span class="p">,</span> <span class="k">long</span> <span class="n">count</span><span class="p">,</span> <span class="k">enum</span> <span class="n">type</span><span class="p">,</span> <span class="k">long</span> <span class="n">offset</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>mode: same as <code>drawArrays()</code>;</li>
<li>count: same as <code>drawArrays()</code>;</li>
<li>type: specifies the data type of the indices which must be <code>UNSIGNED_BYTE</code> or <code>UNSIGNED_SHORT</code>;</li>
<li>offset: specifies the starting point for rendering, usually the first element (0);</li>
</ul>
<p>If use <code>drawElements()</code> to draw a model, then index buffer object should also be created along with the vertex buffer object. The vertex data will be processed once and used as many time as mentioned in the indices.</p>
<p>draw a triangle:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">drawElements</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="nx">indices</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_SHORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
<p>draw two contagious triangles:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="mf">0.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">gl</span><span class="p">.</span><span class="nx">drawElements</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="nx">indices</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">UNSIGNED_SHORT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p></p>
]]></description>
</item>
<item>
    <title>WebGL 样例</title>
    <link>https://ayamir.github.io/posts/knowledge/webgl/webgl-samples/</link>
    <pubDate>Thu, 03 Mar 2022 10:31:31 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webgl/webgl-samples/</guid>
    <description><![CDATA[<h1 id="structure-of-webgl-application">Structure of WebGL Application</h1>
<p>WebGL application code is a combination of JavaScript and OpenGL Shader Language.</p>
<ul>
<li>JavaScript is required to communicate with the CPU.</li>
<li>OpenGL Shader Language is required to communicate with the GPU.</li>
</ul>
<p></p>
<h1 id="samples">Samples</h1>
<h2 id="2d-coordinates">2D coordinates</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp">&lt;!DOCTYPE html&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">canvas</span> <span class="na">width</span><span class="o">=</span><span class="s">&#34;300&#34;</span> <span class="na">height</span><span class="o">=</span><span class="s">&#34;300&#34;</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;my_canvas&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">canvas</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 1. Prepare the canvas and get context
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;my_canvas&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">gl</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&#34;experimental-webgl&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 2. Define the geometry and store it in buffer objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="mf">0.5</span><span class="p">,</span> <span class="c1">// vertex 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="mf">0.0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Create buffer object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">vertex_buffer</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createBuffer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Bind an empty array buffer to it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertex_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Pass the vertices data to the buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">bufferData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="nx">Float32Array</span><span class="p">(</span><span class="nx">vertices</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gl</span><span class="p">.</span><span class="nx">STATIC_DRAW</span>
</span></span><span class="line"><span class="cl">      <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Unbind the buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 3. Create and compile Shader programs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Vertex shader source code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">vertCode</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;attribute vec2 coordinates;&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;void main(void) {&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34; gl_Position = vec4(coordinates, 0.0, 1.0);&#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Create a vertex shader object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">vertShader</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">VERTEX_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Attach vertex shader source code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="nx">vertShader</span><span class="p">,</span> <span class="nx">vertCode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Compile the vertex shader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="nx">vertShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Fragment shader source code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">fragCode</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;void main(void) {&#34;</span> <span class="o">+</span> <span class="s2">&#34;gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);&#34;</span> <span class="o">+</span> <span class="s2">&#34;}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kd">let</span> <span class="nx">fragShader</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createShader</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">FRAGMENT_SHADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">gl</span><span class="p">.</span><span class="nx">shaderSource</span><span class="p">(</span><span class="nx">fragShader</span><span class="p">,</span> <span class="nx">fragCode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">gl</span><span class="p">.</span><span class="nx">compileShader</span><span class="p">(</span><span class="nx">fragShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Create a shader program object to store combined shader program
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">shaderProgram</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">createProgram</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Attact vertex and fragment shader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="nx">vertShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">gl</span><span class="p">.</span><span class="nx">attachShader</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="nx">fragShader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Link both programs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">linkProgram</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Use the combined shader program object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">useProgram</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 4. Associate the shader programs to buffer objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Bind vertex buffer object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">bindBuffer</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">ARRAY_BUFFER</span><span class="p">,</span> <span class="nx">vertex_buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Get the attribute location
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kd">let</span> <span class="nx">coord</span> <span class="o">=</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">getAttribLocation</span><span class="p">(</span><span class="nx">shaderProgram</span><span class="p">,</span> <span class="s2">&#34;coordinates&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Point an attribute to the currently bound VBO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">vertexAttribPointer</span><span class="p">(</span><span class="nx">coord</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">gl</span><span class="p">.</span><span class="nx">FLOAT</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Enable the attribute
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">enableVertexAttribArray</span><span class="p">(</span><span class="nx">coord</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 5. Drawing the required object (triangle)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Clear the canvas
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Enable the depth test
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">DEPTH_TEST</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Clear the color buffer bit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">clear</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">COLOR_BUFFER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Set the view port
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">viewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Draw the triangle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">gl</span><span class="p">.</span><span class="nx">drawArrays</span><span class="p">(</span><span class="nx">gl</span><span class="p">.</span><span class="nx">TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item>
<item>
    <title>WebGL 中的管线</title>
    <link>https://ayamir.github.io/posts/knowledge/webgl/webgl-pipeline/</link>
    <pubDate>Thu, 03 Mar 2022 10:31:22 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webgl/webgl-pipeline/</guid>
    <description><![CDATA[<h1 id="overview">Overview</h1>
<p></p>
<h1 id="javascript">JavaScript</h1>
<p>JavaScript is used to write the control code of the program, which includes the following actions:</p>
<ul>
<li>Initialization: initialize WebGL context.</li>
<li>Arrays: create arrays to hold the data of the geometry.</li>
<li>Buffer objects: create buffer objects by passing the arrays as parameters.</li>
<li>Shaders: create, compile and link the shaders.</li>
<li>Attributes: create attributes, enable them and associate them with buffer objects.</li>
<li>Uniforms: associate the uniforms.</li>
<li>Transformation matrix: create transformation matrix.</li>
</ul>
<h1 id="vertex-shader">Vertex Shader</h1>
<p>The vertex shader is executed for each vertex provided in the vertex buffer object when start the rendering process by invoking the methods <code>drawElements()</code> and <code>drawArrays()</code>.</p>
<ul>
<li>
<p>It calculates the position of each vertex of a primitive polygon and stores it in the varying <code>gl_position</code></p>
</li>
<li>
<p>It calculates the other attributes such as color, texture coordinates and vertices that are normally associated with a vertex.</p>
</li>
</ul>
<h1 id="primitive-assembly">Primitive Assembly</h1>
<p>Here the triangles are assembled and passed to the rasterizer.</p>
<h1 id="resterization">Resterization</h1>
<p>The pixels in the final image of the primitive are determined.</p>
<ul>
<li>Culling: Initially the orientation of the polygons is determined. All those triangles with improper orientation that are not visible in view area are discarded.</li>
<li>Clipping: If a triangle is partly outside the view area, then the part outside the view area is removed.</li>
</ul>
<h1 id="fragment-shader">Fragment Shader</h1>
<p>The fragment shader gets:</p>
<ul>
<li>
<p>data from the vertex shader in varying variables</p>
</li>
<li>
<p>primitives from the rasterization stage</p>
</li>
</ul>
<p>then:</p>
<ul>
<li>calculates the color value for each pixel between the vertices</li>
<li>stores the color values of every pixel in each fragment</li>
</ul>
<h1 id="fragment-operations">Fragment Operations</h1>
<p>The fragment operations may include:</p>
<ul>
<li>Depth</li>
<li>Color buffer blend</li>
<li>Dithering</li>
</ul>
<p>Once all the fragments are processed, a 2D image is formed and displayed on the screen.</p>
<h1 id="frame-buffer">Frame Buffer</h1>
<p>Frame buffer is the final destination of the rendering pipeline.</p>
<p>Frame buffer is a portion of graphics memory that hold the scene data.</p>
<p>This buffer contains details such as width and height of the surface (in pixels), color of each pixel and depth and stencil buffers.</p>
<p></p>
]]></description>
</item>
<item>
    <title>WebGL 基础知识</title>
    <link>https://ayamir.github.io/posts/knowledge/webgl/webgl-basics/</link>
    <pubDate>Thu, 03 Mar 2022 10:31:04 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/webgl/webgl-basics/</guid>
    <description><![CDATA[<h1 id="coordinate-system">Coordinate System</h1>
<p>There are x, y, z axes in WebGL, where the z axis signifies <strong>depth</strong>.
The coordinates in WebGL are restricted to (1, 1, 1) and (-1, -1, -1).
Positive value meaning:
z: near viewer.
x: near right.
y: near top.</p>
<p></p>
<h1 id="graphics-system">Graphics System</h1>
<h2 id="vertices">Vertices</h2>
<p>To draw a polygon, we need to mark the points on the plane and join them to form a desired polygon.
A <code>vertex</code> is a point which defines the conjunction of the edges of a 3D object.
Use <code>javascript</code> arrays to stores points&rsquo; coordinates like <code>[0.5, 0.5, 0.5]</code>.</p>
<h2 id="indices">Indices</h2>
<p>The numerical values which are used to identify the vertices is call <code>Indices</code>.</p>
<h2 id="arrays">Arrays</h2>
<p>There are no predefined methods in WebGL to render the vertices directly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="buffers">Buffers</h2>
<p>Buffers are the memory areas of WebGL that hold the data.
There are various buffers:</p>
<ul>
<li><code>drawing buffer</code></li>
<li><code>frame buffer</code></li>
<li><code>vertex buffer</code></li>
<li><code>index buffer</code></li>
</ul>
<p>The <code>vertex buffer</code> and <code>index buffer</code> are used to describe and process the geometry of the model, stores data about <code>vertices</code> and <code>indices</code> respectively.</p>
<p>The <code>frame buffer</code> is a portion of graphics memory that hold the scene data. This buffer contains details such as width and height of the surface (in pixels), color of each pixel, depth and stencil buffers.</p>
<h2 id="mesh">Mesh</h2>
<p>The WebGL API provides two methods to draw 2D or 3D objects:</p>
<ul>
<li><code>drawArrays()</code></li>
<li><code>drawElements()</code></li>
</ul>
<p>They accept a parameter called <code>mode</code> using which you can select the object you want to draw.</p>
<p><code>mode</code>: <code>points</code> or <code>lines</code> or <code>triangles</code></p>
<p>We can construct primitive polygons using points, lines and triangles.</p>
<p>Thereafter, we can form a <code>mesh</code> using these polygons.</p>
<p>A 3D object drawn using primitive polygons is called a <code>mesh</code>.</p>
<h2 id="shader-programs">Shader Programs</h2>
<p>Since WebGL uses GPU accelerated computing, the information about these triangles should be transferred from CPU to GPU which takes a lot of communication overhead.</p>
<p>WebGL provides a solution to reduce the communication overhead. Since it uses ES SL(Embedded System Shader Language) that runs on GPU, we write all the required programs to draw graphical elements on the client system using shader programs(OpenGL ES Shader Language).</p>
<p>Shader is a snippet that implements algorithms to get pixels for a mesh.</p>
<p>There are two types of shaders: <code>Vertex Shader</code> and <code>Fragment Shader</code>.</p>
<h3 id="vertex-shader">Vertex Shader</h3>
<ul>
<li>called on every vertex.</li>
<li>used to transform the geometry from one place to another.</li>
<li>handle the data of each vertex such as vertex coordinates, normals, colors, and texture coordinates.
<ul>
<li>vertex transformation</li>
<li>normal transformation and normalization</li>
<li>texture coordinate generation</li>
<li>texture coordinate transformation</li>
<li>lighting</li>
<li>color material application</li>
</ul>
</li>
</ul>
<h3 id="fragment-shaderpixel-shader">Fragment Shader(Pixel Shader)</h3>
<p>A mesh is formed by multiple triangles. The surface of each of the triangles is known as a fragment.</p>
<p><code>Fragment shader</code> is the code that runs on all pixels of every fragment.</p>
<p>It is written to calculate and fill the color on <em>individual pixels</em>.</p>
<ul>
<li>operations on interpolated values</li>
<li>texture access</li>
<li>texture application</li>
<li>fog</li>
<li>color sum</li>
</ul>
<p></p>
<h2 id="opengl-es-sl-variables">OpenGL ES SL Variables</h2>
<p>To handle the data in the shader programs, ES SL provides three types of variables.</p>
<ul>
<li>
<p>Attributes: hold the input values of the vertex shader program. Attributes point to the vertex buffer objects that contains per-vertex data.</p>
</li>
<li>
<p>Uniforms: hold the input data that is common for both vertex and fragment shaders, such as light position, texture coordinates and color.</p>
</li>
<li>
<p>Varyings: used to pass the data from the vertex shader to the fragment shader.</p>
</li>
</ul>
]]></description>
</item>
<item>
    <title>VR 和 全景视频的区别总结</title>
    <link>https://ayamir.github.io/posts/knowledge/360video/summary-for-vr-and-panoramic-video/</link>
    <pubDate>Mon, 17 Jan 2022 17:02:51 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/360video/summary-for-vr-and-panoramic-video/</guid>
    <description><![CDATA[<p>VR 和 360 度全景视频都是获得沉浸式体验的重要途径，除此之外，AR（Argmented Reality）和 MR（Mixed Reality）也是比较火的概念，可以用来对比学习。</p>
<h2 id="全景视频">全景视频</h2>
<ol>
<li>全景视频实际上事先通过特殊的全景摄像机录制好视频，之后可以在<code>HMD</code>中观看。虽然看到的图像相对于用户当前环境而言是虚拟的，但是终归是从实际环境中录制而来的，本质上更贴近普通视频的全景推广。</li>
<li>在全景视频的观看过程中，用户只有 3DoF 的自由度，即只能完成头部的 3 个角度的运动，同时手柄实际上并不能和视频中的内容进行交互。</li>
<li>全景视频的主要应用在于实景导览，通过事先由拍摄者带着全景录像设备行走拍摄，用户观看时实际是将自己带入到全景设备的位置上，同时移动头部来观察不同角度的视频。</li>
</ol>
<h2 id="vr">VR</h2>
<ol>
<li>VR 主要做的工作是创造出一个完全虚拟的环境，用户戴上<code>HMD</code>之后可以通过其看到虚拟环境中的事物，同时也可以使用<code>HMD</code>配套的手柄等设备进行操作，完成与虚拟环境之间的交互；</li>
<li>VR 支持的是 6DoF 的自由度，即除了头部的运动之外也支持身体的前后、左右、上下的移动，手柄；</li>
<li>VR 的主要应用在于游戏，比如广受好评的<code>Beat Saber</code>（又称<a href="https://zh.wikipedia.org/zh-cn/%E8%8A%82%E5%A5%8F%E5%85%89%E5%89%91" target="_blank" rel="noopener noreffer"><code>节奏光剑</code></a>），用户根据音乐节奏通过挥动手柄（在虚拟环境中被建模成光剑）来准确地按照提示的方向去砍击方块；</li>
</ol>
<h2 id="ar-和-mr">AR 和 MR</h2>
<ol>
<li>
<p>AR 主要做的工作是将虚拟世界中的事物投影到现实世界中，主体是现实世界，虚拟事物用于增强现实世界。</p>
<p>MR 主要做的工作是将现实世界中的事物虚拟化进入虚拟世界中，主体是虚拟世界，现实事物混合进虚拟世界中。</p>
</li>
<li>
<p>AR 实现起来比较简单，只需要将计算机产生的图像投影显示在现实中即可，目前的应用比如游戏<code>Pokémon GO</code>里面的<code>AR-mode</code>，启用之后游戏中遇到的<code>Pokémon</code>就可以投影在现实中。</p>
<p>MR 实现起来比较复杂，首先需要用摄像头扫描物体，得到的 2D 图像再交给计算机采用算法进行 3D 重建，最后将虚拟化建模好的物体展示到虚拟世界中，目前的应用比如<code>Meta</code>推出的<code>Workrooms</code>，线上的远距离视频会议在虚拟世界中可以变成虚拟人物之间面对面的交流。</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<ol>
<li>
<p>全景视频侧重于对虚拟环境的观察，而 VR 侧重于对虚拟环境的交互。</p>
</li>
<li>
<p>全景视频实际上是将用户带入到全景摄像机的位置上，让用户产生自己身临拍摄的环境中的感觉，本质上是对传统视频的推广；</p>
<p>VR 实际上是将用户完全带入到虚拟的环境中，用户可以和虚拟环境中的事物进行交互，而虚拟环境中发生的一切都和现实无关，本质上是对传统游戏的推广；</p>
</li>
<li>
<p>全景视频实际上和 VR、AR、MR 这种概念距离比较远，实际上只是因为全景摄像机相较于普通摄像机的 360 度视角的特殊性，这能让用户产生沉浸感。</p>
</li>
<li>
<p>VR 相比于 AR、MR 而言，是纯粹的虚拟环境，并不涉及到现实事物（除了<code>HMD</code>配套的手柄等设备），而纯粹的虚拟环境将人带入到了一个完全不同的世界，也是 VR 沉浸式体验的来源。</p>
</li>
<li>
<p>AR 和 MR 是虚拟和现实交融的技术，前者主体是现实，后者主体是虚拟环境。</p>
</li>
</ol>
<p></p>
]]></description>
</item>
<item>
    <title>全景视频中视口预测相关方法总结</title>
    <link>https://ayamir.github.io/posts/knowledge/360video/summary-for-vp/</link>
    <pubDate>Fri, 07 Jan 2022 23:08:36 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/360video/summary-for-vp/</guid>
    <description><![CDATA[<h2 id="视口预测是什么">视口预测是什么？</h2>
<p>视口预测 (Viewport Predict) 是全景视频中特有的一种用于进一步优化码率自适应的方式。</p>
<p>相较于全景视频 360 度无死角的特性，用户实际上能看到的内容其实只是全景视频中的一个小窗口，这个小窗口就是视口 (Viewport) 。</p>
<p>因为用户在观看全景视频时会在 3DoF 的自由度下转动头部去观看全景视频在空间上的不同部分，所以视口预测做的事情就是在用户的观看过程中预测相较于预测执行时刻的下一时刻的视口位置。</p>
<h2 id="vp-在传输中所处的作用">VP 在传输中所处的作用</h2>
<p>基于 tile 的全景视频传输方式之所以热门，就是因其可以通过只传输用户 FoV 内的分块而大幅减少观看过程中消耗的带宽。</p>
<p>所以对用户 FoV 的预测是首先要处理的因素，如果 VP 精度很高，那么所有的带宽都可以用很高的码率去传输 FoV 内的分块。</p>
<h2 id="两种方式的基本假设">两种方式的基本假设</h2>
<ul>
<li>
<p>基于轨迹的方法的基本假设</p>
<p>相对于当前时刻，前 $hw$ (history window)内用户的 FoV 位置对未来可预测的 $pw$ (predict window)内用户的 FoV 位置有影响，比如用户只有很小可能性会在很短的一段单位时间内做 180 度的转弯，而更小角度的调整则更可能发生。</p>
</li>
<li>
<p>基于内容的方法的基本假设</p>
<p>用户的 FoV 变化是因为对视频内容感兴趣，即 ROI 与 FoV 之间有相关关系，比如在观看篮球比赛这样的全景视频时，用户的 FoV 更可能专注于篮球。</p>
<p>按照提取 ROI 的来源不同可以分为两种类型：</p>
<ol>
<li>从视频内容本身出发，使用 CV 方法去猜测 ROI；</li>
<li>从用户观看视频的热图出发，相当于得到了经过统计之后的平均 FoV 分布，以此推测其他用户的 ROI；</li>
</ol>
</li>
</ul>
<p>基于轨迹的方式是要在最表层的历史和预测的轨迹之间学习，即假设两者之间只有时空关系。</p>
<p>跨用户的方式则假设由用户群体所得出的热图可以用来预测单个用户的 FoV，即利用共性来推断个性。</p>
<p>基于内容的方式直接提取视频显著图来推断 FoV，即进一步假设共性与视频内容本身有关系。</p>
<h2 id="跨用户预测的概念">跨用户预测的概念</h2>
<ul>
<li>
<p>基本假设</p>
<p>就单个用户而言，在观看视频过程中其 FoV 的变化看似随机，但是其行为可能从用户群体的角度去看是跨用户相通的，即多个用户在观看视频时可能会表现出相似的，可以学习的行为模式，这种行为模式可以帮助提高 VP 的精度。</p>
</li>
<li>
<p>实际应用</p>
<p>基于轨迹的跨用户：如果训练的模型是基于轨迹的离线模型如 LSTM，那么实际上训练好的模型已经学习到了这种跨用户的行为模式；而如果采用的是边训练边预测的模型如 LR（输入历史窗口的经纬度数据，输出预测窗口的经纬度数据），那么这样的模型就是纯粹的单用户模型。</p>
<p>基于内容的跨用户：将用户在观看视频帧时的注意点作为研究对象，找到用户群体在面对同一帧视频时共同关注的空间区域，而这就是用户间相似的行为模式。这种与内容相结合的跨用户方式即为实际研究中所指的跨用户的研究方式。（实际上就是基于内容的研究方法，只不过出发点不是视频本身，而是用户在观看视频时的 FoV）</p>
</li>
</ul>
<h2 id="实际应用">实际应用</h2>
<p></p>
<ul>
<li>
<p>图中 3 个黄色矩形表示 3 种方法：</p>
<ol>
<li>
<p>ROI extract：基于内容的预测</p>
</li>
<li>
<p>Multiple watchers&rsquo; FoV：跨用户的预测</p>
</li>
<li>
<p>Multiple watchers&rsquo; trajectories：基于轨迹的预测</p>
</li>
</ol>
</li>
<li>
<p>绿色渐变矩形表示直接使用用户当前的历史轨迹数据去训练模型，接着做出预测。</p>
</li>
</ul>
<h2 id="研究方法">研究方法</h2>
<ul>
<li>
<p>基于轨迹的方法</p>
<p>在线训练：输入历史窗口的位置信息，不断迭代修正模型，输出预测窗口的位置信息。</p>
<p>离线训练：输入任何采样条件下的多对 hw 和 pw 信息来拟合模型。</p>
</li>
<li>
<p>跨用户的方法</p>
<p>求出多个用户在同一帧上的热图，以此作为 FoV 预测的依据。</p>
</li>
<li>
<p>基于内容的方法</p>
<p>提取视频帧中的显著图，以此作为 FoV 预测的依据。</p>
</li>
</ul>
<h2 id="优点">优点</h2>
<ol>
<li>使用回归实现的在线训练模型实现简单，反应迅速，有优秀的短期预测精度。</li>
<li>因为独立于 $pw$ ，并且不需要历史窗口 $hw$ 的轨迹输入，跨用户的热图可以帮助长期的预测，可以提供合理的离线全视频 FOV 预测，并具有一致的性能。</li>
<li>显著图对于 ROI 集中突出的预测效果较好。</li>
</ol>
<h2 id="缺点">缺点</h2>
<ol>
<li>使用回归实现的在线训练模型在预测窗口增大时，性能会显著下降。</li>
<li>提取显著图的方式一方面训练开销比较大，另一方面对于 ROI 不够集中突出的视频效果并不好。</li>
</ol>
]]></description>
</item>
<item>
    <title>多媒体基础知识</title>
    <link>https://ayamir.github.io/posts/knowledge/mm-base/</link>
    <pubDate>Mon, 13 Dec 2021 10:03:17 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/mm-base/</guid>
    <description><![CDATA[<h1 id="媒体处理过程">媒体处理过程</h1>
<p></p>
<h2 id="解协议">解协议</h2>
<p>将流媒体传输方案中要求的数据解析为标准的相应封装格式数据。</p>
<p>音视频在网络中传播时需要遵守对应的传输方案所要求的格式，如 DASH、HLS 将媒体内容分解成一系列小片段，每个片段有不同的备用码率版本。</p>
<p>同时应用层的协议会要求在媒体文件本身之外，传输信令数据（如对播放的控制或网络状态的描述）</p>
<p>解协议的过程会去除信令数据并保留音视频内容，需要的话还要对视频段进行拼接，最终将其还原成传输之前的媒体格式如 MP4，FLV 等。</p>
<h2 id="封装格式">封装格式</h2>
<p>封装格式如 AVI、MPEG、Real Video 将音频和视频组合打包成一个完整的文件.</p>
<p>封装格式不会影响视频的画质，影响画质的是视频的编码格式。</p>
<p>解封装过程就是将打包好的封装格式分离成某种编码的音频压缩文件和视频压缩文件，有时也包含字幕和脚本。</p>
<p>比如 FLV 或 TS 格式数据，解封装之后得到 H.264-AVC 编码的视频码流和 AAC 编码的音频码流。</p>
<h2 id="编码">编码</h2>
<p>视频的本质是一帧又一帧的图片。</p>
<p>所以对于一部每秒 30 帧，90 分钟，分辨率为 1920x1080，24 位的真彩色的视频，在压缩之前的大小$S$满足：</p>
<p>$$
一帧大小s = 1920 * 1080 * 24 = 49766400(bit) = 6220800(Byte)
\
总帧数n = 90 * 60 * 30 = 162000
\
总大小S = s * n = 6220800 * 162000 = 1.0077696*10^{12}(Byte) \approx 939(GB)
$$</p>
<p>因为未经压缩的视频体积过于庞大，所以需要对其进行压缩，而压缩就是通常所说的编码。</p>
<p>视频编码方式：H.264-AVC，H.265-HEVC，H.266-VVC</p>
<p>音频编码方式：MP3，AAC</p>
<p>压缩比越大，解压还原之后播放的视频越失真，因为压缩过程中不可避免地丢失了视频中原有图像的数据信息。</p>
<h2 id="解码">解码</h2>
<p>解码就是解压缩过程。</p>
<p>解码之后能够得到系统音频驱动和视频驱动能识别的音频采样数据（如 PCM 数据）和视频像素数据（如 YUV420，RGB 数据）。</p>
<h2 id="音视频同步">音视频同步</h2>
<p>根据时间，帧率和采样率采用一定的算法，同步解码出来的音频和视频数据，将其分别送至声卡和显卡播放。</p>
<h1 id="视频质量指标">视频质量指标</h1>
<h2 id="分辨率">分辨率</h2>
<ul>
<li>
<p>分辨率指的是视频图像在一个单位尺寸内的精密度。</p>
</li>
<li>
<p>将视频放大足够大的倍数之后就能看到组成影像的基本单元：像素。</p>
</li>
<li>
<p>视频的分辨率从数值上描述了像素点的个数，如 1920x1080：视频在水平方向有 1920 个像素，垂直方向有 1080 个像素。</p>
</li>
<li>
<p>常见的描述方式：</p>
<ul>
<li>1080P：指视频有<strong>1080 行</strong>像素，P=&gt;Progressive（逐行扫描）</li>
<li>2K：指视频有<strong>2000 列</strong>像素</li>
<li>MP：像素总数，指像素的行数 P 与列数 K 乘积的结果（百万像素）</li>
<li>1080P 的分辨率为 1920x1080=2073600，所以 1080P 通常也称为 200 万像素分辨率</li>
</ul>
</li>
<li>
<p>通常视频在同样大小的情况下，分辨率越高，所包含的像素点越多，画面就越细腻清晰</p>
</li>
<li>
<p>参考链接：</p>
<ul>
<li><a href="https://www.reneelab.com.cn/m/2k-4k-video-resolution.html" target="_blank" rel="noopener noreffer">科普：视频分辨率是什么？</a></li>
<li><a href="https://www.zhihu.com/question/24205632/answer/648608086" target="_blank" rel="noopener noreffer">「1080p」和「2k、4k」的关系与差别在哪里？</a></li>
</ul>
</li>
</ul>
<h2 id="视频帧率">视频帧率</h2>
<ul>
<li>
<p>帧率的单位 FPS(Frame Per Second)或 Hz，即每秒多少帧，决定视频画面的流畅程度。</p>
</li>
<li>
<p>低帧率会导致播放卡顿，镜头移动不顺畅，并伴随画面模糊的主观体验；</p>
<p>帧率过高则会造成眩晕的感觉。</p>
</li>
<li>
<p>不同帧率的视频在支持不同帧率的设备上播放：</p>
<ol>
<li>
<p>若设备最高支持 60fps，则播放 120fps 视频的时候，设备会每隔一帧删除一帧，被删除的帧即成为无效帧。</p>
<p>所以高帧率的视频在低帧率设备上播放时会导致播放卡顿。</p>
</li>
<li>
<p>若设备最高支持 120fps，则播放 60fps 视频的时候，设备会每隔一帧复制一帧，来填补空缺的帧位置。</p>
<p>但是效果和在 60fps 上的设备播放一样，不能提升播放流畅度。</p>
</li>
</ol>
</li>
<li>
<p>关于显卡对帧率的影像：</p>
<ol>
<li>显示器帧率低而显卡输出帧率高时，会导致<a href="https://zh.wikipedia.org/wiki/%E7%95%AB%E9%9D%A2%E6%92%95%E8%A3%82" target="_blank" rel="noopener noreffer">画面撕裂</a>：显示器同时将两帧或几帧显示在同一个画面上</li>
<li>显示器帧率高而显卡输出帧率低时，同视频帧率高显示器帧率低的情况。</li>
</ol>
</li>
</ul>
<h2 id="视频码率">视频码率</h2>
<ul>
<li>
<p>码率的概念出现在视频编码之后，因为压缩之后的视频已经成为二进制数据，所以使用码率的称呼。</p>
</li>
<li>
<p>码率的单位是 bps(bit per second)，即每秒多少比特。</p>
</li>
<li>
<p>与视频质量的关系：</p>
<ol>
<li>
<p>分辨率不变的情况下，码率越大，压缩比越好，画面质量越清晰。</p>
<p>码率越高，精度越高，处理出的文件就越接近压缩前的原始状态，每一帧的图像质量越高，画质越清晰，当然对播放设备的解码能力要求也越高。</p>
<p>压缩比越小，视频体积越大，越接近源文件。</p>
</li>
</ol>
</li>
</ul>
<p></p>
]]></description>
</item>
<item>
    <title>重学C&#43;&#43;：容器和迭代器</title>
    <link>https://ayamir.github.io/posts/knowledge/cpp/iterator/</link>
    <pubDate>Thu, 28 Oct 2021 17:09:18 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/cpp/iterator/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。</p>
</li>
<li>
<p><code>string</code>虽然不是容器，但是支持很多容器的操作。</p>
</li>
<li>
<p>容器不为空时：<code>begin()</code>返回的是容器中第一个元素的位置；<code>end()</code>返回的是容器中最后一个元素的<strong>后一个位置</strong>。</p>
<p>容器为空时：<code>begin()</code>和<code>end()</code>返回的都是最后一个元素的<strong>后一个位置</strong>。</p>
</li>
<li>
<p>任何可能改变容器大小的操作都会使容器的迭代器失效。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>和指针类似的是，迭代器支持对对象的间接访问。</p>
</li>
<li>
<p>和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如<code>begin()</code>, <code>end()</code>。</p>
</li>
<li>
<p>所有迭代器都支持的运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center"><code>*iter</code></td>
<td style="text-align:center">返回迭代器<code>iter</code>指向元素的<strong>引用</strong></td>
</tr>
<tr>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center"><code>iter-&gt;mem</code></td>
<td style="text-align:center">解引用<code>iter</code>并获取该元素名为<code>mem</code>的成员，即<code>(*iter).mem</code></td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center"><code>++iter</code></td>
<td style="text-align:center">令<code>iter</code>指向当前元素的后一个元素</td>
</tr>
<tr>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center"><code>--iter</code></td>
<td style="text-align:center">令<code>iter</code>指向当前元素的前一个元素</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center"><code>iter1 == iter2</code></td>
<td style="text-align:center">如果两个迭代器指向相同的元素返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center"><code>iter1 != iter2</code></td>
<td style="text-align:center">上面例子的反面</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>迭代器的类型有两种：<code>iterator</code>和<code>const_iterator</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itv</span><span class="p">;</span>          <span class="c1">// 可用于读写vector&lt;int&gt;中的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">its</span><span class="p">;</span>               <span class="c1">// 可用于读写string对象中的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">citv</span><span class="p">;</span>   <span class="c1">// 只能读取元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">cits</span><span class="p">;</span>        <span class="c1">// 只能读取元素
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>begin()</code>和<code>end()</code>返回哪一种取决于对象本身是否被<code>const</code>修饰。</p>
<p>C++11 中引入了<code>cbegin()</code>和<code>cend()</code>来专门返回<code>const_iterator</code>。</p>
</li>
<li>
<p>认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。</p>
</li>
<li>
<p><code>vector</code>和<code>string</code>的迭代器支持的<strong>额外的</strong>运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>iter + n</code></td>
<td style="text-align:center">运算得到一个新迭代器，指向当前元素的后 n 个元素的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>iter - n</code></td>
<td style="text-align:center">运算得到一个新迭代器，指向当前元素的前 n 个元素的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>iter += n</code></td>
<td style="text-align:center">运算得到的新迭代器赋值给<code>iter</code></td>
</tr>
<tr>
<td style="text-align:center"><code>iter -= n</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>iter1 - iter2</code></td>
<td style="text-align:center">两个迭代器之间的距离，可正可负</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td style="text-align:center">同两类型的下标运算符中的数字的关系，位置靠前的较小</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>一般不在意迭代器的类型，因此使用<code>auto</code>来标注。</li>
<li>循环结束的判断条件习惯使用迭代器和<code>!=</code>，这样可以不用在意容器类型。</li>
<li>凡是使用了迭代器的循环体中都不能有改变容器大小的操作如<code>push_back()</code>。</li>
</ol>
]]></description>
</item>
<item>
    <title>重学C&#43;&#43;：标准库类模板Vector</title>
    <link>https://ayamir.github.io/posts/knowledge/cpp/vector/</link>
    <pubDate>Thu, 28 Oct 2021 15:35:17 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/cpp/vector/</guid>
    <description><![CDATA[<h2 id="常见的坑与用法">常见的坑与用法</h2>
<ol>
<li>
<p><code>vector</code>的默认初始化是否合法取决于<code>vector</code>内对象所属的类是否要求显式初始化。</p>
</li>
<li>
<p>使用<code>()</code>和<code>{}</code>对<code>vector</code>执行初始化含义不同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>    <span class="c1">// 存储1个int对象，值为10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">// 存储10个int对象，值为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 存储10个int对象，值都是1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// 存储2个int对象，值分别是10和1
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用<code>{}</code>执行列表初始化时按照顺序遵守 2 个守则：</p>
<ol>
<li>
<p>如果<code>{}</code>内容可以用于初始化，则采用<code>{}</code>默认的初始化含义。</p>
</li>
<li>
<p>如果<code>{}</code>中的内容无法用<code>{}</code>默认的初始化含义做出解释，则会按照<code>()</code>的初始化含义去解释<code>{}</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="s">&#34;hi&#34;</span><span class="p">};</span>      <span class="c1">// 存储1个值为hi的string对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>        <span class="c1">// 存储10个值为空的string对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">};</span>  <span class="c1">// 存储10个值为hi的string对象
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p>与<code>string</code>相同，<code>vector</code>也有<code>size_type</code>作为其<code>size()</code>的返回值类型。</p>
<p>但是使用时必须首先指定<code>vector</code>由哪个类型定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 正确
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">::</span><span class="n">size_type</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 错误
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>只有<code>vector</code>内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。</p>
</li>
<li>
<p>增加<code>vector</code>中的元素只能使用<code>push_back()</code> or <code>emplace_back()</code>，而不能使用对下标赋值的方式。</p>
<p><code>push_back()</code> 和 <code>emplace_back()</code> 的区别来自于两者的函数签名不同：</p>
<ul>
<li><code>emplace_back()</code> 支持通过传入参数在 <code>vector</code> 内部原地构造对象，因而只会调用构造函数 1 次；</li>
<li><code>push_back()</code> 不支持，所以至少会调用 2 次构造函数和 1 次析构函数（临时对象的构造函数和析构函数、<code>vector</code> 内对象的拷贝或移动构造函数）；</li>
<li>两者都支持传入右值引用作为参数，因而可以使用 <code>push_back(std::move(obj))</code> or <code>emplace_back(std::move(obj))</code> 来避免对象拷贝操作，从而改善性能。</li>
</ul>
</li>
<li>
<p>可以使用 <code>vector</code> 来模拟 <code>stack</code> 的行为：</p>
<ul>
<li><code>stack.pop()</code> &lt;=&gt; <code>vector.pop_back()</code></li>
<li><code>stack.top()</code> &lt;=&gt; <code>vector.back()</code></li>
<li><code>stack.push()</code> &lt;=&gt; <code>vector.push_back()</code> or <code>vector.emplace_back()</code></li>
</ul>
</li>
<li>
<p><code>vector</code> 在达到容量上限时会触发扩容操作，<code>GCC</code> 的扩容倍数是 2 ，<code>MSVC</code> 的是 1.5.</p>
<ul>
<li>
<p>为什么使用倍数扩容而不是等长扩容？</p>
<p>因为倍数扩容的单次操作平均时间复杂度是 <code>O(1)</code> （等比数列求和后平均，与扩容倍数相关）。</p>
<p>等长扩容的是<code>O(n)</code> （等差数列求和后平均，与扩容次数相关）。</p>
</li>
<li>
<p>为什么使用 1.5 倍或 2 倍而不使用 3 倍、4 倍？</p>
<p>因为扩容的本质其实就是申请新内存空间、拷贝元素、释放旧内存空间。</p>
<p>一个直观的想法是新申请内存空间时可以重复利用旧内存空间。</p>
<ul>
<li>
<p>对于 2 倍扩容的情况：<code>1 2 4 8 16 32 ...</code>，<code>1+2&lt;4, 1+2+4&lt;8, 1+2+4+8&lt;16</code>，这种情况下之前释放的内存空间无法满足扩容的需求。</p>
</li>
<li>
<p>对于 1.5 倍扩容的情况：<code>1 2 3 4 6 9 13 ...</code>，<code>1+2&gt;=3, 2+3&gt;=4, 4+6&gt;=9, 6+9&gt;=13</code>，这种情况下旧的内存空间可以满足扩容需求，因而存在内存重复利用的可能性。</p>
<p>所以 1.5 倍扩容可以更好的实现对内存的重复利用。</p>
<p>理论最优扩容满足的条件是 <code>f(n-1)+f(n-2)=f(n)</code> 即斐波那契数列，最优扩容因子通过极限可以求出为<strong>黄金分割率</strong>：1.618.</p>
</li>
</ul>
</li>
<li>
<p>Linux 为什么使用 2 倍扩容？</p>
<p>Linux 下主要使用 glibc 的 ptmalloc 来进行用户空间申请的，如果 malloc 的空间小于 128KB，其内部通过 brk()来扩张，如果大于 128KB，通过 mmap 将内存映射到进程地址空间。</p>
<p>Linux 引入了伙伴系统为内核提供了一种用于分配连续的页而建立的一种高效的分配策略，对固定分区和动态分区方式的折中。固定分区存在内部碎片，动态分区存在外部碎片，而且动态分区回收时的合并以及分配时的切片是比较耗时的。伙伴系统是将整个内存区域构建成基本大小 basicSize 的 1 倍、2 倍、4 倍、8 倍、16 倍等，即要求内存空间分区链均对应 2 的整次幂倍大小的空间，整齐划一，有规律的而不是乱糟糟的。</p>
<p>在分配和释放空间时，可以通过 log2(request/basicSize)向上取整的哈希算法快速找到对应内存块。通过伙伴系统管理空闲分区的了解，可以看到在伙伴系统中的每条空闲分区链中挂的都是 2^i 的页面大小，通过哈希思想进行空间分配与合并，非常高效。估计可能是这个原因 SGI-STL 选择以 2 倍方式进行扩容。</p>
</li>
</ul>
</li>
</ol>
<h2 id="必须理解的点">必须理解的点</h2>
<ol>
<li><code>vector</code>是类模板而非类型。</li>
<li><code>vector</code>中只能容纳对象，不能容纳引用。</li>
<li><code>vector</code>对象能高效增长，增加<code>vector</code>中的元素需要使用 <code>push_back()</code> 或 <code>emplace_back()</code> 成员函数。</li>
<li><code>vector</code>的成员函数（<code>empty()</code>, <code>size()</code>）和各种运算符（赋值、关系、下标）的操作使用方法和规则基本同<code>string</code>。</li>
</ol>
<h2 id="note">NOTE</h2>
<ol>
<li>不需要在创建<code>vector</code>时确定其中的元素及其大小，但是如果在创建时就已经知道容器中需要容纳的元素个数就可以直接指定<code>vector</code>的大小。</li>
<li>在循环体内部包含向<code>vector</code>对象添加元素的操作时，不应该使用<code>foreach</code>循环。</li>
</ol>
]]></description>
</item>
<item>
    <title>重学C&#43;&#43;：标准库类型string</title>
    <link>https://ayamir.github.io/posts/knowledge/cpp/string/</link>
    <pubDate>Thu, 28 Oct 2021 10:31:33 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/cpp/string/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>string.size()</code>和<code>string.length()</code>等价。</p>
<p><code>string.size()</code>和其他<code>STL</code>容器的命名风格相一致（如<code>vector</code>, <code>map</code>）。</p>
<p><code>string.length()</code>出现主要是因为这样的命名符合人的直觉，有更好的可读性。</p>
</li>
<li>
<p><code>string::size_type</code>是无符号类型，和<code>int</code>不同，能存放下任何<code>string</code>对象的大小。</p>
</li>
<li>
<p><code>+</code>两边至少有一端需要是<code>string</code>对象，不允许两个字符串字面量单独相加。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&#34;b&#34;</span> <span class="o">+</span> <span class="s">&#34;c&#34;</span><span class="p">;</span>   <span class="c1">// 正确，从左到右运算时能保证至少一段是string对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&#34;b&#34;</span> <span class="o">+</span> <span class="s">&#34;c&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>   <span class="c1">// 错误，从左到右运算时第一个+左右都是字符串字面量
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>string</code>的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。</p>
</li>
<li>
<p><code>string.size()</code>返回值类型为<code>string::size_type</code>，出现这种类型是为了体现标准库类型和机器无关的特性。</p>
</li>
<li>
<p><code>string</code>对象的比较运算完全实现了运算符重载（<code>==</code>, <code>!=</code>, <code>&lt;</code>,<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>）。</p>
<p><code>==</code>表明两个对象的内容和长度完全一致，反之任一不同则<code>!=</code>。</p>
<p>不等关系运算符比较的法则：</p>
<ol>
<li>如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。</li>
<li>如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。</li>
</ol>
</li>
<li>
<p><code>string</code>对象赋值操作就是内容的替换。</p>
</li>
<li>
<p><code>string</code>对象相加操作就是内容的拼接，<code>+=</code>操作同理。</p>
</li>
<li>
<p><code>string</code>对象可以与字符串字面量相加。</p>
</li>
<li>
<p>形如<code>cname</code>的<code>C++</code>头文件兼容形如<code>ctype.h</code>的<code>C</code>头文件，<code>C++</code>头文件中定义的名字可以在<code>std</code>中找到。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>表达式中出现<code>string.size()</code>函数时就不应该使用<code>int</code>类型，这样可以避免<code>int</code>和<code>unsigned</code>混用的问题。</p>
</li>
<li>
<p><code>C++</code>和<code>C</code>兼容的头文件作选择时，选择<code>C++</code>的头文件。</p>
</li>
<li>
<p>处理<code>string</code>对象中每一个字符时，使用<code>foreach</code>语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">str</span><span class="p">{</span><span class="s">&#34;Some String&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用引用来改变原字符串内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>处理<code>string</code>对象中特定字符时使用<code>[]</code>（下标运算符）或者迭代器。</p>
<p>使用<code>[]</code>访问字符之前检查<code>string</code>对象是否为空。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>string</code>对象下标使用<code>string::size_type</code>作为类型而非<code>int</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;Hello, world!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">index_of_space</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
]]></description>
</item>
<item>
    <title>重学C&#43;&#43;：类型推导</title>
    <link>https://ayamir.github.io/posts/knowledge/cpp/auto/</link>
    <pubDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</pubDate><author>miracle_l@bupt.edu.cn (Ayamir)</author><guid>https://ayamir.github.io/posts/knowledge/cpp/auto/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>auto</code>可以在一条语句中声明多个变量，但是所有变量的类型必须一致。</p>
</li>
<li>
<p><code>decltype</code>在分析表达式类型时并不执行表达式。</p>
</li>
<li>
<p><code>decltype</code>处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。</p>
</li>
<li>
<p><code>decltype((variable))</code>的结果永远是引用。</p>
<p><code>decltype(variable)</code>的结果只有当<code>variable</code>是引用时才是引用。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li><code>auto</code>用于变量初始化时的类型推导，<code>decltype</code>用于分析表达式的类型。</li>
<li><code>auto</code>对引用类型推导时实际上用的是引用对象的值。</li>
<li><code>auto</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学 C++：Const 二三事</a>。</li>
<li><code>decltype</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学 C++：Const 二三事</a>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li><code>auto</code>尽量只在类型较长但比较清晰时使用。</li>
<li><code>decltype</code>尽量不要使用。</li>
</ol>
]]></description>
</item>
</channel>
</rss>
