<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Ayamir&#39;s Blog</title>
        <link>https://ayamir.github.io/posts/</link>
        <description>所有文章 | Ayamir&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miracle_l@bupt.edu.cn (Ayamir)</managingEditor>
            <webMaster>miracle_l@bupt.edu.cn (Ayamir)</webMaster><lastBuildDate>Thu, 04 Nov 2021 11:01:18 &#43;0800</lastBuildDate><atom:link href="https://ayamir.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>自适应360度视频推流挑战</title>
    <link>https://ayamir.github.io/posts/note5/</link>
    <pubDate>Thu, 04 Nov 2021 11:01:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/note5/</guid>
    <description><![CDATA[<h1 id="背景">背景</h1>
<p>用户使用头戴设备比使用传统显示器观看360度视频内容时的满意度对于扰乱更加敏感。</p>
<p>沉浸式的体验受到不完美的视角预测和高度动态化的网络状况的消极影响。</p>
<p>目前主要面临的挑战有以下4个：</p>
<p></p>
<h2 id="viewport预测">Viewport预测</h2>
<h3 id="背景-1">背景</h3>
<p>HMD的本质特征是快速响应用户头部的移动。当用户改变viewport时HMD处理交互并检测相关的viewport来精确播放器的信息，这样视野就能以正常的可视角度被提供给用户。Viewport预测在优化的360度视频推流中非常必要。配备有位置传感器的可穿戴HMD允许客户端更新其视角方向相应的视角场景。</p>
<h3 id="分类">分类</h3>
<ul>
<li><em>内容不可知</em>的方式基于历史信息对viewport进行预测。</li>
<li><em>内容感知</em>的方式需要视频内容信息来预测未来的viewport。</li>
</ul>
<h3 id="内容不可知方式">内容不可知方式</h3>
<h4 id="分类-1">分类</h4>
<ul>
<li>平均线性回归LR</li>
<li>航位推算DR</li>
<li>聚类</li>
<li>机器学习ML</li>
<li>编解码器体系结构</li>
</ul>
<h4 id="现有成果">现有成果</h4>
<h5 id="qians-worklr">Qian&rsquo;s work——LR</h5>
<p>使用平均线性回归和加权线性回归模型来做viewport预测，之后对与预测区域重叠的tile进行整体推流。</p>
<ul>
<li>当预测后0.5s、1s、2s加权线性回归表现更好</li>
</ul>
<h5 id="petrangelis-worklr">Petrangeli&rsquo;s work——LR</h5>
<p>将被划分成tile的等矩形的帧分成3个区域：viewport区、相邻区、其他区。</p>
<p>结合观察者头部的移动，将可变比特率分配给可见和不可见区域。</p>
<p>作者利用最近（100毫秒）用户观看历史的线性外推来预测未来的注视点。</p>
<h5 id="mavlankar-and-girods-work运动向量">Mavlankar and Girod&rsquo;s work——运动向量</h5>
<p>使用运动向量比如观察者的平移、倾斜、缩放等方向上的速度和加速度，来执行视角区域预测。</p>
<h5 id="la-fuentes-work运动向量">La Fuente&rsquo;s work——运动向量</h5>
<p>考虑了两种预测变体：角速度和角加速度，从用户以前的方向数据来估计未来的头部方向。按照预测结果分配不同的量化参数到每个tile上。</p>
<p>当进行进一步的预测时（超过2s），这种方式限制了预测的精度。</p>
<p>如果视频tile被基于错误的预测而被请求，用户的实际viewport可能会被没有请求因而没有内容的黑色tile所覆盖。</p>
<h5 id="bans-workknnlr">Ban&rsquo;s work——KNN+LR</h5>
<p>使用KNN算法利用跨用户观看历史，使用LR模型利用户个体化的行为。</p>
<p>就视角预测的准确率而言，分别取得了20%和48%的绝对和相对改进。</p>
<h5 id="lius-workcluster">Liu&rsquo;s work——cluster</h5>
<p>提出了使用数据融合方法，通过考虑几个特征来估计未来视角位置。特征例如：用户的参与度、用户观看同一视频的行为、单个用户观看多个视频的行为、最终用户设备、移动性水平。</p>
<h5 id="petrangelis-workcluster">Petrangeli&rsquo;s work——cluster</h5>
<p>基于车辆轨迹预测的概念，考虑了类似的轨迹形成一个簇来预测未来的viewport。</p>
<p>结果表明这种方法为更长的视野提高了精确度。</p>
<p>检查了来自三个欧拉角的不同轨迹，这样做可能导致性能不足。</p>
<h5 id="rossis-workcluster">Rossi&rsquo;s work——cluster</h5>
<p>提出了一种聚类的方法，基于球形空间中有意义的viewport重叠来确认用户的簇。</p>
<p>基于Bron-Kerbosch（BK）算法的聚类算法能够识别大量用户，这些用户观看的是相同的60%的3s长球形视频块。</p>
<p>与基准相比，该方法为簇提供了可兼容且重要的几何viewport重叠。</p>
<h5 id="jiangs-work">Jiang&rsquo;s work</h5>
<p>背景：</p>
<p>LR方法对于长期的预测视野会导致较差的预测精度。长短时记忆（LSTM）是一种递归神经网络（RNN）架构，适用于序列建模和模式开发。</p>
<p>方法：</p>
<p>为了在FoV预测中获取比LR方法更高的精确度，开发了一种使用带有128个神经元的LSTM模型的viewport预测方法。</p>
<ul>
<li>分析了360度数据集，观察到用户在水平方向头部有快速转向，但是在垂直方向几乎是稳定的。</li>
<li>实验表明，这种方法同时考虑水平和垂直方向的头部移动时，比LR等方法产生了更少的预测错误。</li>
</ul>
<h5 id="baos-work">Bao&rsquo;s work</h5>
<p>背景：</p>
<p>对150个用户进行了16个视频剪辑的主观实验，并对其行为进行了分析。</p>
<p>使用3个方向的欧拉角$\theta$, $\phi$, $\psi$来表示用户在3D空间中头部的移动，结果表明不同方向的动作有强自相关性和消极的互相关性。因此多个角度的预测可以分开进行。</p>
<p>方法：</p>
<p>开发两个独立的LSTM模型来分别预测$\theta$和$\phi$，之后将预测结果应用于目标区域流来有效利用可用网络资源。</p>
<h5 id="hous-work">Hou&rsquo;s work</h5>
<ul>
<li>提出一种基于深度学习的视角产生方法来只对提前预测的360度视频和3自由度的VR应用的viewport tile进行抽取和推流。（使用了大规模的数据集来训练模型）</li>
<li>使用包含多层感知器和LSTM模型来预测6自由度的VR环境中头部乃至身体的移动，预测的视野被预渲染来做到低延迟的VR体验。</li>
</ul>
<h5 id="heyses-work">Heyse&rsquo;s work</h5>
<p>背景：</p>
<p>在某些例子中，用户的移动在视频的不同部分中非常不稳定。这增加了机器学习方式的训练压力。</p>
<p>方法：</p>
<p>提出了一个基于RL模型的上下文代理，这个模型首先检测用户的显著移动，然后预测移动的方向。这种分层自学习执行器优于球形轨迹外推法（这种方法将用户运动建模为轨迹的一部分，而不是单位球体上的完整轨迹）</p>
<h5 id="qians-work">Qian&rsquo;s work</h5>
<p>提出了一种叫做Flare的算法来最小化实际viewport和预测viewport之间的不匹配。</p>
<ul>
<li>应用了一种ML方法来执行频繁的viewport预测，包括从130名用户收集的1300条头部运动轨迹的4个间隔。</li>
<li>使用viewport轨迹预测，Flare可以将错误预测替换成最新预测。</li>
</ul>
<h5 id="yu-and-lius-work">Yu and Liu&rsquo;s work</h5>
<p>背景：</p>
<p>LSTM网络本身具有耗时的线性训练特性。编解码器的LSTM模型把训练过程并行化，相比于LR和LSTM本身而言，改善了预测精度。</p>
<p>方法：</p>
<p>使用基于注意力的LSTM编解码器网络体系结构来避免昂贵的递归并能更好地捕获viewport变化。</p>
<ul>
<li>提出的体系结构相比于传统的RNN，获得了更高的预测精度，更低的训练复杂度和更快的收敛。</li>
</ul>
<h5 id="jamalis-work">Jamali&rsquo;s work</h5>
<p>提出使用LSTM编解码器网络来做长期的viewport预测（例如3.5s）。</p>
<p>收集了低延迟异质网络上跨用户的方向反馈来调整高延迟网络上目标用户的预测性能。</p>
<h3 id="内容感知方式">内容感知方式</h3>
<h4 id="背景-2">背景</h4>
<p>内容感知方式可以提高预测效率。</p>
<h4 id="具体方法">具体方法</h4>
<h5 id="aladaglis-work">Aladagli&rsquo;s work</h5>
<p>提出了一个显著性驱动的模型来提高预测精度。</p>
<ul>
<li>没有考虑用户在360度视频中的视角行为。</li>
<li>viewport预测错误可以通过理解用户对360度视频独特的可见注意力最小化。</li>
</ul>
<h5 id="nguyens-work">Nguyen&rsquo;s work</h5>
<p>背景：</p>
<p>大多数现存的方法把显著性图看作是360度显示中的位置信息来获得更好的预测结果。</p>
<p>通用的显著性和位置信息体系结构基于固定预测模型。</p>
<p>方法：</p>
<p>提出了<code>PanoSalNet</code>来捕获用户在360度帧中独特的可见注意力来改善显著性检测的性能。</p>
<ul>
<li>同时使用HMD特性和显著性图的固定预测模型获得了可测量的结果。</li>
</ul>
<h5 id="xus-work">Xu&rsquo;s work</h5>
<p>提出了两个DRL(Deep Reinforcement Learning)模型用于同时考虑运动轨迹和可见注意力特性的viewport预测网络。</p>
<ul>
<li>离线模型基于内容流行度检测每个帧里的显著性。</li>
<li>在线模型基于从离线模型获得的显著性图和之前的viewport预测信息预测viewport方向和大小。</li>
<li>这个网络只能预测30ms的下一个viewport位置。</li>
</ul>
<h5 id="xus-work-1">Xu&rsquo;s work</h5>
<p>收集了大规模的被使用带有眼部轨迹跟踪的HMD的45个观测者观察的动态360度视频数据集，提出了基于历史扫描路径和图像特征预测注视位移的方法。</p>
<ul>
<li>在与当前注视点、viewport和整个图像相关的三个空间尺度上执行了显著性计算。</li>
<li>可能的图像特性被通过向CNN喂图像和相应的显著性图，同时LSTM模型捕获历史信息来抽取出来。</li>
<li>之后将LSTM和CNN特性耦合起来，用于下一次的用户注视信息预测。</li>
</ul>
<h5 id="fans-work">Fan&rsquo;s work</h5>
<p>用户更容易被运动的物体吸引，因此除了显著性图之外，Fan等人也考虑了使用预训练  的CNN来估计用户未来注视点的内容运动图。</p>
<ul>
<li>由于可能存在多个运动，这让预测变得不可靠，因此运动贴图的开发还需要进一步的研究。</li>
</ul>
<h5 id="yangs-work">Yang&rsquo;s work</h5>
<ul>
<li>使用CNN模型基于历史观测角度信息预测了单viewport。</li>
<li>接着考虑了一种使用内容不可知和内容感知方法如RNN和CFVT模型的融合层的viewport轨迹预测策略。</li>
<li>融合模型使其同时支持更好地预测并且提高了大概40%的精度。</li>
</ul>
<h5 id="ozcinars-work">Ozcinar&rsquo;s work</h5>
<p>将viewport轨迹转换为基于viewport的视觉注意图，然后对不同大小的tile进行推流以保证更高的编码效率。</p>
<h5 id="lis-work">Li&rsquo;s work</h5>
<p>现有的预测模型对未来的预测能力有限，Li等人提出了两种模型，分别用于viewport相关和基于tile的推流系统。</p>
<ul>
<li>第一个模型应用了基于用户轨迹的LSTM编解码网络体系结构。</li>
<li>第二个模型应用了卷积LSTM编解码体系结构，使用序列的热图来预测用户的未来方向。</li>
</ul>
<h3 id="总结">总结</h3>
<p>精确的方向预测使360度视频的客户端可以以高分辨率下载最相关的tile。</p>
<p>当前采用显著性和位置信息的神经网络模型的性能比直接利用当前观察位置进行未来viewport位置估计的简单无运动的基线方法表现差。估计的显著性中的噪音等级限制了这些模型的预测精度。并且这些模型也引入了额外的计算复杂度。</p>
<p>对于360度视频注意点的可靠预测和用户观看可能性与显著性图之间关系的理解，显著性模型必须被改善并通过训练大规模的数据集来适应，尤其是被配备了不同摄像机旋转的镜头所捕获的数据。</p>
<p>另一方面，卷积LSTM编解码器和基于轨迹的预测方法适合长期预测，并能带来相当大的QoE改进，特别是在协作流媒体环境中。</p>
<h2 id="qoe评估">QoE评估</h2>
<h3 id="背景-3">背景</h3>
<p>由于全方位视频非常普遍，因此，通过这种类型的视频分发来确定用户的特定质量方面是至关重要的。QoE在视频推流应用中扮演着重要角色。在传统视频推流中，QoE很大程度上被网络负载和分发性能所影响。现有的次优目标度量方法并不适用于全向视频，因为全向视频受网络状况和用户视角行为的影响很大。</p>
<h3 id="主观质量评估">主观质量评估</h3>
<p>主观质量评估是估计360度视频推流质量的现实并且可靠的方法。</p>
<h4 id="upeniks-work">Upenik&rsquo;s work</h4>
<p>用一台MergeVR HMD执行了主观测试来体验360度图像。</p>
<ul>
<li>实验数据包括主观分数、视角轨迹、在每个图像上花费的时间由软件上获得。</li>
<li>视角方向信息被用于计算显著性图。</li>
<li>但是这项研究没有考虑对360度视频的评估。</li>
</ul>
<h4 id="zhangs-work">Zhang&rsquo;s work</h4>
<p>为了弥补360度视频和常规视频度量方式之间的性能差距，为全景视频提出了一种主观质量评估方法，称为<em>SAMPVIQ</em>。</p>
<ul>
<li>23位参与者被允许观看4个受损视频，整体视频质量体验的评分在0～5分之间。</li>
<li>参与者之间存在较大的评分差异。</li>
</ul>
<h4 id="xus-work-2">Xu&rsquo;s work</h4>
<p>提出两种主观测量方式：总体区分平均意见分数(O-DMOS)和矢量区分平均意见分数(V-DMOS)来获得360度视频的质量损失。</p>
<ul>
<li>类似于传统食品的DMOS度量方式，O-DMOS度量方式计算主观测试序列的总计区分分数。</li>
</ul>
<h4 id="schatzs-work">Schatz&rsquo;s work</h4>
<p>研究了使用HMD观看360度内容时停顿事件的影响。</p>
<ul>
<li>沉浸式内容的主观质量评估并非不重要，可能导致比实际推荐更多的开放性问题。</li>
<li>通常来讲人们的期望于传统的HAS相似，即如果可能的话，根本没有停顿。</li>
</ul>
<h4 id="可用的开源工具">可用的开源工具</h4>
<p>AVTrack360，OpenTrack和360player能捕获用户观看360度视频的头部轨迹。</p>
<p>VRate是一个在VR环境中提供主观问卷调查的基于Unity的工具。</p>
<p>安卓应用*<a href="https://github.com/zerepolbap/miro360" target="_blank" rel="noopener noreffer">MIRO360</a>*，支持未来VR主观测试的指南开发。</p>
<h4 id="cybersickness"><code>Cybersickness</code></h4>
<p><code>Cybersickness</code>是一种获得高QoE的潜在障碍，它能引起疲劳、恶心、不适和呕吐。</p>
<h5 id="singlas-work">Singla&rsquo;s work</h5>
<p>使用受限的带宽和分辨率，在不同的延迟情况下进行了两个主观实验。</p>
<ul>
<li>开发了主观测试平台、测试方法和指标来评估viewport自适应360度视频推流中的视频感知等级和<code>Cybersickness</code>。</li>
<li>基于tile的推流在带宽受限的情况下表现很好。</li>
<li>47ms的延迟实际上不影响感知质量。</li>
</ul>
<h5 id="trans-work">Tran&rsquo;s work</h5>
<p>考虑了几个影响因子例如内容的空间复杂性，数量参数，分辨率特性和渲染模型来评估cybersickness，质量，可用性和用户的存在。</p>
<ul>
<li>VR环境中快速移动的内容很容易引发cybersickness。</li>
<li>由于高可用性和存在性，用户的cybersickness也可能加剧。</li>
</ul>
<h5 id="singlas-work-1">Singla&rsquo;s work</h5>
<p>评估了28名受试者在Oculus Rift和HTC Vive头戴式电脑上观看6个全高清和超高清分辨率YouTube视频时的观看不适感。</p>
<ul>
<li>HMD的类型轻微地影响感知质量。</li>
<li>分辨率和内容类型强烈影响个人体验。</li>
<li>女性用户感到<code>cybersickness</code>的人数更多。</li>
</ul>
<h4 id="空间存在感">空间存在感</h4>
<p>空间存在感能增强沉浸感。</p>
<h5 id="zous-work">Zou&rsquo;s work</h5>
<p>方法：</p>
<p>提出了一个主观框架来测量25名受试者的空间存在感。</p>
<ul>
<li>提出的框架包括三层，从上到下分别为：空间存在层、感知层、科技影响层。</li>
<li>心理上的空间存在感形成了空间存在层。</li>
<li>感知层以视频真实感、音频真实感和交互元素为特征。</li>
<li>科技影响层由几个模块组成，这些模块与感知层相连，以反映传感器的真实性。</li>
</ul>
<h5 id="huponts-work">Hupont&rsquo;s work</h5>
<p>应用通用感知的原则来研究在Oculus HMD和传统2D显示器上玩游戏的用户的空间存在感。</p>
<ul>
<li>与2D显示器相比，3D虚拟现实主义显示出更高的惊奇、沉浸感、存在感、可用性和兴奋感。</li>
</ul>
<h4 id="生理特征度量">生理特征度量</h4>
<h5 id="salgados-work">Salgado&rsquo;s work</h5>
<p>方法：</p>
<p>捕获多种多样的生理度量，例如心率HR，皮肤电活性EDA、皮肤温度、心电图信号ECG、呼吸速率、血压BVP、脑电图信号EEG来评价沉浸式模拟器的质量。</p>
<h5 id="egans-work">Egan&rsquo;s work</h5>
<p>基于HR和EDA信号评估VR和非VR渲染模式质量分数。</p>
<ul>
<li>相比于HR，EDA对质量分数有强烈的影响。</li>
</ul>
<h4 id="技术因素感知">技术因素感知</h4>
<p>不同的技术和感知特征，如失真、清晰度、色彩、对比度、闪烁等，用于评估感知视频质量。</p>
<h5 id="fremereys-work">Fremerey&rsquo;s work</h5>
<p>确定了可视质量强烈地依赖于应用的运动插值（MI）算法和视频特征，例如相机旋转和物体的运动。</p>
<p>在一项主观实验中，12位视频专家回顾了使用FFmpeg混合、FFmpeg MCI（运动补偿插值）和butterflow插值到90 fps的四个视频序列。作者发现，与其他算法相比，MCI在QoE方面提供了极好的改进。</p>
<h4 id="总结-1">总结</h4>
<p>主观测试与人眼直接相关，并揭示了360度视频质量评估的不同方面的影响。</p>
<p>在这些方面中，空间存在感和由佩戴VR头戴设备观看360度视频导致的<em>cybersickness</em>极为重要，因为这些效果并不在传统的2D视频观看中出现。</p>
<p>主观评估需要综合的手工努力并因此昂贵耗时并易于出错，相对而言，客观评估更易于管理和可行。</p>
<h3 id="客观质量评估">客观质量评估</h3>
<p>由于类似的编码结构和2D平面投影格式，对360度内容应用客观质量评估很自然。</p>
<h4 id="计算psnr">计算PSNR</h4>
<p>现有投影方式中的采样密度在每个像素位置并不均匀。</p>
<h5 id="yus-work">Yu&rsquo;s work</h5>
<p>为基于球形的PSNR计算引入S-PSNR和L-PSNR。</p>
<ul>
<li>S-PSNR通过对球面上所有位置的像素点做同等加权来计算PSNR。</li>
<li>利用插值算法，S-PSNR可以完成对支持多种投影模式的360度视频的客观质量评估。</li>
<li>L-PSNR通过基于纬度和访问频率的像素点加权测量PSNR。</li>
<li>L-PSNR可以测量viewport的平均PSNR而无需特定的头部运动轨迹。</li>
</ul>
<h5 id="zakharchenkos-work">Zakharchenko&rsquo;s work</h5>
<p>提出了一种Craster Parabolic Projection-PSNR (CPP-PSNR) 度量方式来比较多种投影方案，通过不改变空间分辨率和不计算实际像素位置的PSNR，将像素重新映射成CPP投影。</p>
<ul>
<li>CPP投影方式可能使视频分辨率大幅下降。</li>
</ul>
<h5 id="suns-work">Sun&rsquo;s work</h5>
<p>提出了一种叫做weighted-to-spherically-uniform PSNR (WS-PSNR)的质量度量方式，以此来测量原始和受损内容之间的质量变化。</p>
<ul>
<li>根据像素在球面上的位置考虑权重。</li>
</ul>
<h4 id="计算ssim">计算SSIM</h4>
<p>SSIM是另一种质量评估指标，它通过三个因素反映图像失真，包括亮度、对比度和结构。</p>
<h5 id="chens-work">Chen&rsquo;s work</h5>
<p>为2D和360度视频分析了SSIM结果，引入了球型结构的相似性度量（S-SSIM）来计算原始和受损的360度视频之间的相似性。</p>
<ul>
<li>在S-SSIM中，使用重投影来计算两个提取的viewport之间的相似性。</li>
</ul>
<h5 id="zhous-work">Zhou&rsquo;s work</h5>
<p>考虑相似性的权重提出了WS-SSIM来测量投影区域中窗口的相似性。</p>
<ul>
<li>性能评估表明，与其他质量评估指标相比，WS-SSIM更接近人类感知。</li>
</ul>
<h5 id="van-der-hoofts-work">Van der Hooft&rsquo;s work</h5>
<p>提出了<em>ProbGaze</em>度量方式，基于tile的空间尺寸和viewport中的注视点。</p>
<ul>
<li>考虑外围tile的权重来提供合适的质量测量。</li>
<li>相比于基于中心和基于平均的PSNR和SSIM度量方式，<em>ProbGaze</em>能估计当用户突然改变viewport位置时的视频质量变化。</li>
</ul>
<h5 id="xus-work-3">Xu&rsquo;s work</h5>
<p>引入了两种客观质量评估度量手段：基于内容感知的PSNR和非内容感知的PSNR，用于编码360度视频。</p>
<ul>
<li>第一种方式基于空间全景内容对像素失真进行加权。</li>
<li>第二种方式考虑人类偏好的统计数据来估计质量损失。</li>
</ul>
<h4 id="基于psnr和ssim方式的改进">基于PSNR和SSIM方式的改进</h4>
<p>尽管各种基于PSNR和SSIM的方式被广阔地应用到了360度视频的质量评估中，但这些方式都没有真正地捕获到感知质量，特别是当HMD被用于观看视频时。因此需要为360度内容特别设计一种优化的质量度量方式。</p>
<h5 id="upeniks-work-1">Upenik&rsquo;s work</h5>
<p>考虑了一场使用4张高质量360度全景图像来让45名受试者在不同的编码设定下评估和比较客观质量度量方式性能的主观实验。</p>
<ul>
<li>现有的客观度量方式和主观感知到的质量相关性较低。</li>
</ul>
<h5 id="trans-work-1">Tran&rsquo;s work</h5>
<p>论证主观度量和客观度量之间相关性较高，但是使用的数据集较小。</p>
<h4 id="基于ml的方式">基于ML的方式</h4>
<p>基于ML的方式可以弥补客观评估和主观评估之间的差距。</p>
<h5 id="da-costa-filhos-work">Da Costa Filho&rsquo;s work</h5>
<p>提出了一个有两个阶段的模型。</p>
<ul>
<li>首先自适应VR视频的播放性能由机器学习算法所确定。</li>
<li>之后模型利用估计的度量手段如视频质量、质量变化、卡顿时间和启动延迟来确定用户的QoE。</li>
</ul>
<h5 id="lis-work-1">Li&rsquo;s work</h5>
<p>引入了基于DRL的质量获取模型，在一次推流会话中同时考虑头部和眼部的移动。</p>
<ul>
<li>360度视频被分割成几个补丁。</li>
<li>低观看概率的补丁被消除。</li>
<li>参考和受损视频序列都被输入到深度学习可执行文件中，以计算补丁的质量分数。</li>
<li>之后分数被加权并加到一起得到最终的分数。</li>
</ul>
<h5 id="yangs-work-1">Yang&rsquo;s work</h5>
<p>考虑了多质量等级的特性和融合模型。</p>
<ul>
<li>质量特性用<code>region of interest(ROI)</code>图来计算，其中包括像素点等级、区域等级、对象等级和赤道偏差。</li>
<li>混合模型由后向传播的神经网络构造而成，这个神经网络组合了多种质量特性来获取整体的质量评分。</li>
</ul>
<h3 id="总结-2">总结</h3>
<p>精确的QoE获取是优化360度视频推流服务中重要的因素，也是自适应分发方案中基础的一环。</p>
<p>单独考虑VR中的可视质量对完整的QoE框架而言并不足够。</p>
<p>为能获得学界的认可，找到其他因素的影响也很必要，例如<code>cybersickness</code>，生理症状，用户的不适感，HMD的重量和可用性，VR音频，viewport降级率，网络特性（延迟，抖动，带宽等），内容特性（相机动作，帧率，编码，投影等），推流特性（viewport偏差，播放缓冲区，时空质量变化等）。</p>
<h2 id="低延迟推流">低延迟推流</h2>
<h3 id="背景-4">背景</h3>
<p>360度全景视频推流过程中的延迟由几部分组成：传感器延迟、云/边处理延迟、网络延迟、请求开销、缓冲延迟、渲染延迟和反馈延迟。</p>
<p>低延迟的要求对于云VR游戏、沉浸式临场感和视频会议等更为严格。</p>
<p>要求极低的终端处理延迟、快速的云/边计算和极低的网络延迟来确保对用户头部移动做出反馈。</p>
<p>现代HMD可以做到使传感器延迟降低到用户无法感知的程度。</p>
<p>传输延迟已经由5G移动和无线通信技术大幅减少。</p>
<p>但是，对于减少处理、缓冲和渲染延迟的工作也是必要的。</p>
<p>许多沉浸式应用的目标是MTP的延迟少于20ms，理想情况是小于15ms。</p>
<h3 id="减少启动时间">减少启动时间</h3>
<h4 id="减少初始化请求的数据量">减少初始化请求的数据量</h4>
<p>通常来讲，较小的视频segment能减少启动和下载时间。</p>
<h5 id="van-der-hoofts-work-1">Van der Hooft&rsquo;s work</h5>
<p>考虑了新闻相关内容的推流，使用的技术有：</p>
<ol>
<li>服务端编码</li>
<li>服务端的用户分析</li>
<li>服务器推送策略</li>
<li>客户端积极存储视频数据</li>
</ol>
<p>取得的效果：</p>
<ul>
<li>降低了启动时间</li>
<li>允许不同网络设定下的快速内容切换</li>
<li>较长的响应时间降低了性能</li>
</ul>
<h5 id="nguyens-work-1">Nguyen&rsquo;s work</h5>
<p>基于viewport依赖的自适应策略分析了自适应间隔延迟和缓冲延迟的影响。</p>
<ul>
<li>使用服务端比特率计算策略来最小化响应延迟的影响。</li>
<li>根据客户端的响应估计可用的网络吞吐量和未来的viewport位置。</li>
<li>服务端的决策引擎推流合适的tile来满足延迟限制。</li>
</ul>
<p>取得的效果：</p>
<ul>
<li>对于viewport依赖型推流方案而言，较少的自适应和缓冲延迟不可避免。</li>
</ul>
<h3 id="降低由tile分块带来的网络负载">降低由tile分块带来的网络负载</h3>
<p>在HTTP/1.1中，在空间上将视频帧分成矩形tile会增加网络负载，因为每个tile会产生独立的网络请求。</p>
<p>请求爆炸的问题导致了较长的响应延迟，但是可以通过使用HTTP/2的服务器推送特性解决。这个特型使服务器能使用一条HTTP请求复用多条消息。</p>
<h5 id="weis-work">Wei&rsquo;s work</h5>
<p>利用HTTP/2协议来促进低延迟的HTTP自适应推流。</p>
<ul>
<li>提出的服务端推送的策略使用一条请求同时发送几个segment避免多个GET请求。</li>
</ul>
<h5 id="petrangelis-work">Petrangeli&rsquo;s work</h5>
<p>结合特定请求参数与HTTP/2的服务端推送特性来促进360度视频推流。</p>
<ul>
<li>客户端为一个segment发送一条call，服务器使用FCFS策略传送k个tile。</li>
<li>利用HTTP/2的优先级特性可以使高优先级的tile以紧急的优先级被获取，进而改善网络环境中的高往返时间的性能。</li>
</ul>
<h5 id="xus-work-4">Xu&rsquo;s work</h5>
<p>为360度内容采用了<code>k-push</code>策略：将k个tile推送到客户端，组成一个单独的时间段。</p>
<ul>
<li>提出的方法与QoE感知的比特率自适应算法一起，在不同的RTT设定下，提高了20%的视频质量，减少了30%的网络传输延迟。</li>
</ul>
<h5 id="yahias-work">Yahia&rsquo;s work</h5>
<p>使用HTTP/2的优先级和多路复用功能，在两个连续的viewport预测之间，即在交付相同片段之前和期间，组织紧急视频块的受控自适应传输。</p>
<h5 id="yens-work">Yen&rsquo;s work</h5>
<p>开发了一种支持QUIC的体系结构来利用流优先级和多路复用的特性来实现360度视频的安全和低优先级的传输。</p>
<ul>
<li>当viewport变化发生时，QUIC能让常规的tile以低优先级推流，viewport内的tile以高优先级推流，都通过一条QUIC连接来降低viewport tile的缺失率。</li>
<li>作者说测试表明基于QUIC的自适应360度推流比HTTP/1.1和HTTP/2的方案表现更好。</li>
</ul>
<h3 id="使用移动边缘计算降低延迟">使用移动边缘计算降低延迟</h3>
<h5 id="mangiantes-work">Mangiante&rsquo;s work</h5>
<p>提出了利用基于边缘处理的viewport渲染方案来减少延迟，同时利用终端设备上的电源和计算负载。</p>
<ul>
<li>但是作者没有给出有效的算法或是建立一个实践执行平台。</li>
</ul>
<h5 id="lius-work">Liu&rsquo;s work</h5>
<p>采用远端渲染技术，通过为不受约束的VR系统获取高刷新率来隐藏网络延迟。</p>
<ul>
<li>采用60GHz的无线链路支持的高端GPU，来加快计算速度和4K渲染，减少显示延迟。</li>
<li>尽管提供了高质量和低延迟的推流，但是使用了昂贵的带宽连接，这通常并不能获得。</li>
</ul>
<h5 id="viitanens-work">Viitanen&rsquo;s work</h5>
<p>引入了端到端的VR游戏系统。通过执行边缘渲染来降低延迟，能源和计算开销。</p>
<ul>
<li>为1080p 30fps的视频格式实现了端到端的低延迟（30ms）的系统。</li>
<li>前提是有充足的带宽资源、终端设备需要性能强劲的游戏本。</li>
</ul>
<h5 id="shis-work">Shi&rsquo;s work</h5>
<p>考虑了不重视viewport预测的高质量360度视频渲染。</p>
<ul>
<li>提出的MEC-VR系统采用了一个远端服务器通过使用一个自适应裁剪过滤器来动态适应viewport覆盖率，这个过滤器按照观测到的系统延迟增加viewport之外的区域。</li>
<li>基于viewport覆盖率的延迟调整允许客户端容纳和补偿突然的头部移动。</li>
</ul>
<h3 id="共享vr环境中的延迟处理">共享VR环境中的延迟处理</h3>
<p>共享VR环境中用户的延迟取决于用户的位置和边缘资源的分发。</p>
<h5 id="parks-work">Park&rsquo;s work</h5>
<p>通过考虑多个用户和边缘服务器之间的双向通信，提出了一种使用线性蜂窝拓扑中的带宽分配策略，以最小化端到端系统延迟。确定了推流延迟强烈地依赖于：</p>
<ul>
<li>边缘服务器的处理性能</li>
<li>多个交互用户之间的物理和虚拟空间</li>
</ul>
<h5 id="perfectos-work">Perfecto&rsquo;s work</h5>
<p>集成了深度神经网络和毫米波多播传输技术来降低协同VR环境中的延迟。</p>
<ul>
<li>神经网络模型估计了用户即将来临的viewport。</li>
<li>用户被基于预测的相关性和位置分组，以此来优化正确的viewport许可。</li>
<li>执行积极的多播资源调度来最小化延迟和拥塞。</li>
</ul>
<h3 id="总结-3">总结</h3>
<p>在单用户和多用户的环境中，边缘辅助的解决方式对于控制延迟而言占主要地位。</p>
<p>此外还有服务端的viewport计算、服务端push机制和远程渲染机制都能用于低延迟的控制。</p>
<p>现有的4G网络足以支持早期的自适应沉浸式多媒体，正在成长的5G网络更能满足沉浸式内容的需求。</p>
]]></description>
</item><item>
    <title>沉浸式流媒体网络问题的相关解决方案</title>
    <link>https://ayamir.github.io/posts/note4/</link>
    <pubDate>Sat, 30 Oct 2021 19:20:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/note4/</guid>
    <description><![CDATA[<h1 id="概况">概况</h1>
<p>现有的沉浸式流媒体应用都对带宽、QoS和计算需求有着高要求，这主要得益于5G网络。</p>
<p>传统的中心化云计算和云存储体系结构不适于实时的高码率内容分发。</p>
<p>边缘缓存和移动边缘计算成为了推动沉浸式流媒体发展的关键技术。</p>
<h1 id="解决方案">解决方案</h1>
<h2 id="360度视频的边缘协助推流">360度视频的边缘协助推流</h2>
<h3 id="背景">背景</h3>
<p>主要的视频内容可以被传送到边缘节点乃至下游客户端来满足高分辨率等级和严格的低延迟要求。</p>
<p>在边缘计算中，处理和存储的任务被从核心网转移到边缘节点例如基站、微型数据中心和机顶盒等。</p>
<h4 id="hous-work">Hou&rsquo;s work</h4>
<p>提出边缘/云服务器渲染可以使计算更加轻便，可以让无线VR/AR体验可行并且便携。</p>
<h4 id="zhangs-work">Zhang&rsquo;s work</h4>
<p>为VR多人游戏提出了一种混合边缘云基础架构，中心云负责更新全局游戏事件，边缘云负责管理视图更新和大规模的帧渲染任务，以此来支持大量的在线联机人数的低延迟游戏。</p>
<p>进一步陈述了一种服务器选择算法，它基于QoS和玩家移动的影响确保所有VR玩家之间的公平性。</p>
<h4 id="los-work">Lo&rsquo;s work</h4>
<p>考虑了为360度视频渲染提供边缘协助的设备的异质性。</p>
<ul>
<li>边缘服务器将 HEVC tile流转码为viewport视频流并传输到多个客户端。</li>
<li>最优化算法根据视频质量、HMD类型和带宽动态决定边缘节点服务哪个客户端。</li>
</ul>
<h4 id="边缘缓存策略">边缘缓存策略</h4>
<h5 id="背景-1">背景</h5>
<p>传统视频的缓冲方案并不能直接应用到360度视频上。</p>
<p>为了在启用边缘缓存的网络中促进360度视频的传输，两个传输节点之间的代理缓存被部署来使用户侧的内容可用。</p>
<p>边缘缓存能从实质上减少重复的传输并且可以使内容服务器更加可扩展。</p>
<h5 id="mahzais-work">Mahzai&rsquo;s work</h5>
<p>基于其他用户的观看行为为360度视频的流行内容提出了一种缓存策略。</p>
<ul>
<li>与最不常用 (LFU) 和最近最少使用 (LRU) 缓存策略相比，在缓存使用方面的性能分别提高了至少 40% 和 17%。</li>
</ul>
<h5 id="papaioannous-work">Papaioannou&rsquo;s work</h5>
<p>提出了基于tile分辨率和需求统计信息的缓存策略，用最少的错误，提高要求tile的和缓存tile这两种版本的viewport覆盖率。</p>
<ul>
<li>不同缓存和传输延迟的实验评估表明提高了缓存命中率，特别是对于分层编码的tile。</li>
</ul>
<h5 id="lius-work">Liu&rsquo;s work</h5>
<p>背景：</p>
<p>边缘缓存可以被在Evolved Packet Core处执行，因为packet大小很小所以这样可能会产生次优的性能。</p>
<p>另一种替换的方式是在Radio Access Network处缓存数据。但这样由于数据隧道和分包会变得更加复杂。</p>
<p>研究内容：</p>
<p>为移动网络提出了一种同时使用RAN和EPC的基于tile的缓存方案，以此在视频流延迟的约束下节省传输带宽。</p>
<ul>
<li>为EPC和RAN的缓存节点分别被部署在Packet Data Network Gateway和eNodeBs。</li>
<li>EPC中的内容控制实体负责为tile内容改善缓存利用率。</li>
<li>这种联合的tile缓存设计能以优秀的可伸缩性为<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E7%B6%B2%E8%B7%AF%E5%9B%9E%E5%82%B3" target="_blank" rel="noopener noreffer">回程网络</a>显著地减少带宽压力。</li>
</ul>
<h5 id="maniotiss-work">Maniotis&rsquo;s work</h5>
<p>为了利用协作传输的机会，提出了一种在包含宏蜂窝基站(MBS)和多个小基站(SBS)的蜂窝网络中的tile级别的视频流行度感知缓存和传输方案。</p>
<ul>
<li>应用了一种高级的编码方式来创建灵活的tile编码结构，使在每个SBS中能协同缓存。</li>
<li>这种协同允许在 SBS 只存储可能被观看的图块，而其他图块可以通过回程链路获取。</li>
</ul>
<h5 id="chens-work">Chen&rsquo;s work</h5>
<p>为被捕获内容从<code>Drone base station</code>到小基站的联合缓存和分发提出了一种<code>echo-liquid</code>状态的 DRL 模型，使用高频毫米波通信技术。</p>
<ul>
<li>为了满足即时延迟的目标，基站可以从数据中缓存流行内容。</li>
<li>但是，小基站的广泛部署实际上消耗了很多能源。</li>
</ul>
<h5 id="yangs-work">Yang&rsquo;s work</h5>
<p>在计算资源受限制的MEC架构中，利用缓存和计算资源来降低对通信资源的要求。</p>
<ul>
<li>但是这种结构需要资源敏感的任务调度来平衡通信开销和延迟。</li>
</ul>
<h5 id="chakareskis-work">Chakareski&rsquo;s work</h5>
<p>为<code>multi-cell</code>网络环境中的AR/VR应用探索了最前沿的缓存、计算和通信机制。</p>
<ul>
<li>提出的框架允许基站利用适当的计算和缓存资源来最大化总计的回报。</li>
<li>只关注了缓存和渲染，没有考虑用户视角的感受以及处理事件。</li>
</ul>
<h5 id="suns-work">Sun&rsquo;s work</h5>
<p>在内容到达终端之前，同时利用FoV(Field of View)缓存和必要的计算操作来节省通信带宽而不牺牲响应时间。</p>
<ul>
<li>对于同质的FoVs，联合缓存和计算框架执行关于缓存和后期处理的最优决策。</li>
<li>对于异质的FoVs，应用凹凸表达式来得到有吸引力的结果。</li>
</ul>
<h5 id="rigazzis-work">Rigazzi&rsquo;s work</h5>
<p>基于一个开源项目Fog05提出了一个三层(3C)解决方案来分发密集的任务（例如编解码和帧重建），穿越中心云层，受约束的雾层和边缘节点层。</p>
<ul>
<li>利用了系统可伸缩性、互操作性和360度视频推流服务的生命周期循环。</li>
<li>实验性的评估表明在带宽、能源消耗、部署开销和终端复杂性方面取得了显著的减少。</li>
</ul>
<h5 id="elbambys-work">Elbamby&rsquo;s work</h5>
<p>通过在延迟和可靠性的约束下，应用积极的计算和毫米波传输，为交互式的VR游戏提出了一个联合框架。</p>
<ul>
<li>对视频帧做预计算和存储来减少VR流量。</li>
<li>评估表明这种联合机制可以减少多达30%的端到端延迟。</li>
</ul>
<h4 id="边缘计算的优势">边缘计算的优势</h4>
<ol>
<li>
<p>减少延迟</p>
<p>传统的云端节点距离用户较远，边缘计算使用户可以共享多个服务器池的协同计算资源。</p>
</li>
<li>
<p>降低能耗</p>
<p>根据网络架构和资源供应将计算卸载到分布式计算集群，能显著提高移动设备的性能。</p>
</li>
<li>
<p>负载均衡</p>
<p>边缘节点例如基站、小蜂窝和终端设备可以在用户端存储内容，降低了核心网的负载。</p>
</li>
</ol>
<h4 id="现有利用边缘计算的解决方案">现有利用边缘计算的解决方案</h4>
<p></p>
<ul>
<li>大多数任务卸载的MEC方案只致力于优化带宽、能源或延迟。</li>
<li>发展中的方案同时致力于许多其他重要的目标：可靠性、可移动性、QoS、部署成本、安全性。</li>
<li>利用带缓存的边缘计算的能力可以增强可移动性、位置感知能力、高效的数据分发、网络上下文理解和提供服务的安全性。</li>
<li>层级化的边缘-云体系结构对于适应360度视频快速动态传输是必要的。</li>
<li>相比于单静态层，多个动态缓存模型可以帮助管理唐突的viewport和网络变化来改善多用户的viewport命中率。</li>
<li>无论环境怎样，主动缓存都可以通过采用预测机制来预取和缓存部分视频来提高感知质量。</li>
</ul>
<h2 id="360度视频的协同传输">360度视频的协同传输</h2>
<h3 id="背景-2">背景</h3>
<ul>
<li>360度视频推流有较大的用户需求并且在逐渐增长。</li>
<li>目前推流viewport之外的冗余信息会浪费重要的网络带宽。</li>
<li>相同的360度视频内容，在带宽受限的网络之上被推流给多个用户时，码率的需求变得更难满足。</li>
</ul>
<p>几个方法应用了360度视频的协同传输，进而改善传输效率。</p>
<h3 id="方案">方案</h3>
<h4 id="ahmadis-work">Ahmadi&rsquo;s work</h4>
<p>引入了基于DASH的加权tile方法来优化子用户组请求的tile编码性能。</p>
<ul>
<li>提出了多播流方案基于被用户看到的可能性对tile分配适当的权重。</li>
<li>接着基于可用带宽和tile权重为每个子用户组选择tile的码率。</li>
<li>实际上因为相邻tile的不同质量导致了空间质量变化，最终造成糟糕的推流体验。</li>
<li>不必要的离散优化问题巨大，不能保证有积极的表现。</li>
</ul>
<h4 id="baos-work">Bao&rsquo;s work</h4>
<p>基于动作预测和并发观看用户的信道条件提出了一种多播框架，来只分发可能被看到的360度视频块。</p>
<ul>
<li>没有在无线多播传输中考虑优化资源分配。</li>
</ul>
<h4 id="guos-work">Guo&rsquo;s work</h4>
<p>为每个用户假设了一种随机动作模式和不稳定的信道条件，并且开发了多播机会来避免冗余数据传输。</p>
<p>作者考虑了两个非凸的问题：</p>
<ol>
<li>在给定视频质量的约束下，最小化平均传输时间和能源消耗。</li>
<li>在给定的传输时间和能源预算下，最大化每个用户的视频质量。</li>
</ol>
<h4 id="longs-work">Long&rsquo;s work</h4>
<p>考虑了传输时间、视频质量的平滑性和能源限制，在单服务器多用户无线网络环境中优化多个用户的聚合效用。</p>
<ul>
<li>为了减少传输复杂性，作者准备了多种质量的tile，并为每组用户将tile划分到不相邻的子集中。</li>
</ul>
<h4 id="zhangs-work-1">Zhang&rsquo;s work</h4>
<p>引入了一种使用SVC质量自适应方法的协同推流策略，来改善移动自组网环境中，观看360度内容的多个用户间的带宽共享。</p>
<ul>
<li>当遇到可用网络资源限制时，提出的启发性方式基于被看到的可能性和聚合的组级别偏好设置选择最优的tile子集。</li>
</ul>
<h4 id="kans-work">Kan&rsquo;s work</h4>
<p>提出了一种服务端混合多播-单播协同推流方案来分发不同质量的360度视频到多个用户。</p>
<ul>
<li>基于用户的观看行为对其进行分簇，以此来轻松共享相同的视频内容。</li>
<li>为每个tile联合选择传输模式和适当的码率来提高整体的QoE。</li>
</ul>
<h4 id="huang-and-zhangs-work">Huang and Zhang&rsquo;s work</h4>
<p>设计了一种MIMO网络中的MAC调度方式。</p>
<ul>
<li>资源分配策略基于三个主要的函数
<ol>
<li>基于延迟的<code>Motion-To-Photon</code>(MTP)VR帧权重计算。</li>
<li>基于最大<code>Aggregate Delay-Capacity Utility</code>（ADCU）的用户选择。</li>
<li>用于平衡VR数据传输的极高需求的链路自适应方法。</li>
</ol>
</li>
</ul>
<h4 id="li-and-gaos-work">Li and Gao&rsquo;s work</h4>
<p>提出了多用户VR框架，其中边缘云自适应地存储和重用冗余VR帧，以减少计算和传输负载。</p>
<ul>
<li>两级cache的设计：用户端的小型本地cache和边缘的大型中央cache。</li>
<li>通过为所有用户产生背景视图和无论何时都重用帧，使得减少了内存需求。</li>
<li>评估表明帧相关数据和计算负载分别减少了95%和90%。</li>
</ul>
<h4 id="总结">总结</h4>
<p>对推流到多个临近用户的流行内容共享例如360度视频是一种自然的选择。</p>
<p>然而非协作式的用户对带宽的竞争会快速使整个网络瘫痪。</p>
<p>为了为多个用户获得改善的QoE，研究者从以下几个方面做了努力：</p>
<ol>
<li>确定多个用户可能的需求来公平地分配可用的网络资源。</li>
<li>分析跨用户的行为来精确传输要求的子帧到终端用户。</li>
<li>由于侧信道攻击，保护VR帧传输到多个终端用户。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：容器和迭代器</title>
    <link>https://ayamir.github.io/posts/iterator/</link>
    <pubDate>Thu, 28 Oct 2021 17:09:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/iterator/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。</p>
</li>
<li>
<p><code>string</code>虽然不是容器，但是支持很多容器的操作。</p>
</li>
<li>
<p>容器不为空时：<code>begin()</code>返回的是容器中第一个元素的位置；<code>end()</code>返回的是容器中最后一个元素的<strong>后一个位置</strong>。</p>
<p>容器为空时：<code>begin()</code>和<code>end()</code>返回的都是最后一个元素的<strong>后一个位置</strong>。</p>
</li>
<li>
<p>任何可能改变容器大小的操作都会使容器的迭代器失效。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>和指针类似的是，迭代器支持对对象的间接访问。</p>
</li>
<li>
<p>和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如<code>begin()</code>, <code>end()</code>。</p>
</li>
<li>
<p>所有迭代器都支持的运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center"><code>*iter</code></td>
<td style="text-align:center">返回迭代器<code>iter</code>指向元素的<strong>引用</strong></td>
</tr>
<tr>
<td style="text-align:center">-&gt;</td>
<td style="text-align:center"><code>iter-&gt;mem</code></td>
<td style="text-align:center">解引用<code>iter</code>并获取该元素名为<code>mem</code>的成员，即<code>(*iter).mem</code></td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center"><code>++iter</code></td>
<td style="text-align:center">令<code>iter</code>指向当前元素的后一个元素</td>
</tr>
<tr>
<td style="text-align:center">&ndash;</td>
<td style="text-align:center"><code>--iter</code></td>
<td style="text-align:center">令<code>iter</code>指向当前元素的前一个元素</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center"><code>iter1 == iter2</code></td>
<td style="text-align:center">如果两个迭代器指向相同的元素返回<code>true</code>，否则返回<code>false</code></td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center"><code>iter1 != iter2</code></td>
<td style="text-align:center">上面例子的反面</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>迭代器的类型有两种：<code>iterator</code>和<code>const_iterator</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itv</span><span class="p">;</span>          <span class="c1">// 可用于读写vector&lt;int&gt;中的元素
</span><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">its</span><span class="p">;</span>               <span class="c1">// 可用于读写string对象中的元素
</span><span class="c1"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">citv</span><span class="p">;</span>   <span class="c1">// 只能读取元素
</span><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">cits</span><span class="p">;</span>        <span class="c1">// 只能读取元素
</span></code></pre></div><p><code>begin()</code>和<code>end()</code>返回哪一种取决于对象本身是否被<code>const</code>修饰。</p>
<p>C++11中引入了<code>cbegin()</code>和<code>cend()</code>来专门返回<code>const_iterator</code>。</p>
</li>
<li>
<p>认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。</p>
</li>
<li>
<p><code>vector</code>和<code>string</code>的迭代器支持的<strong>额外的</strong>运算：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>iter + n</code></td>
<td style="text-align:center">运算得到一个新迭代器，指向当前元素的后n个元素的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>iter - n</code></td>
<td style="text-align:center">运算得到一个新迭代器，指向当前元素的前n个元素的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>iter += n</code></td>
<td style="text-align:center">运算得到的新迭代器赋值给<code>iter</code></td>
</tr>
<tr>
<td style="text-align:center"><code>iter -= n</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>iter1 - iter2</code></td>
<td style="text-align:center">两个迭代器之间的距离，可正可负</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td style="text-align:center">同两类型的下标运算符中的数字的关系，位置靠前的较小</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>一般不在意迭代器的类型，因此使用<code>auto</code>来标注。</li>
<li>循环结束的判断条件习惯使用迭代器和<code>!=</code>，这样可以不用在意容器类型。</li>
<li>凡是使用了迭代器的循环体中都不能有改变容器大小的操作如<code>push_back()</code>。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：标准库类模板Vector</title>
    <link>https://ayamir.github.io/posts/vector/</link>
    <pubDate>Thu, 28 Oct 2021 15:35:17 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/vector/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>vector</code>的默认初始化是否合法取决于<code>vector</code>内对象所属的类是否要求显式初始化。</p>
</li>
<li>
<p>使用<code>()</code>和<code>{}</code>对<code>vector</code>执行初始化含义不同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>    <span class="c1">// 存储1个int对象，值为10
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">// 存储10个int对象，值为0
</span><span class="c1"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 存储10个int对象，值都是1
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// 存储2个int对象，值分别是10和1
</span></code></pre></div></li>
<li>
<p>使用<code>{}</code>执行列表初始化时按照顺序遵守2个守则：</p>
<ol>
<li>
<p>如果<code>{}</code>内容可以用于初始化，则采用<code>{}</code>默认的初始化含义。</p>
</li>
<li>
<p>如果<code>{}</code>中的内容无法用<code>{}</code>默认的初始化含义做出解释，则会按照<code>()</code>的初始化含义去解释<code>{}</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">{</span><span class="s">&#34;hi&#34;</span><span class="p">};</span>      <span class="c1">// 存储1个值为hi的string对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>        <span class="c1">// 存储10个值为空的string对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">};</span>  <span class="c1">// 存储10个值为hi的string对象
</span></code></pre></div></li>
</ol>
</li>
<li>
<p>与<code>string</code>相同，<code>vector</code>也有<code>size_type</code>作为其<code>size()</code>的返回值类型。</p>
<p>但是使用时必须首先指定<code>vector</code>由哪个类型定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 正确
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">::</span><span class="n">size_type</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 错误
</span></code></pre></div></li>
<li>
<p>只有<code>vector</code>内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。</p>
</li>
<li>
<p>增加<code>vector</code>中的元素只能使用<code>push_back()</code>，而不能使用对下标赋值的方式。</p>
</li>
</ol>
<h2 id="必须理解的点">必须理解的点</h2>
<ol>
<li><code>vector</code>是类模板而非类型。</li>
<li><code>vector</code>中只能容纳对象，不能容纳引用。</li>
<li><code>vector</code>对象能高效增长，增加<code>vector</code>中的元素需要使用<code>push_back()</code>成员函数。</li>
<li><code>vector</code>的成员函数（<code>empty()</code>, <code>size()</code>）和各种运算符（赋值、关系、下标）的操作使用方法和规则基本同<code>string</code>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>不需要在创建<code>vector</code>时确定其中的元素及其大小。</li>
<li>在循环体内部包含向<code>vector</code>对象添加元素的操作时，不应该使用<code>foreach</code>循环。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：标准库类型string</title>
    <link>https://ayamir.github.io/posts/string/</link>
    <pubDate>Thu, 28 Oct 2021 10:31:33 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/string/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>string.size()</code>和<code>string.length()</code>等价。</p>
<p><code>string.size()</code>和其他<code>STL</code>容器的命名风格相一致（如<code>vector</code>, <code>map</code>）。</p>
<p><code>string.length()</code>出现主要是因为这样的命名符合人的直觉，有更好的可读性。</p>
</li>
<li>
<p><code>string::size_type</code>是无符号类型，和<code>int</code>不同，能存放下任何<code>string</code>对象的大小。</p>
</li>
<li>
<p><code>+</code>两边至少有一端需要是<code>string</code>对象，不允许两个字符串字面量单独相加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&#34;b&#34;</span> <span class="o">+</span> <span class="s">&#34;c&#34;</span><span class="p">;</span>   <span class="c1">// 正确，从左到右运算时能保证至少一段是string对象
</span><span class="c1"></span><span class="n">string</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&#34;b&#34;</span> <span class="o">+</span> <span class="s">&#34;c&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>   <span class="c1">// 错误，从左到右运算时第一个+左右都是字符串字面量
</span></code></pre></div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>string</code>的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。</p>
</li>
<li>
<p><code>string.size()</code>返回值类型为<code>string::size_type</code>，出现这种类型是为了体现标准库类型和机器无关的特性。</p>
</li>
<li>
<p><code>string</code>对象的比较运算完全实现了运算符重载（<code>==</code>, <code>!=</code>, <code>&lt;</code>,<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>）。</p>
<p><code>==</code>表明两个对象的内容和长度完全一致，反之任一不同则<code>!=</code>。</p>
<p>不等关系运算符比较的法则：</p>
<ol>
<li>如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。</li>
<li>如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。</li>
</ol>
</li>
<li>
<p><code>string</code>对象赋值操作就是内容的替换。</p>
</li>
<li>
<p><code>string</code>对象相加操作就是内容的拼接，<code>+=</code>操作同理。</p>
</li>
<li>
<p><code>string</code>对象可以与字符串字面量相加。</p>
</li>
<li>
<p>形如<code>cname</code>的<code>C++</code>头文件兼容形如<code>ctype.h</code>的<code>C</code>头文件，<code>C++</code>头文件中定义的名字可以在<code>std</code>中找到。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>表达式中出现<code>string.size()</code>函数时就不应该使用<code>int</code>类型，这样可以避免<code>int</code>和<code>unsigned</code>混用的问题。</p>
</li>
<li>
<p><code>C++</code>和<code>C</code>兼容的头文件作选择时，选择<code>C++</code>的头文件。</p>
</li>
<li>
<p>处理<code>string</code>对象中每一个字符时，使用<code>foreach</code>语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

<span class="n">string</span> <span class="n">str</span><span class="p">{</span><span class="s">&#34;Some String&#34;</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 使用引用来改变原字符串内容
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>处理<code>string</code>对象中特定字符时使用<code>[]</code>（下标运算符）或者迭代器。</p>
<p>使用<code>[]</code>访问字符之前检查<code>string</code>对象是否为空。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p><code>string</code>对象下标使用<code>string::size_type</code>作为类型而非<code>int</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

<span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&#34;Hello, world!&#34;</span><span class="p">;</span>
<span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">index_of_space</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">);</span>
</code></pre></div></li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：类型推导</title>
    <link>https://ayamir.github.io/posts/auto/</link>
    <pubDate>Tue, 26 Oct 2021 21:14:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/auto/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>auto</code>可以在一条语句中声明多个变量，但是所有变量的类型必须一致。</p>
</li>
<li>
<p><code>decltype</code>在分析表达式类型时并不执行表达式。</p>
</li>
<li>
<p><code>decltype</code>处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。</p>
</li>
<li>
<p><code>decltype((variable))</code>的结果永远是引用。</p>
<p><code>decltype(variable)</code>的结果只有当<code>variable</code>是引用时才是引用。</p>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li><code>auto</code>用于变量初始化时的类型推导，<code>decltype</code>用于分析表达式的类型。</li>
<li><code>auto</code>对引用类型推导时实际上用的是引用对象的值。</li>
<li><code>auto</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
<li><code>decltype</code>与<code>const</code>：详见<a href="https://ayamir.github.io/posts/const/" target="_blank" rel="noopener noreffer">重学C++：Const二三事</a>。</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li><code>auto</code>尽量只在类型较长但比较清晰时使用。</li>
<li><code>decltype</code>尽量不要使用。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：Const二三事</title>
    <link>https://ayamir.github.io/posts/const/</link>
    <pubDate>Tue, 26 Oct 2021 15:53:11 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/const/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p>仅用<code>const</code>修饰的对象只在单个文件中有效，如果想在多个文件之间共享<code>const</code>对象，必须在对象<strong>定义</strong>的前面加<code>extern</code>。</p>
</li>
<li>
<p>允许为一个常量引用绑定非常量的对象、字面量和表达式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r1</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>       <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>      <span class="c1">// 正确
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 正确
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1">// 错误
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r5</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">r5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                  <span class="c1">// 正确
</span><span class="c1"></span><span class="n">r1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>                 <span class="c1">// 错误
</span></code></pre></div></li>
<li>
<p>指向常量的指针和常量指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">err_numb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>

<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">cur_err</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">err_numb</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">mut_pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="k">const</span> <span class="n">pi_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span>
</code></pre></div><p>从声明语句的变量符号开始，自右向左看：</p>
<p><code>cur_err</code>首先是一个不可变对象，其次是一个指向<code>int</code>类型可变对象的指针。</p>
<p><code>mut_pi_pointer</code>首先是一个可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
<p><code>pi_pointer</code>首先是一个不可变对象，其次是一个指向<code>double</code>类型不可变对象的指针。</p>
</li>
<li>
<p>当<code>typedef</code>遇到<code>const</code>时容易出现错误理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p><code>pstring</code>是<code>char *</code>的别名，即指向<code>char</code>的指针。</p>
<p><code>const</code>修饰的是<code>pstring</code>，因此<code>cstr</code>是：初始化值为<code>nullptr</code>的<strong>不可变指针</strong>。</p>
<p>错误理解会用<code>char *</code>替换掉<code>pstring</code>，即：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>这样从<code>cstr</code>开始自右向左读的话，<code>cstr</code>就会被理解成：指向<strong>字符常量</strong>的<strong>可变指针</strong>。</p>
</li>
<li>
<p><code>constexpr</code>属于顶层<code>const</code>，因此<code>constexpr</code>修饰指针意味着指针本身不可变。</p>
</li>
<li>
<p><code>auto</code>默认会去除顶层<code>const</code>，保留底层<code>const</code>，如果需要顶层<code>const</code>则需要显式加入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>       <span class="c1">// b是一个初始化值为0的可变int对象 
</span><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>       <span class="c1">// c同b
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>       <span class="c1">// d是一个初始化为指向可变int类对象i的可变指针对象
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>      <span class="c1">// e是一个初始化为指向不可变int类对象ci的可变指针对象
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// f是一个初始化值为0的不可变int对象
</span></code></pre></div></li>
<li>
<p><code>decltype</code>不会去除顶层<code>const</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// x的类型是const int
</span></code></pre></div></li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p><code>const</code>对象在创建时必须进行初始化。</p>
</li>
<li>
<p>常量引用即对<code>const</code>对象的引用。</p>
</li>
<li>
<p>常量引用绑定<em>不可变对象</em>和<em>可变对象</em>时含义不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">可变对象</th>
<th style="text-align:center">不可变对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用常量引用绑定</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">必须</td>
</tr>
<tr>
<td style="text-align:center">常量引用的含义</td>
<td style="text-align:center">不能通过此引用改变对象的值</td>
<td style="text-align:center">不可以改变对象的值</td>
</tr>
</tbody>
</table>
<p>常量引用绑定到可变对象上：对原有可操作性质的窄化，减少操作肯定不会引发错误，所以是允许的。</p>
<p>非常量引用绑定到不可变对象上：对原有可操作性质的拓宽，增加不允许的操作会出错、，所以不可变对象必须使用常量引用。</p>
</li>
<li>
<p>因为指针是对象，而引用不是对象，所以<code>const</code>和指针的组合有2种情况，<code>const</code>和引用的组合只有1种情况。</p>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）：不能通过此指针修改对应的量。</li>
<li>常量指针（const pointer）：指针本身的值不可变，即不能用指针指向其他对象，这种不可重新绑定的特性类似于引用。</li>
</ul>
</li>
<li>引用
<ul>
<li>常量引用：不能通过此引用修改对应的量。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>顶层<code>const</code>表示指针本身是常量，推广之后可以指任意对象是常量；</p>
<p>底层<code>const</code>表示指针指向的对象是常量，推广之后主要于指针和引用等复合类型的基本类型部分有关。</p>
</li>
<li>
<p><strong>常量表达式</strong>指：值不会改变，在编译过程中就能得到计算结果的表达式。</p>
</li>
<li>
<p>为什么需要<code>constexpr</code>？</p>
<p>因为实际中很难判断一个初始值是否为常量表达式。</p>
<p>使用<code>constexpr</code>相当于把验证变量的值是否是一个常量表达式的工作交给了编译器。</p>
<p>用<code>constexpr</code>声明的变量一定是一个变量，并且必须用常量表达式来初始化。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>如果认定变量是一个常量表达式，那就将其声明成<code>constexpr</code>类型。</li>
</ol>
]]></description>
</item><item>
    <title>重学C&#43;&#43;：引用和指针</title>
    <link>https://ayamir.github.io/posts/reference-and-pointer/</link>
    <pubDate>Tue, 26 Oct 2021 15:49:49 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/reference-and-pointer/</guid>
    <description><![CDATA[<h2 id="常见的坑">常见的坑</h2>
<ol>
<li>
<p><code>&amp;</code>和<code>*</code>在不同的上下文里面其含义并不相同，因此<strong>完全可以当成不同的符号看待</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// &amp;在类型名后出现，是声明的一部分，表明r是一个引用
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>        <span class="c1">// *在类型名后出现，是声明的一部分，表明p是一个指针
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>        <span class="c1">// &amp;在表达式中出现，是取地址符
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>       <span class="c1">// *在表达式中出现，是解引用符
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// &amp;是声明的一部分，*是解引用符
</span></code></pre></div></li>
<li>
<p>指针可以用<code>0</code>进行初始化成空指针，但是不可以用<code>0</code>赋值。</p>
</li>
<li>
<p>指针之间使用<code>==</code>来比较时，如果结果是<code>true</code>，对应多种情况：</p>
<ul>
<li>都是空指针</li>
<li>都是同一个地址
<ul>
<li>都指向同一个对象</li>
<li>一个指针指向某一个对象，另一个指针指向另一对象的下一地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="必须要理解的点">必须要理解的点</h2>
<ol>
<li>
<p>引用和指针——都可以用于间接访问对象</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">引用</th>
<th style="text-align:center">指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复合类型</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">表示符号</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">含义</td>
<td style="text-align:center">变量的别名</td>
<td style="text-align:center">变量在内存中的地址</td>
</tr>
<tr>
<td style="text-align:center">初始化和赋值时是否需要类型匹配</td>
<td style="text-align:center">必须匹配（除常量引用）</td>
<td style="text-align:center">必须匹配（除void*和指向常量的指针）</td>
</tr>
<tr>
<td style="text-align:center">是否需要初始化</td>
<td style="text-align:center">必须初始化</td>
<td style="text-align:center">无需初始化</td>
</tr>
<tr>
<td style="text-align:center">可否重新绑定其他变量</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center">可否嵌套定义</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
</tbody>
</table>
<p>引用：</p>
<ul>
<li>引用只能<strong>绑定</strong>在对象上，不能绑定在字面量或者表达式上。</li>
<li>引用只是原有对象的<strong>别名</strong>，并非对象，因此不可以定义引用的引用。</li>
<li>定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。</li>
</ul>
<p>指针：</p>
<ul>
<li>
<p>指针本身就是一个对象，能执行的操作自由度远超过引用。</p>
<ul>
<li>
<p>可以实现嵌套定义，即指针的指针。</p>
</li>
<li>
<p>可以实现指针的引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>         <span class="c1">// p是int型指针
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// r是指针p的引用，从r开始自右向左读，&amp;表明r是一个引用，引用的是指针，指针指向的类型是int
</span><span class="c1"></span>
<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>         <span class="c1">// r是p的别名，即给p赋值为i的地址，即令p指向i
</span><span class="c1"></span><span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// r是p的别名，对r解引用即对p解引用，即将p所指向的地址处变量的值赋值为0
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>指针初始化和赋值时需要使用&amp;运算符取得对象的地址。</p>
</li>
<li>
<p>指针值的情况：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，没有指向任何对象。</li>
<li>无效指针，除上述情况之外。</li>
</ol>
<p>对第4种无效指针的操作是未定义的，后果无法预计。</p>
<p>2、3两种值虽然有效，但是因为没有指向任何对象，所以对其操作的后果同样无法预计。</p>
</li>
</ul>
</li>
<li>
<p><code>void*</code>眼中内存空间仅仅是内存空间，并不能访问内存空间中的对象。</p>
</li>
</ol>
<h2 id="建议">建议</h2>
<ol>
<li>
<p>初始化所有的指针，并且<strong>在对象定义完成之后</strong>再定义指向它的指针。</p>
</li>
<li>
<p>避免使用<code>0</code>和<code>NULL</code>初始化空指针，应该使用<code>nullptr</code>。</p>
</li>
<li>
<p>在使用指针之前检查其是否为<code>nullptr</code>。</p>
</li>
<li>
<p><strong>记住赋值改变的永远是等号左侧的对象。</strong></p>
</li>
<li>
<p>面对复杂的指针或引用的声明语句时，从变量名开始自右向左阅读来弄清楚其真实含义。</p>
</li>
</ol>
]]></description>
</item><item>
    <title>自适应360度视频推流方案</title>
    <link>https://ayamir.github.io/posts/note3/</link>
    <pubDate>Mon, 25 Oct 2021 09:34:10 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/note3/</guid>
    <description><![CDATA[<h2 id="概述">概述</h2>
<p>360度视频的推流手段逐渐从视角独立型方案变成基于tile的视角依赖型方案。</p>
<p>相比于常规视频，360度视频被编码成全向的场景。</p>
<p>自适应360度视频推流利用DASH框架来实现比特率的自适应。</p>
<h2 id="分类">分类</h2>
<h3 id="viewport-independent-streaming">Viewport-Independent Streaming</h3>
<h4 id="服务端的任务">服务端的任务</h4>
<ul>
<li>使用如ERP、CMP等视角独立型的投影方式，360度视频被投影到一个球体上。</li>
</ul>
<h4 id="客户端的任务">客户端的任务</h4>
<ul>
<li>投影之后的视频直接被传送到客户端，并不需要来自传感器的方向信息。</li>
<li>客户端需要支持对应的投影格式。</li>
<li>客户端像处理传统视频一样完成比特率自适应。
<ul>
<li>基于网络特征向将要到来的segment请求相同投影格式的表示</li>
</ul>
</li>
</ul>
<p>DASH插件需要支持相同质量视频的推流。</p>
<h4 id="应用">应用</h4>
<p>视角独立型推流主要用于体育、教育和旅游视频内容。</p>
<h4 id="优点">优点</h4>
<ul>
<li>简单</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>相比于视角依赖型方案视频编码效率低了30%。</li>
<li>为不可见的区域要求大量带宽和解码资源。</li>
</ul>
<h3 id="viewport-dependent-streaming">Viewport-Dependent Streaming</h3>
<h4 id="终端设备的任务">终端设备的任务</h4>
<ul>
<li>只接受特定的视频帧内容，包括等于或大于视角角度的可见信息。</li>
<li>监测相关的视角作为用户头部移动的回应，并且向服务端发送信号来精确播放器信息。</li>
<li>为服务端准备和用户方向相关的几个自适应集。</li>
</ul>
<h4 id="客户端的任务-1">客户端的任务</h4>
<ul>
<li>根据网络情况和估计的视角位置决定获取哪个自适应集。</li>
</ul>
<h4 id="难点">难点</h4>
<ul>
<li>可视区域的确定</li>
<li>与用户头部移动的同步</li>
<li>质量调整</li>
<li>提供平滑的播放体验</li>
</ul>
<h4 id="现有的工作">现有的工作</h4>
<h5 id="各种投影方式在实际推流中表现如何">各种投影方式在实际推流中表现如何？</h5>
<ul>
<li>相比于金字塔格式，为视角依赖型投影方案提出的多分辨率变体有最好的研究和开发(RD)性能。</li>
<li>偏移CMP获得了5.6%到16.4%的平均可见质量。
<ul>
<li>提出的框架可以基于已知的网络资源和未来的视角位置适应视角的尺寸和质量。</li>
<li>相比于理想的下载过程，这种二维自适应策略可以花费20%的额外网络带宽下载超过57%的额外视频块。</li>
</ul>
</li>
</ul>
<h5 id="如何在网络资源受限的情况下提供高质量的推流">如何在网络资源受限的情况下提供高质量的推流？</h5>
<ul>
<li>为视角依赖型推流产生不同质量的segment。
<ul>
<li>当流中只有有限的representation时，利用Quality Emphasized Regions策略来缩放特定区域的分辨率。</li>
<li>在拥塞网络条件下，执行了基于网络回应的视角大小和比特率的联合适应，结果显示，相比于传送全部的360度场景，动态的视角覆盖率提供了更好的画面质量。</li>
<li>这种基于网络回应的自适应也确保基于整体拥塞变化做调整时能改善视频质量。</li>
</ul>
</li>
<li>为立体视频的背景和前景视图采用不对称质量。
<ul>
<li>可以分别为背景块和前景块分别节省15%和41%的比特率。</li>
</ul>
</li>
</ul>
<h5 id="dash需要做什么">DASH需要做什么？</h5>
<ul>
<li>manifest中需要包含视角位置信息和投影元数据。</li>
<li>优化获取random access point的周期来优化视角分辨率自适应体验。</li>
<li>考虑低延迟和活跃的视角切换。</li>
</ul>
<h3 id="tile-based-streaming">Tile-based Streaming</h3>
<p>传统视频被分成多个块，360度视频在块的基础上还被分成多个大小相等或者不等的tile，以此更加精确地调整画面的细节质量。</p>
<h4 id="分块策略">分块策略</h4>
<ul>
<li>
<p>基本完全交付</p>
</li>
<li>
<p>高级完全交付</p>
</li>
<li>
<p>部分交付</p>
</li>
</ul>
<p></p>
<h4 id="分块模式">分块模式</h4>
<p>1x1，3x2，5x3，6x4，8x5</p>
<p>其中6x4的模式实现了较好的带宽消耗和编码效率的折中。</p>
<p>在不同的带宽条件下，基本完全交付策略获得了大约65%的带宽节约。</p>
<h4 id="具体方案">具体方案</h4>
<h5 id="clustile">ClusTile</h5>
<p>基于分簇的方式，推送满足最小带宽需求的tile来克服编码效率和计算开销。</p>
<ul>
<li>相比于传统和高级的基于tile的推流方案，分别实现了72%和52%的带宽节约。</li>
<li>当实际看到的和下载的tile有差异时，基于分簇的tile选取可能会导致选择不当。</li>
</ul>
<h5 id="ghoshs-work">Ghosh&rsquo;s work</h5>
<p>提议以最低可获得的质量下载周围和远处的tile。</p>
<ul>
<li>相比于其他算法，视角及其周边区域的可变质量提高了20%的QoE水平。</li>
</ul>
<h5 id="ozcinars-work">Ozcinar&rsquo;s work</h5>
<p>介绍了一种自适应 360° 视频流框架。</p>
<ul>
<li>
<p>利用视觉注意力度量来计算每个帧的最佳平铺模式。</p>
</li>
<li>
<p>使用选中的模式，为不同区域的tile分配非统一的比特率。</p>
</li>
<li>
<p>比特率的选取取决于估计的视角和网络状况。</p>
</li>
<li>
<p>因为很大部分的带宽被用于传输非视角内的tile，框架难以优化视角内的质量。</p>
</li>
</ul>
<h5 id="xies-work">Xie&rsquo;s work</h5>
<p>提出了一套优化框架，以此来最小化预取tile的错误，改善与不同比特率相关联的tile边界的平滑程度。</p>
<ul>
<li>
<p>定义了两个QoE函数，目标是最小化：</p>
<p>预期质量失真$\Phi(X)$</p>
<p>当考虑tile看到概率时视角的空间质量方差$\Psi(X)$：
$$
\Phi(X) = \frac{\sum_{i=1}^{N}\sum_{j=1}^{M}D_{i,j} * x_{i,j} * p_{i,j}}{\sum_{i=1}^{N}\sum_{j=1}^{M}x_{i,j} * s_{i}}
$$</p>
<p>$$
\Psi(X) = \frac{\sum_{i=1}^{N}\sum_{j=1}^{M}x_{i,j}*p_i * (D_{i,j} - s_i * \Phi(X))^{2}}{\sum_{i=1}^{N}\sum_{j=1}^{M}x_{i,j}*s_i}
$$</p>
</li>
<li>
<p>基于目标缓冲区的自适应方法用于在需要短期视口预测的小缓冲区下进行平滑播放</p>
<p>在自适应的第k步，当第k个segment集合下载完成时，缓冲区占用率$b_k$由下面的式子给出：
$$
b_k = b_{k-1} - \frac{R_k*T}{C_k} + T
$$
为了避免用尽所有块，缓冲区的占用率被通过设定一个目标缓冲区水平$B_{target}$所控制，即$b_k = B_{target}$。</p>
</li>
<li>
<p>平均空间质量方差是0.97，比其他基于tile的策略小。</p>
</li>
<li>
<p>所提出的概率自适应框架在感知质量上实现了约 39% 的增益，平均降低了 46% 的空间质量方差。</p>
</li>
</ul>
<h5 id="vander-hoofts-work">Vander Hooft&rsquo;s work</h5>
<p>将360度帧划分成视角内区域和视角外区域。</p>
<ul>
<li>首先为所有区域都选择最低质量，然后提高视角内tile的质量。</li>
<li>如果带宽依然可用，接着提高剩下的tile的质量。</li>
<li>启发式的方式在带宽可用的基础上积极提高视角内tile的质量。</li>
<li>没有考虑视角比特率调整时视角预测的错误。</li>
</ul>
<h5 id="nguyens-work">Nguyen&rsquo;s work</h5>
<p>提出了一种新的自适应机制，它在每个segment中同时考虑头部移动和视角的预测错误，动态地决定视角内的比特率。</p>
<ul>
<li>联合适应扩展块的覆盖范围和比特率。</li>
<li>在不同记录的用户头部运动下的实验评估表明，在不获取非视角内区域过多带宽利用率的情况下，视角内容质量有所提高。</li>
</ul>
<h4 id="dash-srd扩展">DASH SRD扩展</h4>
<p>DASH的SRD扩展提供了多种版本的tile的关联来节省更多的比特率。</p>
<h5 id="le-feuvre-and-concolatos-work">Le Feuvre and Concolato&rsquo;s work</h5>
<p>他们应用了这个SRD特性，引入了同时为独立的和运动受限的HEVC tile的不同优先级设定，以此来高效地实现基于tile的方案。</p>
<ul>
<li>使用开源的GPAC多媒体框架开发了一个DASH客户端，以此来执行带有可配置参数的基于tile的推流。</li>
</ul>
<h5 id="dacuntos-work">D&rsquo;Acunto&rsquo;s work</h5>
<p>提出了一种 <a href="https://github.com/tnomedialab/dash-srd.js" target="_blank" rel="noopener noreffer">MPEG-DASH SRD 方法</a>来促进可缩放和可平移视频的平滑推流。</p>
<ul>
<li>总是下载低分辨率的tile来避免用户移动视角时的重新缓冲。</li>
<li>当前视野区域被上采样并展示给用户，以此来支持高质量的缩放功能。</li>
<li>用<code>JavaScript</code>实现了SRD视频播放器。</li>
</ul>
<h5 id="hosseinis-work">Hosseini&rsquo;s work</h5>
<p>基于SRD实现了视角内容、相邻tile和剩余tile的优先级推流。</p>
<ul>
<li>用6个3D网格构建了一套3D座标系来在3D空间中平滑地表示tile。</li>
<li>相比于基础的方式，这种区分质量的推流方案节省了72%的带宽。</li>
</ul>
<h5 id="kim-and-yangs-work">Kim and Yang&rsquo;s work</h5>
<p>使用改进的MPEG-DASH SRD来在质量可变的tile层中作选择。</p>
<ul>
<li>基于他们之前的工作设计并实现了一个支持多层渲染的 360° VR 播放器，以支持高度不可预测的头部运动数据的高分辨率和低延迟流。</li>
</ul>
<h4 id="motion-constrained-tileset">Motion-Constrained TileSet</h4>
<p>在HEVC中，运动约束贴图集(MCTS)是将整个帧表示为子视频的相邻分割，并为自由选择的贴图集提供解码支持。</p>
<h5 id="zares-work">Zare&rsquo;s work</h5>
<p>将MCTS的概念应用到了全景视频推流中。</p>
<ul>
<li>将两个质量版本的视频分割成tile，以原始的分辨率推流视角内的tile，以低分辨率推流剩余的tile。</li>
<li>它已经表明，选定图块的可变比特率会降低 30% 到 40% 的比特率。</li>
</ul>
<h5 id="skupins-work">Skupin&rsquo;s work</h5>
<p>陈述了一种使用HEVC编码器的基于tile的可变分辨率的推流系统。</p>
<ul>
<li>使用立方贴图投影的360度视频被分割成24个网格，每个代表了一个独立的比特流。</li>
<li>两种不同质量的版本被推流到客户端，例如8个tile以高质量推送，16个tile以低质量推送。</li>
</ul>
<h5 id="sons-work">Son&rsquo;s work</h5>
<p>在基于视角的移动VR推流中，为独立的tile提取和传输实现了基于MCTS的HEVC和可缩放的HEVC编解码器。</p>
<ul>
<li>节省了超过47%的带宽。</li>
<li>相比于原始的HM和SHM编码器表现不佳，因为MCTS限制了时间运动信息。</li>
</ul>
<h5 id="lees-work">Lee&rsquo;s work</h5>
<p>用MCTS编码360度视频tile，并使用显著性检测网络将混合质量的视频tile推流给终端用户。</p>
<ul>
<li>通过显著性模型改进MCTS的使用，可以在不增加任何复杂性的情况下灵活地对感兴趣的tile区域进行解码支持。</li>
</ul>
<h4 id="scalable-video-code">Scalable Video Code</h4>
<p>可伸缩视频编码SVC是实现viewport自适应的一种替代策略。</p>
<p>基础层总被需要并且能从客户端预取来避免重新缓冲事件。</p>
<p>提高层改善viewport质量并且可以在带宽充足的时候被请求。</p>
<p>SVC促进了一种高效的网络内缓存支持来减少多个客户端请求相同内容时的分发开销。</p>
<h5 id="nasrabadis-work">Nasrabadi&rsquo;s work</h5>
<p>使用了一种可伸缩编码方案来解决360度视频推流的重新缓冲的问题。</p>
<ul>
<li>存在质量波动的问题，因为没有使用任何机制来处理viewport的预测错误。</li>
</ul>
<h5 id="nguyens-work-1">Nguyen&rsquo;s work</h5>
<p>建议使用SVC协同viewport预测来克服网络信道和头部运动的随机性。</p>
<ul>
<li>实验表明，所提出的平铺层更新和后期平铺终止特征可使viewport质量提高17%。</li>
</ul>
<h4 id="ai方法的应用">AI方法的应用</h4>
<p>背景：传统视频推流中使用强化学习来高效调整视频比特率和实现长期的QoE回报。</p>
<p>和传统视频内容不同，360度视频包含几个新的方面比如tile大小、viewport预测等。</p>
<p>直接将现有的强化学习自适应策略应用到360度视频上可能会降低推流性能。</p>
<h5 id="fus-work">Fu&rsquo;s work</h5>
<p>为360度视频提出了称为<em>360SRL</em>的一种序列化强化学习方法，它基于之前决策的QoE回报而非估计的带宽状况做出自适应决策。</p>
<ul>
<li>360SRL使用基于tile的推流模拟器来增强训练阶段。</li>
<li>跟踪驱动的评估表明，360SRL比基线适应方法取得了12%的QoE改善。</li>
</ul>
<h5 id="jiangs-work">Jiang&rsquo;s work</h5>
<p>基于历史带宽、缓冲区空间、tile大小和viewport预测错误等，利用强化学习来做viewport和非viewport内tile的比特率选择。</p>
<ul>
<li>所提出系统的架构由状态缓冲区、视口预测 (VPP) 和tile比特率选择 (TBS) 代理组成。</li>
<li>状态缓冲区向VPP和TBS代理提供用户查看模式和网络状态。</li>
<li>VPP代理然后使用LSTM模型估计下一个viewport位置。</li>
<li>TBS 代理由 Asynchronous Advantage Actor-Critic (A3C)算法训练以执行合适的比特率决策。</li>
</ul>
<h5 id="quans-work">Quan&rsquo;s work</h5>
<p>通过卷积神经网络(CNN)提取像素运动来分析用户QoE，并使用它对tile动态分组，从而在视频质量和编码效率之间提供重要的平衡。</p>
<ul>
<li>使用了基于强化学习的自适应代理，它可以智能地使每个图块的质量适应动态环境。</li>
<li>使用真实LTE带宽跟踪验证该方案，在感知质量方面表现出了卓越的性能，同时也节省了带宽资源。</li>
</ul>
<p>背景：深度学习使强化学习能够使用多方面的状态和动作空间进一步优化聚合回报。</p>
<h5 id="kan-and-xiaos-work">Kan and Xiao&rsquo;s work</h5>
<p>设计了一套深度强化学习的框架，基于对环境因素的探索和开发，自适应地调整推流策略。</p>
<ul>
<li>这两种方案都采用DRL的A3C算法来进行比特率决策，因为A3C算法能使代理变得越来越智能化。</li>
<li>性能评估表明，所提出的系统平衡了各种 QoE 指标，包括平均视觉质量、平均质量波动和重新缓冲事件等。</li>
</ul>
<h5 id="zhangs-work">Zhang&rsquo;s work</h5>
<p>提出了一个深度强化学习模型，它考虑viewport预测准确度和网络状况，使用基于LSTM的ACTOR-CRITIC(AC)网络动态地学习适应比特率分配。</p>
<ul>
<li>方案能够很好地适应广泛的动态特性，并且与传统方法相比，提供了20%到30%的改进QoE回报。</li>
</ul>
<h4 id="总结">总结</h4>
<p>基于tile的推流只需要少量的服务端内容版本。</p>
<p>与依赖视图的推流相比，它包含更低的存储和处理开销。</p>
<p>提出的大多数方案为viewport及其临近的tile使用不同的分辨率，这会为高效推流减少带宽开销。</p>
<p>但是这种区分分辨率的tile为了防止viewport预测错误会显著地降低能察觉到的视频质量。</p>
<p>一个50个用户的主观实验表明，当混合1920x1080和960x540分辨率的块时，绝大多数用户能观察到明显的质量降低。</p>
<p>但是当混合1920x1080和1600x900分辨率的块时，用户只会注意到微小的差别。</p>
<p>对于高运动内容，这种混合效应甚至会导致严重的质量下降。</p>
<p>因此为了动态执行tile的选择和基于DRL的比特率适应，需要有一个推流分辨率的恰当选择，进而在流质量、空间质量方差、视口预测误差和带宽效率之间获得完美的平衡。</p>
]]></description>
</item><item>
    <title>自适应视频推流方案</title>
    <link>https://ayamir.github.io/posts/note2/</link>
    <pubDate>Thu, 21 Oct 2021 10:50:54 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://ayamir.github.io/posts/note2/</guid>
    <description><![CDATA[<h2 id="概述">概述</h2>
<p>自适应方案可以在处理不同目标对象时帮助改善推流体验。</p>
<p>目标主要包括视频质量、功耗、负载均衡等在移动无线网和有线网接入的情形。</p>
<p>适应性的视频比特率需要同时匹配网络条件和质量目标的需求。</p>
<h2 id="分类">分类</h2>
<h3 id="服务端适应">服务端适应</h3>
<p>大多数服务端适应的方案要求客户端发送系统或网络相关信息。</p>
<h4 id="质量导向的适应方案quality-oriented-adaptive-schemeqoas">质量导向的适应方案（Quality-Oriented Adaptive Scheme/QOAS）</h4>
<p>向终端用户提供了高知觉质量的媒体内容。</p>
<ol>
<li>
<p>QOAS是C-S架构，决策在服务器端产生。</p>
</li>
<li>
<p>QOAS基于客户知觉质量的反馈，提供对推流质量等级的调整。</p>
</li>
</ol>
<h4 id="智能优先级适应方案intelligent-prioritized-adaptive-schemeipas">智能优先级适应方案（intelligent Prioritized Adaptive Scheme/iPAS）</h4>
<p>专用于802.11网络。</p>
<ol>
<li>
<p>iPAS服务器上的基于固有印象的带宽分配模块被用于组合QoS相关的参数和视频内容特征来进行内容的优先级分类和带宽份额分配。</p>
</li>
<li>
<p>通过区分多媒体流，iPAS提供可用无线信道的优先级分配。</p>
</li>
</ol>
<h4 id="设备导向的适应方案device-oriented-adaptive-multimedia-schemedoas">设备导向的适应方案（Device-Oriented Adaptive multimedia Scheme/DOAS）</h4>
<p>专用于LTE网络，建立在LTE下行链路调度机制之上。</p>
<ol>
<li>DOAS专门根据设备特性实现适配，尤其为多屏终端用户提供了卓越的QoE。</li>
</ol>
<h3 id="客户端适应">客户端适应</h3>
<h4 id="基于吞吐量的自适应方案">基于吞吐量的自适应方案</h4>
<p>这类方案基于估计的网络吞吐量从服务端选择视频的比特率。</p>
<ol>
<li>HTTP客户端通过之前的观察记录来估计网络的吞吐量。</li>
<li>通过测量端获取时间（segment fetch time/SFT）来代表发起和收到回复的瞬时HTTP GET请求之间的时间段，以此来确定一个推流会话中吞吐量的变化，进而独立地做出适应决策。</li>
<li>在分布式网络中，同时考虑并发和顺序的SFT。通过比较实际的和理想的SFT来选择未来的segment的质量等级。</li>
</ol>
<h5 id="festive算法">FESTIVE算法</h5>
<p>适用于多个HAS客户端共享一个常见的拥塞带宽链路的情形。</p>
<p>以<strong>效率、稳定性、公平性</strong>为度量因素的适应性算法。</p>
<p>探索了一种为<strong>分段调度、吞吐量估计和比特率选择</strong>而生的健壮的机制。</p>
<p>包含一个随机调度器来调度下一个视频块的下载。</p>
<p>多个客户端共享容量为$W$的满带宽链路，每个客户端$x$在$t$时刻播放的视频比特率为$b_x,_t$ ，需要避免以下3种问题：</p>
<ul>
<li>
<p><em>Inefficiency</em>：多个HAS客户端必须能选择最可能的表示来提高QoE。</p>
<p>$$ Inefficiency = \frac{|\sum_{x}b_x,_t - W|}{W} $$</p>
<p>低<em>Inefficiency</em>值表明多个客户端对带宽实现了最有效的利用。</p>
</li>
<li>
<p><em>Unfairness</em>：可用带宽应该被均等地分配。</p>
<p>$$ Unfairness = \sqrt{1-JainFair} $$</p>
<p>低<em>Unfairness</em>值表明多个客户端有相近的比特率。</p>
</li>
<li>
<p><em>Instability</em>：不必要的比特率切换会损害推流体验</p>
<p>$$Instability = \frac{\sum_{d=0}^{k-1}|b_{x,t-d} - b_{x,t-d-1}|*w(d)}{\sum_{d=1}^{k}b_{x,t-d} * w(d)}$$</p>
</li>
</ul>
<h5 id="probe-and-adaptpanda算法">Probe AND Adapt(PANDA)算法</h5>
<p>用于检测网络状况，考虑未来比特率选择的平均目标数据比特率。</p>
<p>目标是当多个HAS客户端共享一个拥塞带宽信道时，通过正确探测网络，进而最小化<strong>比特率震荡</strong>。</p>
<p>PANDA算法在性能上击败了FESTIVE算法，并且PANDA算法在这些解决方案中表现出了最好的适应性，在不同带宽情况和播放器设置下实现了最优的<strong>效率、公平性和稳定性</strong>。</p>
<p>整体上的推流质量不只依赖于本地的吞吐量测量，还依赖服务端的网络容量。</p>
<ol>
<li>利用服务器发起的推送机制来降低DASH内容推流到移动客户端的端到端延迟。</li>
<li>利用<em>HTTP/2</em>的流终止特性来实现中间质量调整。</li>
<li>基于估计的用户QoE，功耗和可用资源来改善用户端的推流体验。</li>
</ol>
<p>虽然有证据表明性能得到了提高，但是评估工作只是在受控的LAN环境下有效。</p>
<h5 id="cross-session-stateful-predictorcs2p方案">Cross Session Stateful Predictor(CS2P)方案</h5>
<p>一种数据驱动的吞吐量估计方案，以克服不准确的 HAS 流量预测问题。</p>
<p>将共享相似特性的推流会话分簇，然后对每个簇使用隐马尔科夫模型预测相应的吞吐量样本。</p>
<p>在一个大规模数据集上实验性的评估表明：CS2P高效地估计了可用的网络吞吐量，进而改善了整体上的视频比特率的适应性。</p>
<p>CFA和Pytheas等方案和CS2P类似，也使用数据驱动的控制器来估计可用的吞吐量。</p>
<p>但是这些工作<strong>不支持异构系统</strong>并且<strong>需要额外的训练复杂性</strong>，使其不够具有吸引力。</p>
<p>基于吞吐量的适应性方案主要的挑战在于对吞吐量的精确估计。</p>
<p>为360度视频采用一个没有经过精巧设计的吞吐量估计机制可能会导致不稳定性和较差的QoE，在高度动态化的无线和蜂窝网络中尤甚。</p>
<h4 id="基于缓冲区的自适应方案">基于缓冲区的自适应方案</h4>
<p>客户端会在播放视频时根据当前缓冲区的占用情况请求将要到来的segment。</p>
<h5 id="如何克服不完整的网络信息的限制">如何克服不完整的网络信息的限制</h5>
<ol>
<li>
<p>在多客户端启用缓存的环境中，结合客户端测量工具集和补偿算法构造模型。</p>
<p>这个模型可以高效探测比特率切换时间并通过选择切换适当的比特率来进行补偿，最终实现了可达20%的比特率改善。</p>
</li>
<li>
<p>Buffer Based Adaptation(BBA)方法</p>
<p>应用于Netfix客户端时可以减少可达20%的重新缓冲事件。</p>
<p>BBA方法考虑的缓冲区较大，因此对于比较短的视频不一定有这样的性能。</p>
</li>
<li>
<p>Buffer Occupancy-based Lyapunov Algorithm(BOLA)</p>
<p>把比特率适应性问题看作是与播放质量和重新缓冲时间相关的最优化问题。</p>
<p>BOLA旨在通过把缓冲区大小保持在设定的目标水平来避免重新缓冲。</p>
<p>对于缓冲区级别的突然下降，BOLA通过请求最低可用视频比特率来避免停顿事件的频率。</p>
</li>
</ol>
<h5 id="如何优化缓冲区利用率">如何优化缓冲区利用率</h5>
<ol>
<li>
<p>Adaptation and Buffer Management Algorithm(ABMA+)</p>
<ul>
<li>基于重新缓冲事件的可能性确定未来representation的下载时间。</li>
<li>通过基于预先计算的缓冲区大小和segment下载时间选择最大比特率来确保流畅的播放。</li>
</ul>
<p>这样可以实现低计算开销的良好部署。</p>
</li>
<li>
<p>Scalable Video Coding(SVC)/Bandwidth Independent Efficient Buffering(BIEB)</p>
<ul>
<li>基于层分发获取视频块，进而维持稳定的缓冲区大小来避免频繁的中断。</li>
<li>没有考虑QoE模型中的卡顿和质量切换。</li>
<li>涉及额外的编码和处理开销。</li>
</ul>
</li>
<li>
<p>使用PID控制器的控制论方法</p>
<ul>
<li>强制执行缓冲区设置点来使缓冲区保持在最佳水平。</li>
<li>略微降低视频比特率，以防止不必要的视频比特率调整。</li>
<li>在多个客户端竞争的情况下，不能保证公平性。</li>
</ul>
</li>
</ol>
<h5 id="如何降低dash流的排队延迟">如何降低DASH流的排队延迟</h5>
<p>DASH流会经历最长可达1s的排队延迟和严重拥塞，导致缓冲区膨胀问题，而这会严重损害实时多媒体服务的QoE。</p>
<p>旨在减少网络拥塞的主动队列管理 (AQM) 策略并没有充分减少这种不必要的延迟。</p>
<ol>
<li>DASH客户端根据网络设备的队列大小动态接收窗口大小可以显著减轻缓冲区膨胀效应。</li>
<li>由于长期的viewport预测的高度不确定性，充足的缓冲区空间对于360度视频的流畅播放来说并不可行。</li>
<li>通常小于3s的缓冲区大小对于短期的viewport预测来讲比较适合。</li>
<li>由于小缓冲区很有可能造成播放卡顿，因此较短持续时间的segment可以被用于基于tile的流中，但是相比于长持续时间的segment，这样也会降低编码效率。</li>
</ol>
<h4 id="混合自适应方案">混合自适应方案</h4>
<p>客户端同时考虑吞吐量和播放缓冲信号来确定即将到来的segments的视频比特率。</p>
<h5 id="model-predictive-controlmpc">Model Predictive Control(MPC)</h5>
<p>利用良好定义的参数集合来估计可用的网络和缓冲区资源，进而为高QoE的比特率做出最优调整的控制论方法。</p>
<p>提出的QoE模型采用视频的平均质量$R_k$，平均比特率切换，重新缓冲事件，和初始延迟$T_s$作计算：
$$
QoE_1^K = \sum_{k=1}^{K}q(R_k) - \lambda\sum_{k=1}^{K-1}|q(R_{k+1}) - q(R_k)| - \mu\sum_{k=1}^{K}(d_k(R_k)/C_k - B_k)_+ - \mu_sT_s
$$
$C_k$：第k个块的可用带宽，$B_k$：第k个块的可用缓冲区大小</p>
<p>$\lambda, \mu, \mu_s$：可以根据用户兴趣进行调整的权重</p>
<ul>
<li>
<p>MPC用调和平均的方法来估计吞吐量，并且能够明确管理复杂的控制对象。</p>
</li>
<li>
<p>只研究了单播放器的情况，因此没有公平性的考量。</p>
</li>
</ul>
<h5 id="throughput-and-buffer-occupancy-based-adaptationtboa">Throughput and Buffer Occupancy-based Adaptation(TBOA)</h5>
<p>选择合适的视频比特率来获得单个或多个客户端环境中改进的推流体验。</p>
<ul>
<li>
<p>激进地提高了比特率来最高效地利用可用的带宽。</p>
</li>
<li>
<p>等待缓冲区超过某个级别，然后降低比特率以获得稳定的性能。</p>
</li>
<li>
<p>为缓冲区等级设置三个阈值，例如：</p>
<p>$0 &lt; B_{min} &lt; B_{low} &lt; B_{high}$</p>
<p>目标区间在$B_{low}$和$B_{high}$之间。</p>
<p>算法努力使最优区间$B_{opt}满足$ $B_{opt} = B_{low} + B_{high} \over 2$。</p>
<p>通过控制$B_{low}$和$B_{high}$的阈值，使缓冲区和比特率的变化稳定来应对未知的TCP吞吐量。</p>
</li>
<li>
<p>算法表现的流畅而公平，但是没有把用户满意度的度量考虑在内。</p>
</li>
</ul>
<h5 id="fuzzy-logic-based-dash">fuzzy logic-based DASH</h5>
<p>控制重新缓冲事件和视频推流的质量。</p>
<ul>
<li>考虑了平均吞吐量的估计方法，获得了更高的视频比特率和更少的质量波动。</li>
<li>没有考虑QoE度量。</li>
</ul>
<p>为了更好地调整比特率做出的改进：</p>
<ul>
<li>用Kaufman&rsquo;s Adaptive Moving Average/KAMA测量法估计吞吐量。</li>
<li>用Grey Prediction Model/GPM来估计缓冲区等级。</li>
</ul>
<p>竞争流模拟环境中，改进所取得的效果：</p>
<ul>
<li>平均情况下达到50%的公平性。</li>
<li>最好情况下达到17%的更好的接收质量。</li>
</ul>
<h5 id="spectrum-based-quality-adaptationsquad算法">Spectrum-based Quality Adaptation(SQUAD)算法</h5>
<p>解决吞吐量预测和缓冲区等级估计的不连续性。</p>
<ul>
<li>吞吐量和缓冲区等级反馈信号都被用于选择恰当的质量。</li>
<li>在一开始获取最低质量的segment来减少启动时间。</li>
<li>在视频质量切换频率和幅度方面性能显著提高。</li>
</ul>
<p>尚未有方案讨论如何在视频质量和带宽利用率之间做出很好的平衡。</p>
<h5 id="throughput-friendly-dashtfdash">Throughput Friendly DASH/TFDASH</h5>
<p>获得多个竞争客户端情形下的公平性、稳定性和效率。</p>
<ul>
<li>通过避免OFF端获得了最大并且公平的带宽利用率。</li>
<li>双阈值的缓冲区保证播放时的稳定性。</li>
</ul>
<p>在单客户端的环境中，混合适应方案表现的很合理。</p>
<p>但是多个客户端一起竞争带宽时会迅速扼杀整个网络。</p>
<p>当客户端的缓冲区达到了最大阈值时，客户端进入了ON-OFF阶段，此时客户端只对自己的视频比特率做了调整而没有考虑其他客户端，因而不能正确地估计可用的带宽资源。</p>
<p>这会导致竞争客户端之间带宽利用不足以及带宽分配不均。</p>
<h4 id="基于多路径的自适应方案">基于多路径的自适应方案</h4>
<p>解决的主要问题是在异质网络之上，如何面对交付内容的增加。</p>
<h5 id="multipath-transmission-control-protocolmptcp">Multipath Transmission Control Protocol(MPTCP)</h5>
<ul>
<li>有用但是并不理想
<ul>
<li>因为需要发送端和接收端同时修改内核堆栈。</li>
<li>因为受到网络运营商的限制可能无法通过中间件。</li>
</ul>
</li>
</ul>
<h5 id="cmt-qa方案">CMT-QA方案</h5>
<p>采用多种特定的网络技术来实现并发的多路内容交付。</p>
<h5 id="multi-source-playermsplayer">Multi-source player(MSPlayer)</h5>
<p>实现多条链路之上的高质量视频传送和弹性的容错机制。</p>
<ul>
<li>
<p>客户端驱动的对未来视频segment的比特率分配依赖于估计的网络状况。</p>
</li>
<li>
<p>视频segment可以在两种可用网络之上进行下载，但是多路径的下载可能会造成交付顺序错乱。</p>
</li>
</ul>
<h5 id="cross-layer-fairness-solution">Cross-layer Fairness solution</h5>
<p>通过探索数据链路层和传输层之间的交互来分析数据传输路径的实时质量，提出了一个公平性驱动的高效流控机制。</p>
<p>在模拟环境中，相比于CMT-QA方案：</p>
<ul>
<li>获得了更高的公平性评级。</li>
<li>获得了更低的平均吞吐量和PSNR（峰值信噪比）。</li>
</ul>
<h5 id="kim-and-chungs-work">Kim and Chung&rsquo;s work</h5>
<p>同时利用WiFi和LTE网络接口，从多个视频源下载部分segment。</p>
<ul>
<li>对多路径的聚合带宽进行平滑处理以避免带宽波动。</li>
<li>实现了一种部分segment请求策略以避免乱序问题，经过各种路径传输的部分片段
在呈现给用户之前进行组合。</li>
</ul>
<h5 id="gos-work">Go&rsquo;s work</h5>
<p>在网络成本限制下，调度跨网络间相同比特率的视频块中的所有segment。</p>
<h5 id="基于mpeg-dash的推流策略实验性评估">基于MPEG-DASH的推流策略实验性评估</h5>
<p>以低功耗为移动设备提供了WiFi和LTE网络下的无缝视频播放。</p>
<ul>
<li>没有分析感知视频质量的影响。</li>
</ul>
<h5 id="davvi">DAVVI</h5>
<p>基于HTTP的推流系统，为了实现3G和WiFi网络之上的多信道支持。</p>
<ul>
<li>基于每个信道的质量，视频segment被动态地划分成subsegment，以便于最大负载可以被应用到每个信道上。</li>
</ul>
<p>为多媒体内容交付使用多个网络接口需要为路径质量测量和数据调度精心设计机制，来避免丢包和乱序交付的问题。</p>
<p>然而因为无线异质网络的高度动态性和复杂性，现有的方案在测量实时信息的时候是受限的。</p>
<h5 id="elgablis-work">Elgabli&rsquo;s work</h5>
<p>考虑了基于 SVC 的优先自适应视频传输的两条路径。</p>
<ul>
<li>属于每一层的段可以根据质量、块deadline和路径偏好从可用路由之一传输。</li>
<li>没有考虑在任何路径上应用最大贡献度。</li>
</ul>
<h5 id="zhangs-work">Zhang&rsquo;s work</h5>
<p>提出了一种基于两个流的优先级感知自适应解决方案，它为每个流使用不同的视频比特率。</p>
<ul>
<li>实现了一个集成带宽的方式来为高优先级流启用更高的视频比特率，并在没有足够的可用带宽时终止低优先级流。</li>
</ul>
<h5 id="yun-and-chungs-work">Yun and Chung&rsquo;s work</h5>
<p>为多视图视频提出了一种基于DASH的推流框架，它包括基于缓冲区的服务器推送方案和并行传输机制，以减少不同传输视图之间的切换时间。</p>
<ul>
<li>只有一种路径配置被应用。</li>
</ul>
<h5 id="rahman-and-chungs-work">Rahman and Chung&rsquo;s work</h5>
<p>介绍了基于 HAS 的多视图会议流解决方案，其中演示者、观众和演示屏幕的多个流通过多条路径同时传输。</p>
<ul>
<li>对所有的3个流分配相同的优先级。</li>
<li>采用统一带宽的方式，以便于统一的质量可以被分配到所有流的segment上。</li>
<li>对于多个流的每个segment，其路径以通过考虑网络吞吐量和每个segment的比特率来决定。</li>
<li>没有考虑多信道的影响，这可能降低整体性能。</li>
</ul>
<p>利用多路径网络的特点和优先级特性可以为360度tile视频推流提供更高的推流性能。</p>
<p>提出的所有自适应策略都是通用的，目标是标准的视频交付，并没有对360度视频内容做出特别的考虑。</p>
]]></description>
</item></channel>
</rss>
