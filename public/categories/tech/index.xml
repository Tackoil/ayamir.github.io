<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on Ayamir&#39;s Blog</title>
    <link>https://ayamir.github.io/categories/tech/</link>
    <description>Recent content in Tech on Ayamir&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Feb 2022 17:19:26 +0800</lastBuildDate><atom:link href="https://ayamir.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Use Jupyter Notebook in Conda Env</title>
      <link>https://ayamir.github.io/posts/use-jupyter-notebook-in-conda-env/</link>
      <pubDate>Tue, 15 Feb 2022 17:19:26 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/use-jupyter-notebook-in-conda-env/</guid>
      <description>激活预先配置好的conda环境，这里假设环境名为keras-tf-2.1.0：
conda activate keras-tf-2.1.0 安装ipykernel：
pip3 install ipykernel --user 为ipykernel安装环境：
python3 -m ipykernel install --user --name=keras-tf-2.1.0 打开notebook更改服务之后刷新即可：</description>
    </item>
    
    <item>
      <title>多媒体基础知识</title>
      <link>https://ayamir.github.io/posts/mm-base/</link>
      <pubDate>Mon, 13 Dec 2021 10:03:17 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/mm-base/</guid>
      <description>媒体处理过程 解协议 将流媒体传输方案中要求的数据解析为标准的相应封装格式数据。
音视频在网络中传播时需要遵守对应的传输方案所要求的格式，如DASH、HLS将媒体内容分解成一系列小片段，每个片段有不同的备用码率版本。
同时应用层的协议会要求在媒体文件本身之外，传输信令数据（如对播放的控制或网络状态的描述）
解协议的过程会去除信令数据并保留音视频内容，需要的话还要对视频段进行拼接，最终将其还原成传输之前的媒体格式如MP4，FLV等。
封装格式 封装格式如AVI、MPEG、Real Video将音频和视频组合打包成一个完整的文件.
封装格式不会影响视频的画质，影响画质的是视频的编码格式。
解封装过程就是将打包好的封装格式分离成某种编码的音频压缩文件和视频压缩文件，有时也包含字幕和脚本。
比如FLV或TS格式数据，解封装之后得到H.264-AVC编码的视频码流和AAC编码的音频码流。
编码 视频的本质是一帧又一帧的图片。
所以对于一部每秒30帧，90分钟，分辨率为1920x1080，24位的真彩色的视频，在压缩之前的大小$S$满足： $$ 一帧大小s = 1920 * 1080 * 24 = 49766400(bit) = 6220800(Byte) \ 总帧数n = 90 * 60 * 30 = 162000 \ 总大小S = s * n = 6220800 * 162000 = 1.0077696*10^{12}(Byte) \approx 939(GB) $$ 因为未经压缩的视频体积过于庞大，所以需要对其进行压缩，而压缩就是通常所说的编码。
视频编码方式：H.264-AVC，H.265-HEVC，H.266-VVC
音频编码方式：MP3，AAC
压缩比越大，解压还原之后播放的视频越失真，因为压缩过程中不可避免地丢失了视频中原有图像的数据信息。
解码 解码就是解压缩过程。
解码之后能够得到系统音频驱动和视频驱动能识别的音频采样数据（如PCM数据）和视频像素数据（如YUV420，RGB数据）。
音视频同步 根据时间，帧率和采样率采用一定的算法，同步解码出来的音频和视频数据，将其分别送至声卡和显卡播放。
视频质量指标 分辨率 分辨率指的是视频图像在一个单位尺寸内的精密度。
将视频放大足够大的倍数之后就能看到组成影像的基本单元：像素。
视频的分辨率从数值上描述了像素点的个数，如1920x1080：视频在水平方向有1920个像素，垂直方向有1080个像素。
常见的描述方式：
1080P：指视频有1080行像素，P=&amp;gt;Progressive（逐行扫描） 2K：指视频有2000列像素 MP：像素总数，指像素的行数P与列数K乘积的结果（百万像素） 1080P的分辨率为1920x1080=2073600，所以1080P通常也称为200万像素分辨率 通常视频在同样大小的情况下，分辨率越高，所包含的像素点越多，画面就越细腻清晰</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：容器和迭代器</title>
      <link>https://ayamir.github.io/posts/iterator/</link>
      <pubDate>Thu, 28 Oct 2021 17:09:18 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/iterator/</guid>
      <description>常见的坑 所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。
string虽然不是容器，但是支持很多容器的操作。
容器不为空时：begin()返回的是容器中第一个元素的位置；end()返回的是容器中最后一个元素的后一个位置。
容器为空时：begin()和end()返回的都是最后一个元素的后一个位置。
任何可能改变容器大小的操作都会使容器的迭代器失效。
必须要理解的点 和指针类似的是，迭代器支持对对象的间接访问。
和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如begin(), end()。
所有迭代器都支持的运算：
运算符 例子 含义 * *iter 返回迭代器iter指向元素的引用 -&amp;gt; iter-&amp;gt;mem 解引用iter并获取该元素名为mem的成员，即(*iter).mem ++ ++iter 令iter指向当前元素的后一个元素 &amp;ndash; --iter 令iter指向当前元素的前一个元素 == iter1 == iter2 如果两个迭代器指向相同的元素返回true，否则返回false != iter1 != iter2 上面例子的反面 迭代器的类型有两种：iterator和const_iterator。
vector&amp;lt;int&amp;gt;::iterator itv; // 可用于读写vector&amp;lt;int&amp;gt;中的元素 string::iterator its; // 可用于读写string对象中的元素 vector&amp;lt;int&amp;gt;::const_iterator citv; // 只能读取元素 string::const_iterator cits; // 只能读取元素 begin()和end()返回哪一种取决于对象本身是否被const修饰。
C++11中引入了cbegin()和cend()来专门返回const_iterator。
认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。
vector和string的迭代器支持的额外的运算：
运算 含义 iter + n 运算得到一个新迭代器，指向当前元素的后n个元素的位置 iter - n 运算得到一个新迭代器，指向当前元素的前n个元素的位置 iter += n 运算得到的新迭代器赋值给iter iter -= n 同上 iter1 - iter2 两个迭代器之间的距离，可正可负 &amp;gt;, &amp;lt;, &amp;lt;=, &amp;gt;= 同两类型的下标运算符中的数字的关系，位置靠前的较小 建议 一般不在意迭代器的类型，因此使用auto来标注。 循环结束的判断条件习惯使用迭代器和!</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：标准库类模板Vector</title>
      <link>https://ayamir.github.io/posts/vector/</link>
      <pubDate>Thu, 28 Oct 2021 15:35:17 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/vector/</guid>
      <description>常见的坑 vector的默认初始化是否合法取决于vector内对象所属的类是否要求显式初始化。
使用()和{}对vector执行初始化含义不同。
using std::vector; vector&amp;lt;int&amp;gt; v1{10}; // 存储1个int对象，值为10 vector&amp;lt;int&amp;gt; v2(10); // 存储10个int对象，值为0 vector&amp;lt;int&amp;gt; v3(10, 1); // 存储10个int对象，值都是1 vector&amp;lt;int&amp;gt; v4{10, 1}; // 存储2个int对象，值分别是10和1 使用{}执行列表初始化时按照顺序遵守2个守则：
如果{}内容可以用于初始化，则采用{}默认的初始化含义。
如果{}中的内容无法用{}默认的初始化含义做出解释，则会按照()的初始化含义去解释{}。
using std::vector; using std::string; vector&amp;lt;string&amp;gt; v1{&amp;#34;hi&amp;#34;}; // 存储1个值为hi的string对象 vector&amp;lt;string&amp;gt; v2{10}; // 存储10个值为空的string对象 vector&amp;lt;string&amp;gt; v3{10, &amp;#34;hi&amp;#34;}; // 存储10个值为hi的string对象 与string相同，vector也有size_type作为其size()的返回值类型。
但是使用时必须首先指定vector由哪个类型定义。
std::vector&amp;lt;int&amp;gt;::size_type a; // 正确 std::vector::size_type a; // 错误 只有vector内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。
增加vector中的元素只能使用push_back()，而不能使用对下标赋值的方式。
必须理解的点 vector是类模板而非类型。 vector中只能容纳对象，不能容纳引用。 vector对象能高效增长，增加vector中的元素需要使用push_back()成员函数。 vector的成员函数（empty(), size()）和各种运算符（赋值、关系、下标）的操作使用方法和规则基本同string。 建议 不需要在创建vector时确定其中的元素及其大小。 在循环体内部包含向vector对象添加元素的操作时，不应该使用foreach循环。 </description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：标准库类型string</title>
      <link>https://ayamir.github.io/posts/string/</link>
      <pubDate>Thu, 28 Oct 2021 10:31:33 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/string/</guid>
      <description>常见的坑 string.size()和string.length()等价。
string.size()和其他STL容器的命名风格相一致（如vector, map）。
string.length()出现主要是因为这样的命名符合人的直觉，有更好的可读性。
string::size_type是无符号类型，和int不同，能存放下任何string对象的大小。
+两边至少有一端需要是string对象，不允许两个字符串字面量单独相加。
using std::string; string a = &amp;#34;a&amp;#34;; string b = a + &amp;#34;b&amp;#34; + &amp;#34;c&amp;#34;; // 正确，从左到右运算时能保证至少一段是string对象 string c = &amp;#34;b&amp;#34; + &amp;#34;c&amp;#34; + a; // 错误，从左到右运算时第一个+左右都是字符串字面量 必须要理解的点 string的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。
string.size()返回值类型为string::size_type，出现这种类型是为了体现标准库类型和机器无关的特性。
string对象的比较运算完全实现了运算符重载（==, !=, &amp;lt;,&amp;lt;=, &amp;gt;, &amp;gt;=）。
==表明两个对象的内容和长度完全一致，反之任一不同则!=。
不等关系运算符比较的法则：
如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。 如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。 string对象赋值操作就是内容的替换。
string对象相加操作就是内容的拼接，+=操作同理。
string对象可以与字符串字面量相加。
形如cname的C++头文件兼容形如ctype.h的C头文件，C++头文件中定义的名字可以在std中找到。
建议 表达式中出现string.size()函数时就不应该使用int类型，这样可以避免int和unsigned混用的问题。
C++和C兼容的头文件作选择时，选择C++的头文件。
处理string对象中每一个字符时，使用foreach语句。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cctype&amp;gt; using std::string; string str{&amp;#34;Some String&amp;#34;}; for (auto c : str) { std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl; } // 使用引用来改变原字符串内容 for (auto &amp;amp;c : str) { c = std::toupper(c); } std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl; 处理string对象中特定字符时使用[]（下标运算符）或者迭代器。</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：类型推导</title>
      <link>https://ayamir.github.io/posts/auto/</link>
      <pubDate>Tue, 26 Oct 2021 21:14:32 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/auto/</guid>
      <description>常见的坑 auto可以在一条语句中声明多个变量，但是所有变量的类型必须一致。
decltype在分析表达式类型时并不执行表达式。
decltype处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。
decltype((variable))的结果永远是引用。
decltype(variable)的结果只有当variable是引用时才是引用。
必须要理解的点 auto用于变量初始化时的类型推导，decltype用于分析表达式的类型。 auto对引用类型推导时实际上用的是引用对象的值。 auto与const：详见重学C++：Const二三事。 decltype与const：详见重学C++：Const二三事。 建议 auto尽量只在类型较长但比较清晰时使用。 decltype尽量不要使用。 </description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：Const二三事</title>
      <link>https://ayamir.github.io/posts/const/</link>
      <pubDate>Tue, 26 Oct 2021 15:53:11 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/const/</guid>
      <description>常见的坑 仅用const修饰的对象只在单个文件中有效，如果想在多个文件之间共享const对象，必须在对象定义的前面加extern。
允许为一个常量引用绑定非常量的对象、字面量和表达式。
int i = 42; const int &amp;amp;r1 = i; // 正确 const int &amp;amp;r2 = 42; // 正确 const int &amp;amp;r3 = r1 * 2; // 正确 int &amp;amp;r4 = r1 * 2; // 错误 int &amp;amp;r5 = i; r5 = 0; // 正确 r1 = 42; // 错误 指向常量的指针和常量指针：
int err_numb = 0; const double pi = 3.1415; int *const cur_err = &amp;amp;err_numb; const double *mut_pi_pointer = &amp;amp;pi; const double *const pi_pointer = &amp;amp;pi; 从声明语句的变量符号开始，自右向左看：</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：引用和指针</title>
      <link>https://ayamir.github.io/posts/reference-and-pointer/</link>
      <pubDate>Tue, 26 Oct 2021 15:49:49 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/reference-and-pointer/</guid>
      <description>常见的坑 &amp;amp;和*在不同的上下文里面其含义并不相同，因此完全可以当成不同的符号看待。
int i = 42; int &amp;amp;r = i; // &amp;amp;在类型名后出现，是声明的一部分，表明r是一个引用 int *p; // *在类型名后出现，是声明的一部分，表明p是一个指针 p = &amp;amp;i; // &amp;amp;在表达式中出现，是取地址符 *p = 43; // *在表达式中出现，是解引用符 int &amp;amp;r2 = *p; // &amp;amp;是声明的一部分，*是解引用符 指针可以用0进行初始化成空指针，但是不可以用0赋值。
指针之间使用==来比较时，如果结果是true，对应多种情况：
都是空指针 都是同一个地址 都指向同一个对象 一个指针指向某一个对象，另一个指针指向另一对象的下一地址 必须要理解的点 引用和指针——都可以用于间接访问对象
引用 指针 复合类型 ✅ ✅ 表示符号 &amp;amp; * 含义 变量的别名 变量在内存中的地址 初始化和赋值时是否需要类型匹配 必须匹配（除常量引用） 必须匹配（除void*和指向常量的指针） 是否需要初始化 必须初始化 无需初始化 可否重新绑定其他变量 不可以 可以 可否嵌套定义 不可以 可以 引用：
引用只能绑定在对象上，不能绑定在字面量或者表达式上。 引用只是原有对象的别名，并非对象，因此不可以定义引用的引用。 定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。 指针：
指针本身就是一个对象，能执行的操作自由度远超过引用。
可以实现嵌套定义，即指针的指针。</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：类型系统基础</title>
      <link>https://ayamir.github.io/posts/cpp-types/</link>
      <pubDate>Mon, 18 Oct 2021 19:32:22 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/cpp-types/</guid>
      <description>常见的坑 int, short, long, long long都是带符号的，在前面添加unsigned就能得到无符号类型。
字符型被分为3种：char, signed char, unsigned char，前两种并不等价。 虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。
有符号类型在与无符号类型运算时会隐式转换为无符号类型。
虽然变量初始化时候使用了=号，但是初始化和变量赋值并不相同。
变量默认初始化：
变量类型 位置在函数内部 位置在函数外部 内置类型 undefined 0 自定义类型 由类决定 由类决定 #include &amp;lt;iostream&amp;gt; int default_initialize(int a) { // 输出必定是0 std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; int b; return b; } int main() { int a; // 输出是随机值 std::cout &amp;lt;&amp;lt; default_initialize(a) &amp;lt;&amp;lt; std::endl; } 如果在函数体内部试图初始化一个extern标记的变量会引发错误。
在嵌套作用域中，内层作用域中的定义可以覆盖外层作用域中声明的变量。
可以显式使用域操作符::来指明使用哪层的变量。
必须要理解的点 字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。
变量的组成部分：类型和值。说白了就是一个定性一个定量。
类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。
值在实际代码运行过程中则被各种函数使用参与运算。
变量声明和定义：
声明的意思就是：我要用这个变量。
定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。
声明 定义 规定变量的类型和名字 ✅ ✅ 申请空间 ✅ 初始化 ✅ 执行多次 ✅ 用extern标记未初始化的变量来表明只对变量作声明：</description>
    </item>
    
    <item>
      <title>Immersive Video OMAF-Sample Deploy</title>
      <link>https://ayamir.github.io/posts/immersive-video-deploy/</link>
      <pubDate>Sat, 09 Oct 2021 15:31:46 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/immersive-video-deploy/</guid>
      <description>原仓库地址：Tech-Sample
修改之后的仓库：Tech-Sample
Server 端搭建 修改 Dockerfile 手动设置 wget 和 git 的 http_proxy
旧 package 目录 not found，修改为新 package 目录
因为找不到 glog 库因此加入软链接操作
ln -s /usr/local/lib64/libglog.so.0.6.0 /usr/local/lib64/libglog.so.0 重新编译内核 运行脚本时显示 libnuma 错误因此推断与 numa 设置有关
执行numactl -H显示只有一个 node，报错输出显示需要至少两个 numa 节点
查询资料之后获知可以使用 fakenuma 技术创造新节点，但是 Ubuntu 默认的内核没有开启对应的内核参数
手动下载 Linux 内核源代码到/usr/src/目录 wget https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.11.1.tar.gz 解压 tar xpvf linux-5.11.1.tar.gz 复制现有内核配置 cd linux-5.11.1 &amp;amp;&amp;amp; cp -v /boot/config-$(uname -r) .config 安装必要的包 sudo apt install build-essential libncurses-dev bison flex libssl-dev libelf-dev 进入内核配置界面 sudo make menuconfig 按下/键分别查询CONFIG_NUMA和CONFIG_NUMA_EMU位置 手动勾选对应选项之后保存退出 重新编译并等待安装结束 sudo make -j $(nproc) &amp;amp;&amp;amp; sudo make modules_install &amp;amp;&amp;amp; sudo make install 修改grub启动参数加入 fake numa 配置 sudo vim /etc/default/grub 找到对应行并修改为</description>
    </item>
    
    <item>
      <title>Linux权限相关命令解读</title>
      <link>https://ayamir.github.io/posts/linux-authority/</link>
      <pubDate>Mon, 15 Mar 2021 21:43:35 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/linux-authority/</guid>
      <description>文件和目录的权限 下图为使用exa命令的部分截图
上图中的 Permission 字段下面的字母表示权限 第一个字母表示 文件类型 ：
属性 文件类型 - 普通文件 d 目录文件 l 符号链接 符号链接文件剩余的属性都是 rwxrwxrwx，是伪属性值，符号链接指向的文件属性才是真正的文件属性 c 字符设备文件 表示以字节流形式处理数据的设备，如 modem b 块设备文件 表示以数据块方式处理数据的设备，如硬盘驱动或光盘驱动 剩下的 9 个位置上的字符称为 文件模式 ，每 3 个为一组，分别表示文件所有者、文件所属群组以及其他所有用户对该文件的读取、写入和执行权限
属性 文件 目录 r 允许打开和读取文件 如果设置了执行权限，允许列出目录下的内容 w 允许写入或截断文件，但是不允许重命名或删除文件 如果设置了执行权限，那么允许目录中的文件被创建、被删除和被重命名 x 允许把文件当作程序一样来执行 允许进入目录 id：显示用户身份标识 一个用户可以拥有文件和目录，同时对其拥有的文件和目录有控制权 用户之上是群组，一个群组可以由多个用户组成 文件和目录的访问权限由其所有者授予群组或者用户
下图为 Gentoo Linux 下以普通用户身份执行 id 命令的结果
uid 和 gid 分别说明了当前用户的用户编号与用户名、所属用户组的编号与组名 groups 后的内容说明了用户还属于哪些组，说明了其对应的编号和名称
许多类 UNIX 系统会将普通用户分配到一个公共的群组中如：users 现代 Linux 操作是创建一个独一无二的只有一个用户的同名群组
chmod：更改文件模式 chmod 支持两种标识方法
八进制表示法</description>
    </item>
    
    <item>
      <title>Dns Settings on Archlinux</title>
      <link>https://ayamir.github.io/posts/dns-settings-on-archlinux/</link>
      <pubDate>Tue, 26 Jan 2021 21:43:35 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/dns-settings-on-archlinux/</guid>
      <description>Arch Linux DNS设置 安装dnsmasq sudo pacman -S dnsmasq 配置/etc/resolv.conf中的域名代理服务器 # Tencent nameserver 119.29.29.29 nameserver 182.254.118.118 # Ali nameserver 223.5.5.5 nameserver 223.6.6.6 # OpenDNS IPv4 nameservers nameserver 208.67.222.222 nameserver 208.67.220.220 # OpenDNS IPv6 nameservers nameserver 2620:0:ccc::2 nameserver 2620:0:ccd::2 # Google IPv4 nameservers nameserver 8.8.8.8 nameserver 8.8.4.4 # Google IPv6 nameservers nameserver 2001:4860:4860::8888 nameserver 2001:4860:4860::8844 # Comodo nameservers nameserver 8.26.56.26 nameserver 8.20.247.20 # Generated by NetworkManager nameserver 192.168.1.1 防止/etc/resolv.conf被修改 sudo chattr +i /etc/resolv.</description>
    </item>
    
  </channel>
</rss>
