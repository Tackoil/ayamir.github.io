<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <script
    type="application/javascript"
    src='https://ayamir.github.io/js/theme-mode.js'
  ></script>
  <link rel="stylesheet" href='https://ayamir.github.io/css/frameworks.min.css' />
  <link rel="stylesheet" href='https://ayamir.github.io/css/github.min.css' />
  <link rel="stylesheet" href='https://ayamir.github.io/css/github-style.css' />
  <link rel="stylesheet" href='https://ayamir.github.io/css/light.css' />
  <link rel="stylesheet" href='https://ayamir.github.io/css/dark.css' />
  <link rel="stylesheet" href='https://ayamir.github.io/css/syntax.css' />
  
  <title>
    C&#43;&#43;中的引用 | Ayamir&#39;s blog
  </title>
  
  <link rel="icon" type="image/x-icon" href="/images/favicon.png" />
  
  <meta name="theme-color" content="#1e2327" />

  
  <meta
  name="description"
  content="这篇博客主要总结了C&#43;&#43;中一些与引用有关的概念和使用方法。"
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://ayamir.github.io/post/knowledge/cpp/value-optimization/" />


<meta name="twitter:card" content="summary" />
<meta
  name="twitter:title"
  content="C&#43;&#43;中的引用 - Ayamir&#39;s blog"
/>
<meta
  name="twitter:description"
  content="这篇博客主要总结了C&#43;&#43;中一些与引用有关的概念和使用方法。"
/>
<meta name="twitter:site" content="https://ayamir.github.io/" />
<meta name="twitter:creator" content="" />
<meta
  name="twitter:image"
  content="https://ayamir.github.io/"
/>


<meta
  property="og:type"
  content="article"
/>
<meta
  property="og:title"
  content="C&#43;&#43;中的引用 - Ayamir&#39;s blog"
/>
<meta
  property="og:description"
  content="这篇博客主要总结了C&#43;&#43;中一些与引用有关的概念和使用方法。"
/>
<meta property="og:url" content="https://ayamir.github.io/post/knowledge/cpp/value-optimization/" />
<meta property="og:site_name" content="C&#43;&#43;中的引用" />
<meta
  property="og:image"
  content="https://ayamir.github.io/"
/>
<meta property="og:image:width" content="2048" />
<meta property="og:image:height" content="1024" />

<meta property="article:published_time" content="2024-04-28 22:49:37 &#43;0800 CST" />









 
<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=G-6KX34MKCTY"
></script>
<script>
  if (navigator.doNotTrack !== "1") {
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-6KX34MKCTY");
  }
</script>
 





</head>


<body>
  

<style>
  .height-limitation {
    max-height: 300px;
    overflow-y: scroll;
  }

  .loader {
    border: 4px solid #f3f3f3;
    border-bottom: 4px solid var(--color-fg-muted);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
</style>

<div style="position: relative">
  <header
    class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on"
  >
    <div
      class="Header-item mobile-none"
      style="margin-top: -4px; margin-bottom: -4px"
    >
      <a class="Header-link" href="https://ayamir.github.io/" aria-label="Home">
        <svg
          class="octicon"
          height="32"
          viewBox="0 0 16 16"
          version="1.1"
          width="32"
        >
          <path
            fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          ></path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button
        class="Header-link btn-link js-details-target"
        type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'"
        aria-label="Search"
      >
        <svg
          height="24"
          class="octicon octicon-three-bars"
          viewBox="0 0 16 16"
          version="1.1"
          width="24"
        >
          <path
            fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z"
          ></path>
        </svg>
      </button>
    </div>
    <div
      style="display: none"
      id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex"
    >
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to"
      >
        <div class="position-relative">
          <form
            target="_blank"
            action="https://www.google.com/search"
            accept-charset="UTF-8"
            method="get"
            autocomplete="off"
          >
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"
            >
              <input
                type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q"
                value=""
                placeholder="Search"
                autocomplete="off"
              />
              <input type="hidden" name="q" value="site:https://ayamir.github.io/" />
              <div
                class="js-jump-to-suggestions-container jump-to-suggestions overflow-hidden position-absolute"
              >
                <div
                  id="search-progress"
                  class="d-none color-bg-primary no-underline p-2"
                  role="progress"
                  aria-selected="false"
                >
                  <div class="loader"></div>
                </div>

                <ul
                  id="jump-to-results"
                  role="listbox"
                  class="Box border-0 p-0 m-0 js-navigation-container jump-to-suggestions-results-container js-jump-to-suggestions-results-container js-active-navigation-container height-limitation"
                ></ul>
              </div>
            </label>
          </form>
        </div>
      </div>
    </div>

    <div
      class="Header-item Header-item--full flex-justify-center d-md-none position-relative"
    >
      <a class="Header-link" href="https://ayamir.github.io/" aria-label="Home">
        <svg
          class="octicon octicon-mark-github v-align-middle"
          height="32"
          viewBox="0 0 16 16"
          version="1.1"
          width="32"
        >
          <path
            fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          ></path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0">
      <a
        href="javascript:void(0)"
        class="Header-link no-select"
        onclick="switchTheme()"
      >
        <svg
          style="fill: var(--color-profile-color-modes-toggle-moon)"
          class="no-select"
          viewBox="0 0 16 16"
          version="1.1"
          width="16"
          height="16"
        >
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z"
          ></path>
        </svg>
      </a>
    </div>
  </header>
</div>

  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://ayamir.github.io/">
                  <img class=" avatar-user"
                    src="/images/avatar.png"
                    width="32" height="32" alt=""></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://ayamir.github.io/"></a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://ayamir.github.io/post/knowledge/cpp/value-optimization/">C&#43;&#43;中的引用</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Sun, 28 Apr 2024 22:49:37 &#43;0800"
                    class="no-wrap">
                    Sun, 28 Apr 2024 22:49:37 &#43;0800</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Thu, 02 May 2024 13:17:55 &#43;0800"
                    class="no-wrap">
                    Thu, 02 May 2024 13:17:55 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      3561 Words
                    <span class="file-info-divider"></span>
                                        16 min

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/c&#43;&#43;">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      C&#43;&#43;
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h2 id="移动语义">移动语义</h2>
<p>C++11中引入了移动语义也即移动构造函数，主要的目的是避免不必要的拷贝。移动这一概念相对来说比较好理解，因为一个类型的实例是由其成员构成的，构造一个对象实际上就是对对象的成员进行初始化操作。所以移动就可以理解为把一个对象所拥有的成员移动给另一个对象。在Rust这种一开始就表明所有权这一概念的语言中，移动其实将对象成员的所有权转移给另一个对象。</p>
<p>我们知道拷贝构造函数接受的是const引用：</p>
<ul>
<li>为什么用const修饰？因为拷贝这一个行为在语义上蕴含着这一操作不应该修改被拷贝的对象</li>
<li>为什么是引用？因为如果不是引用就会导致递归的拷贝构造</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// copy constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// copy assign operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="o">*</span><span class="n">array_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><p>那么移动构造函数应该接受什么作为参数呢？这就必须要引入左值引用和右值引用这组概念了，那么什么是左值？什么是右值呢？</p>
<h2 id="左值右值">左值、右值</h2>
<p>其实用 <strong>值(value)</strong> 这个词来描述是不准确的，严格来说是表达式，为什么不严格来说呢？我猜可能是约定俗成吧（C++中就是有很多的不严谨的术语，习惯就好）。在C++里面，一个表达式要么是左值，要么是右值。</p>
<p>左值lvalue的这个左是怎么来的呢，主要是相对于赋值运算符=来说的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">lvalue</span> <span class="o">=</span> <span class="n">rvalue</span>
</span></span></code></pre></div><p>左值顾名思义就是赋值号=左边的值，右值就是右边的值。当然，这种表达是不准确的。</p>
<p>严格来说，左值是在<strong>内存</strong>中占有一个位置的表达式，换句话说就是，我们可以获得左值的地址。</p>
<p>而右值就是反过来：右值是没法获取其在内存中地址的表达式，当然也就没法修改它（认识到这一点这很重要）。</p>
<h2 id="左值引用右值引用">左值引用、右值引用</h2>
<p>右值引用是随着移动语义这个概念在C++11中提出来的，我们都知道引用其实就是一种对某个对象的绑定Binding：</p>
<ul>
<li>左值引用就是只能绑定到左值上的引用，形式上表现为<code>T&amp; x_lref = x;</code>（假设<code>x</code>已经在之前定义过）</li>
<li>右值引用就是只能绑定到右值上的引用，形式上表现为<code>T&amp;&amp; x_rref = T{};</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x_lref</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x_rref</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// compile error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">product_lref</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// compile error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">product_rref</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// ok
</span></span></span></code></pre></div><p>当考虑到<code>const</code>的时候，情况发生了变化。从语义上看，<code>const</code>就是不可变的意思，而我们在使用非<code>const</code>的左值引用的时候通常就是需要修改这个引用所绑定的对象的时候，所以，<code>const</code>修饰左值引用的时候就是向编译器承诺，我们不会修改这个引用所绑定的对象，这满足右值的语义（右值无法修改），因而<code>const</code>左值引用既可以绑定到左值上，也可以绑定到右值上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">product_const_lref</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// ok
</span></span></span></code></pre></div><p>当左值引用、右值引用和<code>const</code>左值引用作为形参类型的时候也是一样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// compile error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">{});</span> <span class="c1">// compile error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">g</span><span class="p">(</span><span class="n">A</span><span class="p">{});</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">h</span><span class="p">(</span><span class="n">A</span><span class="p">{});</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="移动构造函数">移动构造函数</h2>
<p>了解完右值引用之后我们发现，移动这一语义和右值引用的语义不谋而合（不能修改被移动对象的内容），移动构造函数便可以声明为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// copy constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// copy assign operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// move constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span><span class="err">；</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// move assign operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="o">*</span><span class="n">array_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><p>移动构造函数做了什么呢？如前所述，移动这一行为就是把被移动对象other的成员转移给当前对象，所以：</p>
<ol>
<li>递归<strong>浅拷贝</strong>other的每个成员给this的每个成员</li>
<li>释放other的所有成员</li>
</ol>
<p>而移动复制运算符就是：</p>
<ol>
<li>释放this的每个成员</li>
<li>递归浅拷贝other的每个成员给a的每个成员</li>
<li>释放other的所有成员</li>
<li>返回this指针</li>
</ol>
<p>以上面的<code>class A</code>为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">array_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">array_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">other</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">other</span><span class="p">.</span><span class="n">array_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">delete</span> <span class="p">[]</span><span class="n">array_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">array_</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">array_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">other</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">other</span><span class="p">.</span><span class="n">array_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果一个类需要拷贝构造函数，那么它一般也需要移动构造函数。反过来，如果一个类需要移动构造函数，但是不一定需要拷贝构造函数。比如<code>std::unique_ptr</code>只允许移动语义而不允许拷贝语义。（更能理解为什么rust里面默认就是移动，而不是拷贝）</p>
<p>因为默认的移动构造函数并不会进行资源的释放，那么对于拥有在堆上成员的类来说，使用移动构造会造成内存泄漏或者重复释放。具体来说，当我们不定义析构函数时会内存泄漏，定义析构函数但不定义移动构造函数时会重复释放。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">a</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">b</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/ayamir/blog-imgs/main/image-20240429001550851.png" alt="默认析构造成内存泄漏"></p>
<p>因为默认析构函数不会释放动态分配的内存，所以可以看到泄露了<code>sizeof(int) * 10 = 40Byte</code>的内存。</p>
<p>那加上析构函数之后呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span><span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">a</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">b</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/ayamir/blog-imgs/main/image-20240429002210606.png" alt="image-20240429002210606"></p>
<p>因为默认移动构造函数不会将<code>array</code>置为<code>nullptr</code>，所以当析构两个栈上对象时会对同一块内存重复释放。</p>
<p>所以正确版本应该是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// move constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// make other.array to nullptr, avoid re-release
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">other</span><span class="p">.</span><span class="n">array</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">other</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span><span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">a</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span> <span class="n">b</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/ayamir/blog-imgs/main/image-20240429003254819.png" alt="image-20240429003254819"></p>
<h2 id="stdmove和右值引用">std::move和右值引用</h2>
<p><code>std::move()</code>在<code>&lt;utility&gt;</code>中定义，其作用很简单：就是明确地告诉编译器，需要调用形参是右值引用版本的函数重载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">A</span><span class="p">{});</span>              <span class="c1">// rvalue version push_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">A</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>              <span class="c1">// lvalue version push_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>   <span class="c1">// rvalue version push_back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>需要使用<code>std::move</code>的原因和移动构造函数存在的意义也是一样的，避免对象成员的重复创建，也就是避免开销较大的深拷贝。</p>
<h2 id="stdforward引用折叠和万能引用">std::forward、引用折叠和万能引用</h2>
<p>既然提到了<code>std::move</code>就不能绕过<code>std::forward</code>，它和<code>std::move</code>一样，也是在<code>&lt;utility&gt;</code>中定义，两者都是与引用有关的函数，但是使用场合和作用都不太相同，但是它们各自被使用在了<code>vector</code>的<code>push_back</code>和<code>emplace_back</code>定义中，所以也很有意思，这里做一下对比分析。</p>
<p>因为<code>std::forward</code>和<strong>万能引用</strong>基本上是绑定在一块出现的，所以首先需要明确万能引用的定义。</p>
<p>万能引用(Universal Reference)就是既可以接受左值、又可以接受右值的引用，还能保持<code>const</code>语义，这也是我们会看到for-range中的变量类型往往是<code>auto&amp;&amp;</code>的原因。</p>
<p>需要特别注意的是：万能引用的概念在类型推导的场合下是才有意义的，具体来说就是在<code>auto</code>, <code>template &lt;typename T&gt;</code>这样的上下文中才有万能引用这个说法。万能引用和右值引用都是使用<code>&amp;&amp;</code>来表示引用的语义，但是只有在类型推导的上下文中，<code>&amp;&amp;</code>表示的才是万能引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">// universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">...;</span>     <span class="c1">// rvalue reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">...;</span>    <span class="c1">// universal reference
</span></span></span></code></pre></div><p>形参类型是万能引用的函数既能接受左值、又能接受右值，左值和右值对应的实参类型的推导结果不同：</p>
<ul>
<li>传入左值，实参类型被推导为左值引用</li>
<li>传入右值，实参类型为推导为非引用类型，也就是值类型</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">// universal reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>    <span class="c1">// T推导为A&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">{});</span>  <span class="c1">// T推导为A
</span></span></span></code></pre></div><p>此时可以看到，如果传入左值，<code>T</code>被推导为<code>A&amp;</code>，模板相当于被实例化为<code>void (fA&amp; &amp;&amp; t);</code>，而这样的函数签名在C++中是会报编译错误的，这个时候<strong>引用折叠</strong>就发挥作用了，引用折叠的规则会将函数最终的签名推导为<code>void f(A&amp; t);</code>，也就是说，当编译器在模板实例化之后生成引用的引用的时候，引用折叠的规则会推导出最终的函数签名，具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">形参类型</th>
<th style="text-align:center">实参类型</th>
<th style="text-align:center">推导结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A&amp;</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">A&amp;</td>
</tr>
<tr>
<td style="text-align:center">A&amp;</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">A&amp;</td>
</tr>
<tr>
<td style="text-align:center">A&amp;&amp;</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">A&amp;</td>
</tr>
<tr>
<td style="text-align:center">A&amp;&amp;</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">A&amp;&amp;</td>
</tr>
</tbody>
</table>
<p><code>std::forward</code>又名<strong>完美转发</strong>(Perfect Forward)，作用其实就是在类型推导的上下文中，可以保持传入实参的引用类型不变，即：传入左值引用就是左值引用，传入右值引用就是右值引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;rvalue</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g1</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g2</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">{</span><span class="mi">10</span><span class="p">});</span>  <span class="c1">// &#34;rvalue&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">g1</span><span class="p">(</span><span class="n">A</span><span class="p">{</span><span class="mi">10</span><span class="p">});</span> <span class="c1">// &#34;lvalue&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">g2</span><span class="p">(</span><span class="n">A</span><span class="p">{</span><span class="mi">10</span><span class="p">});</span> <span class="c1">// &#34;rvalue&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">A</span> <span class="n">a</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">g2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// &#34;lvalue&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>下面是对这4个调用的解释：</p>
<ol>
<li>直接调用<code>f</code>的右值版本，所以输出&quot;rvalue&quot;；</li>
<li><code>g1</code>接受万能引用，传递一个右值给<code>g1</code>，但是右值的这个属性是在<code>main</code>这个上下文中存在的(<code>A{10}</code>)，而对于<code>g1</code>的上下文来说，<code>t</code>就是一个普通的值类型，所以在不使用<code>std::forward</code>的情况下，会调用左值版本的<code>f</code>，从而输出&quot;lvalue&quot;；</li>
<li><code>g1</code>接受万能引用，传递一个右值给<code>g2</code>，而在<code>g2</code>中使用了<code>std::forward</code>来保持传入的实参的右值属性，所以会调用右值版本的<code>f</code>，从而输出&quot;rvalue&quot;；</li>
<li><code>g2</code>接受左值，并且使用<code>std::forward</code>保持左值的属性，所以调用左值版本的<code>f</code>，从而输出&quot;lvalue&quot;；</li>
</ol>
<h2 id="库代码中的例子">库代码中的例子</h2>
<p>gcc中对于<code>push_back</code>和<code>emplace_back</code>的实现就分别用到了右值引用、万能引用、<code>std::move</code>和<code>std::forward</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// push_back
</span></span></span><span class="line"><span class="cl"><span class="c1">// 接收左值的重载版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_end_of_storage</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="n">_M_realloc_insert</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 接收右值的重载版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__x</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// emplace_back
</span></span></span><span class="line"><span class="cl"><span class="c1">// 万能引用，既接收左值又接收右值的唯一版本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">_Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;::</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">_Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">__args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_end_of_storage</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_Alloc_traits</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_M_realloc_insert</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而两者之间的区别可以看我之前的一篇文章：<a href="https://ayamir.github.io/post/knowledge/cpp/pushback-emplaceback">push_back vs emplace_back</a></p>
</article>
              </div>

              
            </div>
          </div>
        </div>
      </div>

      <div class="pagination-nav">
        <div class="pagination-button next-post">
          
          <div>«&nbsp;</div><a class="pagination-link link-reverse" href="https://ayamir.github.io/post/knowledge/cpp/value-and-optimization/"> C++中的值和优化</a>
          
        </div>
        
        <div class="pagination-button previous-post">
          
          <a class="pagination-link link-reverse" href="https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/">Jitter Buffer学习理解（上）&nbsp;</a><div> »</div>
          
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://ayamir.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://ayamir.github.io/css/toc.css' />

<script
  src="https://utteranc.es/client.js"
  repo="ayamir/ayamir.github.io"
  issue-term="pathname"
  theme="github-light"
  crossorigin="anonymous"
  async
></script>



  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light"
  >
    <ul
      class="list-style-none d-flex flex-wrap col-12 flex-justify-center mb-2 mb-lg-0"
    >
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>
</div>

</body>

<script type="application/javascript" src="https://ayamir.github.io/js/github-style.js"></script>

<script src="https://ayamir.github.io/js/mark.es6.min.js"></script>


<script type="text/javascript">

  const host = window.location.host;
  const keyword = localStorage.getItem('keyword');
  localStorage.removeItem('keyword');

  if (keyword) {
    const markInstance = new Mark(document.body);
    markInstance.unmark({
      done: function() {
        markInstance.mark(keyword);
      }
    });
  }

  const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--color-bg-primary');
  const mutedColor = getComputedStyle(document.documentElement).getPropertyValue('--color-fg-muted');
  const hoverColor = '#216EEB';

  let originalStyle;
  let svgOriginalStyle;
  let titleOriginalStyle;

  const onMouseOver = (node) => {
    originalStyle = Object.assign({}, node.style);
    node.style.backgroundColor = hoverColor;

    const child = node.querySelector('.js-jump');
    child.classList.remove('d-on-nav-focus');

    const title = node.querySelector('.title');
    if (title && primaryColor === ' #fff') {
      titleOriginalStyle = title.style;
      title.style.color = '#fff';
    }

    const svg = node.querySelector('.octicon');
    if (svg) {
      svgOriginalStyle = svg.style;
      svg.style.color = '#fff';
    }
  }

  const onMouseLeave = (node) => {
    node.style = originalStyle;
    const child = node.querySelector('.js-jump');
    child.classList.add('d-on-nav-focus');

    const title = node.querySelector('.title');
    title.style = titleOriginalStyle;

    const svg = node.querySelector('.octicon');
    svg.style = svgOriginalStyle;
  }

  const createSearchItem = (title, link, index) => {
    return `
    <li class="color-bg-primary search-item d-flex flex-justify-start flex-items-center p-0 f5 navigation-item js-navigation-item js-jump-to-scoped-search"
        role="option" aria-selected="false" tabindex="${index}">
        <a onmouseover="onMouseOver(this)" onmouseleave="onMouseLeave(this)"
          class="no-underline d-flex flex-auto flex-items-center jump-to-suggestions-path js-jump-to-suggestion-path js-navigation-open p-2"
          href="${link}" data-item-type="scoped_search">
          <div class="jump-to-octicon js-jump-to-octicon flex-shrink-0 mr-2 text-center ">
            <svg title="Repository" aria-label="Repository" role="img" height="16" viewBox="0 0 16 16"
              version="1.1" width="16" data-view-component="true"
              class="octicon octicon-repo js-jump-to-octicon-repo  flex-shrink-0">
              <path fill-rule="evenodd"
                d="M2 2.5A2.5 2.5 0 014.5 0h8.75a.75.75 0 01.75.75v12.5a.75.75 0 01-.75.75h-2.5a.75.75 0 110-1.5h1.75v-2h-8a1 1 0 00-.714 1.7.75.75 0 01-1.072 1.05A2.495 2.495 0 012 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 011-1h8zM5 12.25v3.25a.25.25 0 00.4.2l1.45-1.087a.25.25 0 01.3 0L8.6 15.7a.25.25 0 00.4-.2v-3.25a.25.25 0 00-.25-.25h-3.5a.25.25 0 00-.25.25z">
              </path>
            </svg>
          </div>    

          <div
            class="title jump-to-suggestion-name js-jump-to-suggestion-name flex-auto overflow-hidden text-left no-wrap css-truncate css-truncate-target">
            ${title}
          </div>

          <div aria-hidden="true" style="color: var(--color-fg-muted);"
            class="color-bg-primary js-jump border rounded-2 flex-shrink-0 color-bg-subtle px-1 ml-1 f6 d-on-nav-focus js-jump-to-badge-jump">
            Jump to
            <span class="d-inline-block ml-1 v-align-middle">↵</span>
          </div>
        </a>
      </li>
    `
  }

  const createGoogleSearchItem = (keyword) => {
    return `
    <li class="color-bg-primary search-item d-flex flex-justify-start flex-items-center p-0 f5 navigation-item js-navigation-item js-jump-to-scoped-search"
        role="option" aria-selected="false" tabindex="0">
        <a onmouseover="onMouseOver(this)" onmouseleave="onMouseLeave(this)"
          class="no-underline d-flex flex-auto flex-items-center jump-to-suggestions-path js-jump-to-suggestion-path js-navigation-open p-2"
          href="https://www.google.com/search?q=${keyword}" target="_blank" data-item-type="scoped_search">
          <div class="jump-to-octicon js-jump-to-octicon flex-shrink-0 mr-2 text-center ">
            <svg title="Search" aria-label="Search" role="img" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-search js-jump-to-octicon-search flex-shrink-0">
                <path fill-rule="evenodd" d="M11.5 7a4.499 4.499 0 11-8.998 0A4.499 4.499 0 0111.5 7zm-.82 4.74a6 6 0 111.06-1.06l3.04 3.04a.75.75 0 11-1.06 1.06l-3.04-3.04z"></path>
            </svg>
          </div>    

          <div
            class="title jump-to-suggestion-name js-jump-to-suggestion-name flex-auto overflow-hidden text-left no-wrap css-truncate css-truncate-target">
            ${keyword}
          </div>

          <div aria-hidden="true" style="color: var(--color-fg-muted);"
            class="color-bg-primary js-jump border rounded-2 flex-shrink-0 color-bg-subtle px-1 ml-1 f6 d-on-nav-focus js-jump-to-badge-jump">
            Google search
            <span class="d-inline-block ml-1 v-align-middle">↵</span>
          </div>
        </a>
      </li>
    `
  }

  const stripHtml = (html) => {
    let tmp = document.createElement('div');
    tmp.innerHTML = html;

    
    const styles = tmp.getElementsByTagName('style');
    while(styles[0]) {
      styles[0].parentNode.removeChild(styles[0]);
    }

    
    const scripts = tmp.getElementsByTagName('script');
    while(scripts[0]) {
      scripts[0].parentNode.removeChild(scripts[0]);
    }
    
    return tmp.textContent || tmp.innerText || "";
  }

  const inputDom = document.querySelector(".Header-search-input");
  const resultDom = document.getElementById('jump-to-results');
  let debounceTimer;
  let parser;
  let xmlDoc;

  const search = (_keyword) => {

    resultDom.innerHTML = '';

    const keyword = _keyword;

    if (!keyword) return;

    const progressDom = document.getElementById('search-progress');
    if (progressDom && progressDom.classList.contains('d-none')) {
      progressDom.classList.remove('d-none');
    }

    localStorage.setItem('keyword', keyword);
    fetch(`${host.indexOf('localhost') > -1 ? 'http://' : 'https://'}${host}/index.xml`).then(resp => resp.text()).then(async (res) => {
      parser = new DOMParser();
      xmlDoc = parser.parseFromString(res, 'text/xml');
      const linkResult = xmlDoc.getElementsByTagName('link');
      const titleResult = xmlDoc.getElementsByTagName('title');
      const arr = [];

      const matched = [];
      await (async function searchLink() {
        for (let i = 0; i < linkResult.length; i++) {
          await fetch(linkResult[i].textContent).then(resp => resp.text().then(res => {
            const pureText = stripHtml(res);
            if (pureText.indexOf(keyword) >= 0) {
              matched.push(i);
            }
          }))
        }
      })();

      const googleSearchItem = createGoogleSearchItem(keyword);
      const node= document.createRange().createContextualFragment(googleSearchItem);
      resultDom.appendChild(node);

      matched.map((itemIndex, index) => {
        const r = createSearchItem(titleResult[itemIndex].textContent, linkResult[itemIndex].textContent, index + 1);
        const node = document.createRange().createContextualFragment(r);
        resultDom.appendChild(node);
      });

      if (progressDom && !progressDom.classList.contains('d-none')) {
        progressDom.classList.add('d-none');
      }
    });
  }

  const debounce = (callback, time) => {
    window.clearTimeout(debounceTimer);
    debounceTimer = window.setTimeout(callback, time);
  };

  ['focus', 'input'].forEach(event => {
    inputDom.addEventListener(event, (e) => {
      debounce(() => search(e.target.value), 500);
    }, false);
  });

  inputDom.addEventListener('blur', () => {
    setTimeout(() => {
      resultDom.innerHTML = '';
    }, 100);
  });

</script>



<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




</html>