<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Ayamir&#39;s blog</title>
    <link>https://ayamir.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Ayamir&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 25 Apr 2024 19:02:12 +0800</lastBuildDate>
    <atom:link href="https://ayamir.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ABI是什么？</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/abi/</link>
      <pubDate>Wed, 07 Feb 2024 12:51:01 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/abi/</guid>
      <description>ABI 是什么？ ABI: Application Binary Interface（应用二进制接口）。&#xA;其实就是针对 编译器 和 链接器 的二进制级别的一些规范和约束，主要规范的内容有：&#xA;规定函数的调用顺序，也称为“调用约定”，规定了如何将“函数”转换成汇编代码。 规定库函数如何表示，主要对链接过程有指导作用。 规定可以使用什么类型的数据，这些数据如何对齐以及其他低级细节。 ABI 还涉及到 OS 的内容，包括可执行文件的格式、虚拟地址空间布局等细节。 为什么会有 ABI ？ 原因其实很简单，硬件架构、OS、编译工具链以及编程语言的发展和逐层抽象让大部分程序员可以不太在意底层程序的执行过程，而只需要负责编写表明业务逻辑的源代码。大部分程序员不需要在意并不意味着这部分不存在，实际上，这部分内容是通向二进制文件执行的必经之路。&#xA;通过上面的分析可以知道， ABI 这个概念基本上是由(硬件架构, OS, 编译工具链, 编程语言)这个四元组决定的。&#xA;架构兼容性：amd64架构和arm64架构对应的指令集不同，因而一个可执行文件要想在这两个架构上成功运行，就需要编译这两个架构的二进制文件（也就是交叉编译）。 OS 兼容性：windows(PE-COFF), linux(ELF)和macos(MACH-O)上规定的程序二进制文件格式不同，因而也需要为不同的 OS 编译不同的二进制文件。 编译工具链兼容性：这个我们平时遇到的比较多，常见原因是不同的编译器或不同的编译器版本的名字修饰规则不同，导致链接器在链接时找不到对应名字的库函数。 编程语言兼容性：C 语言中的一些基本内容如不同类型数据在内存中存放的形式，寄存器的使用形式等，以及 C++的众多特性：虚函数如何调用、虚表的内容和分布形式、template 如何实例化等等，都是 ABI 所需要规定的内容。 ABI-Compatible ? ABI-compatible 允许编译好的目标代码可以无需修改或重新编译链接就能直接运行，而从上面举的例子就可以发现，ABI 兼容是一件很难做到的事情，光是架构和 OS 的不同就需要不同的目标文件了。&#xA;而编译工具链的兼容性容易做到吗？其实也不容易。目前主流的 C++编译工具链有gcc, llvm(clang)和msvc，这三者之间对于名字修饰的规定都不同，因而一个用clang编译的库函数是无法被一个用msvc编译的main文件调用的。当然，这里指的是默认进行名字修饰的情况，如果使用extern &amp;quot;C&amp;quot;对函数进行修饰，从而要求编译器使用 C 语言的编译和链接规范进行处理就可以解决这个问题。&#xA;C++一直被诟病的原因之一就是二进制兼容性不好，对于小型项目而言使用同一种编译器进行编译可能可行，但是对于大型项目而言不太现实，库代码的提供者通常只是提供编译链接好的库，并不提供源代码，所以要想做到对于所有的编译器（的所有版本）都进行支持是一件困难且不太现实的事情。</description>
    </item>
    <item>
      <title>重学C&#43;&#43;：容器和迭代器</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/iterator/</link>
      <pubDate>Thu, 28 Oct 2021 17:09:18 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/iterator/</guid>
      <description>常见的坑 所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。&#xA;string虽然不是容器，但是支持很多容器的操作。&#xA;容器不为空时：begin()返回的是容器中第一个元素的位置；end()返回的是容器中最后一个元素的后一个位置。&#xA;容器为空时：begin()和end()返回的都是最后一个元素的后一个位置。&#xA;任何可能改变容器大小的操作都会使容器的迭代器失效。&#xA;必须要理解的点 和指针类似的是，迭代器支持对对象的间接访问。&#xA;和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如begin(), end()。&#xA;所有迭代器都支持的运算：&#xA;运算符 例子 含义 * *iter 返回迭代器iter指向元素的引用 -&amp;gt; iter-&amp;gt;mem 解引用iter并获取该元素名为mem的成员，即(*iter).mem ++ ++iter 令iter指向当前元素的后一个元素 &amp;ndash; --iter 令iter指向当前元素的前一个元素 == iter1 == iter2 如果两个迭代器指向相同的元素返回true，否则返回false != iter1 != iter2 上面例子的反面 迭代器的类型有两种：iterator和const_iterator。&#xA;vector&amp;lt;int&amp;gt;::iterator itv; // 可用于读写vector&amp;lt;int&amp;gt;中的元素 string::iterator its; // 可用于读写string对象中的元素 vector&amp;lt;int&amp;gt;::const_iterator citv; // 只能读取元素 string::const_iterator cits; // 只能读取元素 begin()和end()返回哪一种取决于对象本身是否被const修饰。&#xA;C++11 中引入了cbegin()和cend()来专门返回const_iterator。&#xA;认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。&#xA;vector和string的迭代器支持的额外的运算：&#xA;运算 含义 iter + n 运算得到一个新迭代器，指向当前元素的后 n 个元素的位置 iter - n 运算得到一个新迭代器，指向当前元素的前 n 个元素的位置 iter += n 运算得到的新迭代器赋值给iter iter -= n 同上 iter1 - iter2 两个迭代器之间的距离，可正可负 &amp;gt;, &amp;lt;, &amp;lt;=, &amp;gt;= 同两类型的下标运算符中的数字的关系，位置靠前的较小 建议 一般不在意迭代器的类型，因此使用auto来标注。 循环结束的判断条件习惯使用迭代器和!</description>
    </item>
    <item>
      <title>重学C&#43;&#43;：标准库类模板Vector</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/vector/</link>
      <pubDate>Thu, 28 Oct 2021 15:35:17 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/vector/</guid>
      <description>常见的坑与用法 vector的默认初始化是否合法取决于vector内对象所属的类是否要求显式初始化。&#xA;使用()和{}对vector执行初始化含义不同。&#xA;using std::vector; vector&amp;lt;int&amp;gt; v1{10}; // 存储1个int对象，值为10 vector&amp;lt;int&amp;gt; v2(10); // 存储10个int对象，值为0 vector&amp;lt;int&amp;gt; v3(10, 1); // 存储10个int对象，值都是1 vector&amp;lt;int&amp;gt; v4{10, 1}; // 存储2个int对象，值分别是10和1 使用{}执行列表初始化时按照顺序遵守 2 个守则：&#xA;如果{}内容可以用于初始化，则采用{}默认的初始化含义。&#xA;如果{}中的内容无法用{}默认的初始化含义做出解释，则会按照()的初始化含义去解释{}。&#xA;using std::vector; using std::string; vector&amp;lt;string&amp;gt; v1{&amp;#34;hi&amp;#34;}; // 存储1个值为hi的string对象 vector&amp;lt;string&amp;gt; v2{10}; // 存储10个值为空的string对象 vector&amp;lt;string&amp;gt; v3{10, &amp;#34;hi&amp;#34;}; // 存储10个值为hi的string对象 与string相同，vector也有size_type作为其size()的返回值类型。&#xA;但是使用时必须首先指定vector由哪个类型定义。&#xA;std::vector&amp;lt;int&amp;gt;::size_type a; // 正确 std::vector::size_type a; // 错误 只有vector内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。&#xA;增加vector中的元素只能使用push_back() or emplace_back()，而不能使用对下标赋值的方式。&#xA;push_back() 和 emplace_back() 的区别来自于两者的函数签名不同：&#xA;emplace_back() 支持通过传入参数在 vector 内部原地构造对象，因而只会调用构造函数 1 次； push_back() 不支持，所以至少会调用 2 次构造函数和 1 次析构函数（临时对象的构造函数和析构函数、vector 内对象的拷贝或移动构造函数）； 两者都支持传入右值引用作为参数，因而可以使用 push_back(std::move(obj)) or emplace_back(std::move(obj)) 来避免对象拷贝操作，从而改善性能。 可以使用 vector 来模拟 stack 的行为：</description>
    </item>
    <item>
      <title>重学C&#43;&#43;：标准库类型string</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/string/</link>
      <pubDate>Thu, 28 Oct 2021 10:31:33 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/string/</guid>
      <description>常见的坑 string.size()和string.length()等价。&#xA;string.size()和其他STL容器的命名风格相一致（如vector, map）。&#xA;string.length()出现主要是因为这样的命名符合人的直觉，有更好的可读性。&#xA;string::size_type是无符号类型，和int不同，能存放下任何string对象的大小。&#xA;+两边至少有一端需要是string对象，不允许两个字符串字面量单独相加。&#xA;using std::string; string a = &amp;#34;a&amp;#34;; string b = a + &amp;#34;b&amp;#34; + &amp;#34;c&amp;#34;; // 正确，从左到右运算时能保证至少一段是string对象 string c = &amp;#34;b&amp;#34; + &amp;#34;c&amp;#34; + a; // 错误，从左到右运算时第一个+左右都是字符串字面量 必须要理解的点 string的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。&#xA;string.size()返回值类型为string::size_type，出现这种类型是为了体现标准库类型和机器无关的特性。&#xA;string对象的比较运算完全实现了运算符重载（==, !=, &amp;lt;,&amp;lt;=, &amp;gt;, &amp;gt;=）。&#xA;==表明两个对象的内容和长度完全一致，反之任一不同则!=。&#xA;不等关系运算符比较的法则：&#xA;如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。 如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。 string对象赋值操作就是内容的替换。&#xA;string对象相加操作就是内容的拼接，+=操作同理。&#xA;string对象可以与字符串字面量相加。&#xA;形如cname的C++头文件兼容形如ctype.h的C头文件，C++头文件中定义的名字可以在std中找到。&#xA;建议 表达式中出现string.size()函数时就不应该使用int类型，这样可以避免int和unsigned混用的问题。&#xA;C++和C兼容的头文件作选择时，选择C++的头文件。&#xA;处理string对象中每一个字符时，使用foreach语句。&#xA;#include &amp;lt;iostream&amp;gt; #include &amp;lt;cctype&amp;gt; using std::string; string str{&amp;#34;Some String&amp;#34;}; for (auto c : str) { std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl; } // 使用引用来改变原字符串内容 for (auto &amp;amp;c : str) { c = std::toupper(c); } std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl; 处理string对象中特定字符时使用[]（下标运算符）或者迭代器。</description>
    </item>
    <item>
      <title>重学C&#43;&#43;：类型推导</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/auto/</link>
      <pubDate>Tue, 26 Oct 2021 21:14:32 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/auto/</guid>
      <description>常见的坑 auto可以在一条语句中声明多个变量，但是所有变量的类型必须一致。&#xA;decltype在分析表达式类型时并不执行表达式。&#xA;decltype处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。&#xA;decltype((variable))的结果永远是引用。&#xA;decltype(variable)的结果只有当variable是引用时才是引用。&#xA;必须要理解的点 auto用于变量初始化时的类型推导，decltype用于分析表达式的类型。 auto对引用类型推导时实际上用的是引用对象的值。 auto与const：详见重学 C++：Const 二三事。 decltype与const：详见重学 C++：Const 二三事。 建议 auto尽量只在类型较长但比较清晰时使用。 decltype尽量不要使用。 </description>
    </item>
    <item>
      <title>重学C&#43;&#43;：Const二三事</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/const/</link>
      <pubDate>Tue, 26 Oct 2021 15:53:11 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/const/</guid>
      <description>常见的坑 仅用const修饰的对象只在单个文件中有效，如果想在多个文件之间共享const对象，必须在对象定义的前面加extern。&#xA;允许为一个常量引用绑定非常量的对象、字面量和表达式。&#xA;int i = 42; const int &amp;amp;r1 = i; // 正确 const int &amp;amp;r2 = 42; // 正确 const int &amp;amp;r3 = r1 * 2; // 正确 int &amp;amp;r4 = r1 * 2; // 错误 int &amp;amp;r5 = i; r5 = 0; // 正确 r1 = 42; // 错误 指向常量的指针和常量指针：&#xA;int err_numb = 0; const double pi = 3.1415; int *const cur_err = &amp;amp;err_numb; const double *mut_pi_pointer = &amp;amp;pi; const double *const pi_pointer = &amp;amp;pi; 从声明语句的变量符号开始，自右向左看：</description>
    </item>
    <item>
      <title>重学C&#43;&#43;：引用和指针</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/reference-and-pointer/</link>
      <pubDate>Tue, 26 Oct 2021 15:49:49 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/reference-and-pointer/</guid>
      <description>常见的坑 &amp;amp;和*在不同的上下文里面其含义并不相同，因此完全可以当成不同的符号看待。&#xA;int i = 42; int &amp;amp;r = i; // &amp;amp;在类型名后出现，是声明的一部分，表明r是一个引用 int *p; // *在类型名后出现，是声明的一部分，表明p是一个指针 p = &amp;amp;i; // &amp;amp;在表达式中出现，是取地址符 *p = 43; // *在表达式中出现，是解引用符 int &amp;amp;r2 = *p; // &amp;amp;是声明的一部分，*是解引用符 指针可以用0进行初始化成空指针，但是不可以用0赋值。&#xA;指针之间使用==来比较时，如果结果是true，对应多种情况：&#xA;都是空指针 都是同一个地址 都指向同一个对象 一个指针指向某一个对象，另一个指针指向另一对象的下一地址 必须要理解的点 引用和指针——都可以用于间接访问对象&#xA;引用 指针 复合类型 ✅ ✅ 表示符号 &amp;amp; * 含义 变量的别名 变量在内存中的地址 初始化和赋值时是否需要类型匹配 必须匹配（除常量引用） 必须匹配（除 void*和指向常量的指针） 是否需要初始化 必须初始化 无需初始化 可否重新绑定其他变量 不可以 可以 可否嵌套定义 不可以 可以 引用：&#xA;引用只能绑定在对象上，不能绑定在字面量或者表达式上。 引用只是原有对象的别名，并非对象，因此不可以定义引用的引用。 定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。 指针：&#xA;指针本身就是一个对象，能执行的操作自由度远超过引用。</description>
    </item>
    <item>
      <title>重学C&#43;&#43;：类型系统基础</title>
      <link>https://ayamir.github.io/posts/knowledge/cpp/Cpp-Types/</link>
      <pubDate>Mon, 18 Oct 2021 19:32:22 +0800</pubDate>
      <guid>https://ayamir.github.io/posts/knowledge/cpp/Cpp-Types/</guid>
      <description>常见的坑 int, short, long, long long都是带符号的，在前面添加unsigned就能得到无符号类型。&#xA;字符型被分为 3 种：char, signed char, unsigned char，前两种并不等价。 虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。&#xA;有符号类型在与无符号类型运算时会隐式转换为无符号类型。&#xA;虽然变量初始化时候使用了=号，但是初始化和变量赋值并不相同。&#xA;变量默认初始化：&#xA;变量类型 位置在函数内部 位置在函数外部 内置类型 undefined 0 自定义类型 由类决定 由类决定 #include &amp;lt;iostream&amp;gt; int default_initialize(int a) { // 输出必定是0 std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; int b; return b; } int main() { int a; // 输出是随机值 std::cout &amp;lt;&amp;lt; default_initialize(a) &amp;lt;&amp;lt; std::endl; } 如果在函数体内部试图初始化一个extern标记的变量会引发错误。&#xA;在嵌套作用域中，内层作用域中的定义可以覆盖外层作用域中声明的变量。&#xA;可以显式使用域操作符::来指明使用哪层的变量。&#xA;必须要理解的点 字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。&#xA;变量的组成部分：类型和值。说白了就是一个定性一个定量。&#xA;类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。&#xA;值在实际代码运行过程中则被各种函数使用参与运算。&#xA;变量声明和定义：&#xA;声明的意思就是：我要用这个变量。&#xA;定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。&#xA;声明 定义 规定变量的类型和名字 ✅ ✅ 申请空间 ✅ 初始化 ✅ 执行多次 ✅ 用extern标记未初始化的变量来表明只对变量作声明：</description>
    </item>
  </channel>
</rss>
