<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Ayamir&#39;s Blog</title>
    <link>https://ayamir.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Ayamir&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Oct 2021 17:09:18 +0800</lastBuildDate><atom:link href="https://ayamir.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>重学C&#43;&#43;：容器和迭代器</title>
      <link>https://ayamir.github.io/posts/iterator/</link>
      <pubDate>Thu, 28 Oct 2021 17:09:18 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/iterator/</guid>
      <description>常见的坑 所有标准库容器都支持迭代器，而只有少数几种支持下标运算符。
string虽然不是容器，但是支持很多容器的操作。
容器不为空时：begin()返回的是容器中第一个元素的位置；end()返回的是容器中最后一个元素的后一个位置。
容器为空时：begin()和end()返回的都是最后一个元素的后一个位置。
任何可能改变容器大小的操作都会使容器的迭代器失效。
必须要理解的点 和指针类似的是，迭代器支持对对象的间接访问。
和指针不同的是，获取迭代器不使用取地址符，有迭代器的类型都拥有返回迭代器的成员函数，如begin(), end()。
所有迭代器都支持的运算：
运算符 例子 含义 * *iter 返回迭代器iter指向元素的引用 -&amp;gt; iter-&amp;gt;mem 解引用iter并获取该元素名为mem的成员，即(*iter).mem ++ ++iter 令iter指向当前元素的后一个元素 &amp;ndash; --iter 令iter指向当前元素的前一个元素 == iter1 == iter2 如果两个迭代器指向相同的元素返回true，否则返回false != iter1 != iter2 上面例子的反面 迭代器的类型有两种：iterator和const_iterator。
vector&amp;lt;int&amp;gt;::iterator itv; // 可用于读写vector&amp;lt;int&amp;gt;中的元素 string::iterator its; // 可用于读写string对象中的元素 vector&amp;lt;int&amp;gt;::const_iterator citv; // 只能读取元素 string::const_iterator cits; // 只能读取元素 begin()和end()返回哪一种取决于对象本身是否被const修饰。
C++11中引入了cbegin()和cend()来专门返回const_iterator。
认定一种类型是迭代器当且仅当它支持一套操作，这套操作能使我们访问容器内的元素或从某一个元素移动到另一个元素。
vector和string的迭代器支持的额外的运算：
运算 含义 iter + n 运算得到一个新迭代器，指向当前元素的后n个元素的位置 iter - n 运算得到一个新迭代器，指向当前元素的前n个元素的位置 iter += n 运算得到的新迭代器赋值给iter iter -= n 同上 iter1 - iter2 两个迭代器之间的距离，可正可负 &amp;gt;, &amp;lt;, &amp;lt;=, &amp;gt;= 同两类型的下标运算符中的数字的关系，位置靠前的较小 建议 一般不在意迭代器的类型，因此使用auto来标注。 循环结束的判断条件习惯使用迭代器和!</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：标准库类模板Vector</title>
      <link>https://ayamir.github.io/posts/vector/</link>
      <pubDate>Thu, 28 Oct 2021 15:35:17 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/vector/</guid>
      <description>常见的坑 vector的默认初始化是否合法取决于vector内对象所属的类是否要求显式初始化。
使用()和{}对vector执行初始化含义不同。
using std::vector; vector&amp;lt;int&amp;gt; v1{10}; // 存储1个int对象，值为10 vector&amp;lt;int&amp;gt; v2(10); // 存储10个int对象，值为0 vector&amp;lt;int&amp;gt; v3(10, 1); // 存储10个int对象，值都是1 vector&amp;lt;int&amp;gt; v4{10, 1}; // 存储2个int对象，值分别是10和1 使用{}执行列表初始化时按照顺序遵守2个守则：
如果{}内容可以用于初始化，则采用{}默认的初始化含义。
如果{}中的内容无法用{}默认的初始化含义做出解释，则会按照()的初始化含义去解释{}。
using std::vector; using std::string; vector&amp;lt;string&amp;gt; v1{&amp;#34;hi&amp;#34;}; // 存储1个值为hi的string对象 vector&amp;lt;string&amp;gt; v2{10}; // 存储10个值为空的string对象 vector&amp;lt;string&amp;gt; v3{10, &amp;#34;hi&amp;#34;}; // 存储10个值为hi的string对象 与string相同，vector也有size_type作为其size()的返回值类型。
但是使用时必须首先指定vector由哪个类型定义。
std::vector&amp;lt;int&amp;gt;::size_type a; // 正确 std::vector::size_type a; // 错误 只有vector内元素的类型可以被比较时才能做比较运算，对于自定义类型需要手动定义运算符重载。
增加vector中的元素只能使用push_back()，而不能使用对下标赋值的方式。
必须理解的点 vector是类模板而非类型。 vector中只能容纳对象，不能容纳引用。 vector对象能高效增长，增加vector中的元素需要使用push_back()成员函数。 vector的成员函数（empty(), size()）和各种运算符（赋值、关系、下标）的操作使用方法和规则基本同string。 建议 不需要在创建vector时确定其中的元素及其大小。 在循环体内部包含向vector对象添加元素的操作时，不应该使用foreach循环。 </description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：标准库类型string</title>
      <link>https://ayamir.github.io/posts/string/</link>
      <pubDate>Thu, 28 Oct 2021 10:31:33 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/string/</guid>
      <description>常见的坑 string.size()和string.length()等价。
string.size()和其他STL容器的命名风格相一致（如vector, map）。
string.length()出现主要是因为这样的命名符合人的直觉，有更好的可读性。
string::size_type是无符号类型，和int不同，能存放下任何string对象的大小。
+两边至少有一端需要是string对象，不允许两个字符串字面量单独相加。
using std::string; string a = &amp;#34;a&amp;#34;; string b = a + &amp;#34;b&amp;#34; + &amp;#34;c&amp;#34;; // 正确，从左到右运算时能保证至少一段是string对象 string c = &amp;#34;b&amp;#34; + &amp;#34;c&amp;#34; + a; // 错误，从左到右运算时第一个+左右都是字符串字面量 必须要理解的点 string的初始化方式有两种，一种是默认初始化，另一种是拷贝初始化。
string.size()返回值类型为string::size_type，出现这种类型是为了体现标准库类型和机器无关的特性。
string对象的比较运算完全实现了运算符重载（==, !=, &amp;lt;,&amp;lt;=, &amp;gt;, &amp;gt;=）。
==表明两个对象的内容和长度完全一致，反之任一不同则!=。
不等关系运算符比较的法则：
如果两个对象长度不同，但是从前到后内容一致，则长度较短的对象较小。 如果两个对象从前到后有对应位置的字符不同，则这个位置的两个字符的大小关系就是两个对象的大小关系。 string对象赋值操作就是内容的替换。
string对象相加操作就是内容的拼接，+=操作同理。
string对象可以与字符串字面量相加。
形如cname的C++头文件兼容形如ctype.h的C头文件，C++头文件中定义的名字可以在std中找到。
建议 表达式中出现string.size()函数时就不应该使用int类型，这样可以避免int和unsigned混用的问题。
C++和C兼容的头文件作选择时，选择C++的头文件。
处理string对象中每一个字符时，使用foreach语句。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cctype&amp;gt; using std::string; string str{&amp;#34;Some String&amp;#34;}; for (auto c : str) { std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl; } // 使用引用来改变原字符串内容 for (auto &amp;amp;c : str) { c = std::toupper(c); } std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl; 处理string对象中特定字符时使用[]（下标运算符）或者迭代器。</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：类型推导</title>
      <link>https://ayamir.github.io/posts/auto/</link>
      <pubDate>Tue, 26 Oct 2021 21:14:32 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/auto/</guid>
      <description>常见的坑 auto可以在一条语句中声明多个变量，但是所有变量的类型必须一致。
decltype在分析表达式类型时并不执行表达式。
decltype处理解引用操作之后返回的是引用类型，而引用类型的变量必须初始化。
decltype((variable))的结果永远是引用。
decltype(variable)的结果只有当variable是引用时才是引用。
必须要理解的点 auto用于变量初始化时的类型推导，decltype用于分析表达式的类型。 auto对引用类型推导时实际上用的是引用对象的值。 auto与const：详见重学C++：Const二三事。 decltype与const：详见重学C++：Const二三事。 建议 auto尽量只在类型较长但比较清晰时使用。 decltype尽量不要使用。 </description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：Const二三事</title>
      <link>https://ayamir.github.io/posts/const/</link>
      <pubDate>Tue, 26 Oct 2021 15:53:11 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/const/</guid>
      <description>常见的坑 仅用const修饰的对象只在单个文件中有效，如果想在多个文件之间共享const对象，必须在对象定义的前面加extern。
允许为一个常量引用绑定非常量的对象、字面量和表达式。
int i = 42; const int &amp;amp;r1 = i; // 正确 const int &amp;amp;r2 = 42; // 正确 const int &amp;amp;r3 = r1 * 2; // 正确 int &amp;amp;r4 = r1 * 2; // 错误 int &amp;amp;r5 = i; r5 = 0; // 正确 r1 = 42; // 错误 指向常量的指针和常量指针：
int err_numb = 0; const double pi = 3.1415; int *const cur_err = &amp;amp;err_numb; const double *mut_pi_pointer = &amp;amp;pi; const double *const pi_pointer = &amp;amp;pi; 从声明语句的变量符号开始，自右向左看：</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：引用和指针</title>
      <link>https://ayamir.github.io/posts/reference-and-pointer/</link>
      <pubDate>Tue, 26 Oct 2021 15:49:49 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/reference-and-pointer/</guid>
      <description>常见的坑 &amp;amp;和*在不同的上下文里面其含义并不相同，因此完全可以当成不同的符号看待。
int i = 42; int &amp;amp;r = i; // &amp;amp;在类型名后出现，是声明的一部分，表明r是一个引用 int *p; // *在类型名后出现，是声明的一部分，表明p是一个指针 p = &amp;amp;i; // &amp;amp;在表达式中出现，是取地址符 *p = 43; // *在表达式中出现，是解引用符 int &amp;amp;r2 = *p; // &amp;amp;是声明的一部分，*是解引用符 指针可以用0进行初始化成空指针，但是不可以用0赋值。
指针之间使用==来比较时，如果结果是true，对应多种情况：
都是空指针 都是同一个地址 都指向同一个对象 一个指针指向某一个对象，另一个指针指向另一对象的下一地址 必须要理解的点 引用和指针——都可以用于间接访问对象
引用 指针 复合类型 ✅ ✅ 表示符号 &amp;amp; * 含义 变量的别名 变量在内存中的地址 初始化和赋值时是否需要类型匹配 必须匹配（除常量引用） 必须匹配（除void*和指向常量的指针） 是否需要初始化 必须初始化 无需初始化 可否重新绑定其他变量 不可以 可以 可否嵌套定义 不可以 可以 引用：
引用只能绑定在对象上，不能绑定在字面量或者表达式上。 引用只是原有对象的别名，并非对象，因此不可以定义引用的引用。 定义引用时并不开辟新的内存空间，因此不可以定义引用的指针。 指针：
指针本身就是一个对象，能执行的操作自由度远超过引用。
可以实现嵌套定义，即指针的指针。</description>
    </item>
    
    <item>
      <title>重学C&#43;&#43;：类型系统基础</title>
      <link>https://ayamir.github.io/posts/cpp-types/</link>
      <pubDate>Mon, 18 Oct 2021 19:32:22 +0800</pubDate>
      
      <guid>https://ayamir.github.io/posts/cpp-types/</guid>
      <description>常见的坑 int, short, long, long long都是带符号的，在前面添加unsigned就能得到无符号类型。
字符型被分为3种：char, signed char, unsigned char，前两种并不等价。 虽然有三种类型，但是实际上只有两种表现形式：有符号的和无符号的。
有符号类型在与无符号类型运算时会隐式转换为无符号类型。
虽然变量初始化时候使用了=号，但是初始化和变量赋值并不相同。
变量默认初始化：
变量类型 位置在函数内部 位置在函数外部 内置类型 undefined 0 自定义类型 由类决定 由类决定 #include &amp;lt;iostream&amp;gt; int default_initialize(int a) { // 输出必定是0 std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; int b; return b; } int main() { int a; // 输出是随机值 std::cout &amp;lt;&amp;lt; default_initialize(a) &amp;lt;&amp;lt; std::endl; } 如果在函数体内部试图初始化一个extern标记的变量会引发错误。
在嵌套作用域中，内层作用域中的定义可以覆盖外层作用域中声明的变量。
可以显式使用域操作符::来指明使用哪层的变量。
必须要理解的点 字面量的意思就是从这个表示形式就能推断其对应类型的量，不同表示形式的字面量和不同类型是多对一的关系。
变量的组成部分：类型和值。说白了就是一个定性一个定量。
类型决定变量在内存里面的存储方式，包括大小和布局方式，以及能参与的运算。
值在实际代码运行过程中则被各种函数使用参与运算。
变量声明和定义：
声明的意思就是：我要用这个变量。
定义的意思就是：我要对这个操作的变量做出定义，规定其具体的细节。
声明 定义 规定变量的类型和名字 ✅ ✅ 申请空间 ✅ 初始化 ✅ 执行多次 ✅ 用extern标记未初始化的变量来表明只对变量作声明：</description>
    </item>
    
  </channel>
</rss>
